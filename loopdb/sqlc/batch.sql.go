// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: batch.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const confirmBatch = `-- name: ConfirmBatch :exec
UPDATE
        sweep_batches
SET
        confirmed = TRUE
WHERE
        id = $1
`

func (q *Queries) ConfirmBatch(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, confirmBatch, id)
	return err
}

const getBatchSweeps = `-- name: GetBatchSweeps :many
SELECT
        sweeps.id, sweeps.swap_hash, sweeps.batch_id, sweeps.outpoint_txid, sweeps.outpoint_index, sweeps.amt, sweeps.completed,
        swaps.id, swaps.swap_hash, swaps.preimage, swaps.initiation_time, swaps.amount_requested, swaps.cltv_expiry, swaps.max_miner_fee, swaps.max_swap_fee, swaps.initiation_height, swaps.protocol_version, swaps.label,
        loopout_swaps.swap_hash, loopout_swaps.dest_address, loopout_swaps.swap_invoice, loopout_swaps.max_swap_routing_fee, loopout_swaps.sweep_conf_target, loopout_swaps.htlc_confirmations, loopout_swaps.outgoing_chan_set, loopout_swaps.prepay_invoice, loopout_swaps.max_prepay_routing_fee, loopout_swaps.publication_deadline, loopout_swaps.single_sweep,
        htlc_keys.swap_hash, htlc_keys.sender_script_pubkey, htlc_keys.receiver_script_pubkey, htlc_keys.sender_internal_pubkey, htlc_keys.receiver_internal_pubkey, htlc_keys.client_key_family, htlc_keys.client_key_index
FROM
        sweeps
JOIN
        swaps ON sweeps.swap_hash = swaps.swap_hash
JOIN
        loopout_swaps ON sweeps.swap_hash = loopout_swaps.swap_hash
JOIN
        htlc_keys ON sweeps.swap_hash = htlc_keys.swap_hash
WHERE
        sweeps.batch_id = $1
ORDER BY
        sweeps.id ASC
`

type GetBatchSweepsRow struct {
	ID                     int32
	SwapHash               []byte
	BatchID                int32
	OutpointTxid           []byte
	OutpointIndex          int32
	Amt                    int64
	Completed              bool
	ID_2                   int32
	SwapHash_2             []byte
	Preimage               []byte
	InitiationTime         time.Time
	AmountRequested        int64
	CltvExpiry             int32
	MaxMinerFee            int64
	MaxSwapFee             int64
	InitiationHeight       int32
	ProtocolVersion        int32
	Label                  string
	SwapHash_3             []byte
	DestAddress            string
	SwapInvoice            string
	MaxSwapRoutingFee      int64
	SweepConfTarget        int32
	HtlcConfirmations      int32
	OutgoingChanSet        string
	PrepayInvoice          string
	MaxPrepayRoutingFee    int64
	PublicationDeadline    time.Time
	SingleSweep            bool
	SwapHash_4             []byte
	SenderScriptPubkey     []byte
	ReceiverScriptPubkey   []byte
	SenderInternalPubkey   []byte
	ReceiverInternalPubkey []byte
	ClientKeyFamily        int32
	ClientKeyIndex         int32
}

func (q *Queries) GetBatchSweeps(ctx context.Context, batchID int32) ([]GetBatchSweepsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBatchSweeps, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBatchSweepsRow
	for rows.Next() {
		var i GetBatchSweepsRow
		if err := rows.Scan(
			&i.ID,
			&i.SwapHash,
			&i.BatchID,
			&i.OutpointTxid,
			&i.OutpointIndex,
			&i.Amt,
			&i.Completed,
			&i.ID_2,
			&i.SwapHash_2,
			&i.Preimage,
			&i.InitiationTime,
			&i.AmountRequested,
			&i.CltvExpiry,
			&i.MaxMinerFee,
			&i.MaxSwapFee,
			&i.InitiationHeight,
			&i.ProtocolVersion,
			&i.Label,
			&i.SwapHash_3,
			&i.DestAddress,
			&i.SwapInvoice,
			&i.MaxSwapRoutingFee,
			&i.SweepConfTarget,
			&i.HtlcConfirmations,
			&i.OutgoingChanSet,
			&i.PrepayInvoice,
			&i.MaxPrepayRoutingFee,
			&i.PublicationDeadline,
			&i.SingleSweep,
			&i.SwapHash_4,
			&i.SenderScriptPubkey,
			&i.ReceiverScriptPubkey,
			&i.SenderInternalPubkey,
			&i.ReceiverInternalPubkey,
			&i.ClientKeyFamily,
			&i.ClientKeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchSweptAmount = `-- name: GetBatchSweptAmount :one
SELECT
        SUM(amt) AS total
FROM
        sweeps
WHERE
        batch_id = $1
AND
        completed = TRUE
`

func (q *Queries) GetBatchSweptAmount(ctx context.Context, batchID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBatchSweptAmount, batchID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getParentBatch = `-- name: GetParentBatch :one
SELECT
        sweep_batches.id, sweep_batches.confirmed, sweep_batches.batch_tx_id, sweep_batches.batch_pk_script, sweep_batches.last_rbf_height, sweep_batches.last_rbf_sat_per_kw, sweep_batches.max_timeout_distance
FROM
        sweep_batches
JOIN
        sweeps ON sweep_batches.id = sweeps.batch_id
WHERE
        sweeps.swap_hash = $1
AND
        sweeps.completed = TRUE
AND   
        sweep_batches.confirmed = TRUE
`

func (q *Queries) GetParentBatch(ctx context.Context, swapHash []byte) (SweepBatch, error) {
	row := q.db.QueryRowContext(ctx, getParentBatch, swapHash)
	var i SweepBatch
	err := row.Scan(
		&i.ID,
		&i.Confirmed,
		&i.BatchTxID,
		&i.BatchPkScript,
		&i.LastRbfHeight,
		&i.LastRbfSatPerKw,
		&i.MaxTimeoutDistance,
	)
	return i, err
}

const getSweepStatus = `-- name: GetSweepStatus :one
SELECT
    COALESCE(s.completed, f.false_value) AS completed
FROM
    (SELECT false AS false_value) AS f
LEFT JOIN
    sweeps s ON s.swap_hash = $1
`

func (q *Queries) GetSweepStatus(ctx context.Context, swapHash []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, getSweepStatus, swapHash)
	var completed bool
	err := row.Scan(&completed)
	return completed, err
}

const getUnconfirmedBatches = `-- name: GetUnconfirmedBatches :many
SELECT
        id, confirmed, batch_tx_id, batch_pk_script, last_rbf_height, last_rbf_sat_per_kw, max_timeout_distance
FROM
        sweep_batches
WHERE
        confirmed = FALSE
`

func (q *Queries) GetUnconfirmedBatches(ctx context.Context) ([]SweepBatch, error) {
	rows, err := q.db.QueryContext(ctx, getUnconfirmedBatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SweepBatch
	for rows.Next() {
		var i SweepBatch
		if err := rows.Scan(
			&i.ID,
			&i.Confirmed,
			&i.BatchTxID,
			&i.BatchPkScript,
			&i.LastRbfHeight,
			&i.LastRbfSatPerKw,
			&i.MaxTimeoutDistance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBatch = `-- name: InsertBatch :one
INSERT INTO sweep_batches (
        confirmed,
        batch_tx_id,
        batch_pk_script,
        last_rbf_height,
        last_rbf_sat_per_kw,
        max_timeout_distance
) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
) RETURNING id
`

type InsertBatchParams struct {
	Confirmed          bool
	BatchTxID          sql.NullString
	BatchPkScript      []byte
	LastRbfHeight      sql.NullInt32
	LastRbfSatPerKw    sql.NullInt32
	MaxTimeoutDistance int32
}

func (q *Queries) InsertBatch(ctx context.Context, arg InsertBatchParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertBatch,
		arg.Confirmed,
		arg.BatchTxID,
		arg.BatchPkScript,
		arg.LastRbfHeight,
		arg.LastRbfSatPerKw,
		arg.MaxTimeoutDistance,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateBatch = `-- name: UpdateBatch :exec
UPDATE sweep_batches SET
        confirmed = $2,
        batch_tx_id = $3,
        batch_pk_script = $4,
        last_rbf_height = $5,
        last_rbf_sat_per_kw = $6
WHERE id = $1
`

type UpdateBatchParams struct {
	ID              int32
	Confirmed       bool
	BatchTxID       sql.NullString
	BatchPkScript   []byte
	LastRbfHeight   sql.NullInt32
	LastRbfSatPerKw sql.NullInt32
}

func (q *Queries) UpdateBatch(ctx context.Context, arg UpdateBatchParams) error {
	_, err := q.db.ExecContext(ctx, updateBatch,
		arg.ID,
		arg.Confirmed,
		arg.BatchTxID,
		arg.BatchPkScript,
		arg.LastRbfHeight,
		arg.LastRbfSatPerKw,
	)
	return err
}

const upsertSweep = `-- name: UpsertSweep :exec
INSERT INTO sweeps (
        swap_hash,
        batch_id,
        outpoint_txid,
        outpoint_index,
        amt,
        completed
) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
) ON CONFLICT (swap_hash) DO UPDATE SET
        batch_id = $2,
        outpoint_txid = $3,
        outpoint_index = $4,
        amt = $5,
        completed = $6
`

type UpsertSweepParams struct {
	SwapHash      []byte
	BatchID       int32
	OutpointTxid  []byte
	OutpointIndex int32
	Amt           int64
	Completed     bool
}

func (q *Queries) UpsertSweep(ctx context.Context, arg UpsertSweepParams) error {
	_, err := q.db.ExecContext(ctx, upsertSweep,
		arg.SwapHash,
		arg.BatchID,
		arg.OutpointTxid,
		arg.OutpointIndex,
		arg.Amt,
		arg.Completed,
	)
	return err
}

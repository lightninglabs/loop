// Code generated by protoc-gen-go. DO NOT EDIT.
// source: server.proto

package looprpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//*
//This enum defines the protocol versions that clients may adhere to. Note that
//this is not a flagged enum. If a particular protocol version adds a feature,
//then in general all the preceding features are also supported. Exception to this
//is when features get deprecated.
type ProtocolVersion int32

const (
	/// No protocol version reported at all.
	ProtocolVersion_LEGACY ProtocolVersion = 0
	/// Client may attempt to send the loop out payment in multiple parts.
	ProtocolVersion_MULTI_LOOP_OUT ProtocolVersion = 1
	//*
	//Loop will use native segwit (P2WSH) htlcs by default, while externally
	//published htlcs may use native (P2WSH) or nested (NP2WSH) segwit as well.
	ProtocolVersion_NATIVE_SEGWIT_LOOP_IN ProtocolVersion = 2
	//
	//Once the on chain loop out htlc is confirmed, the client can push the swap
	//preimage to the server to speed up claim of their off chain htlc (acquiring
	//incoming liquidity more quickly than if the server waited for the on chain
	//claim tx).
	ProtocolVersion_PREIMAGE_PUSH_LOOP_OUT ProtocolVersion = 3
)

var ProtocolVersion_name = map[int32]string{
	0: "LEGACY",
	1: "MULTI_LOOP_OUT",
	2: "NATIVE_SEGWIT_LOOP_IN",
	3: "PREIMAGE_PUSH_LOOP_OUT",
}

var ProtocolVersion_value = map[string]int32{
	"LEGACY":                 0,
	"MULTI_LOOP_OUT":         1,
	"NATIVE_SEGWIT_LOOP_IN":  2,
	"PREIMAGE_PUSH_LOOP_OUT": 3,
}

func (x ProtocolVersion) String() string {
	return proto.EnumName(ProtocolVersion_name, int32(x))
}

func (ProtocolVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{0}
}

// ServerSwapState is an enum which represents all the states a swap may have
// from the server's perspective.
type ServerSwapState int32

const (
	// The server has created the swap.
	ServerSwapState_INITIATED ServerSwapState = 0
	// The server has published the loop out on chain htlc.
	ServerSwapState_HTLC_PUBLISHED ServerSwapState = 1
	// The swap completed successfully.
	ServerSwapState_SUCCESS ServerSwapState = 2
	//
	//The swap failed for a reason that is unknown to the server, this is only
	//set for older swaps.
	ServerSwapState_FAILED_UNKNOWN ServerSwapState = 3
	// No htlc was confirmed in time for the loop in swap to complete.
	ServerSwapState_FAILED_NO_HTLC ServerSwapState = 4
	// A loop in htlc confirmed on chain, but it did not have the correct value.
	ServerSwapState_FAILED_INVALID_HTLC_AMOUNT ServerSwapState = 5
	//
	//We did not succeed in completing the loop in off chain payment before the
	//timeout.
	ServerSwapState_FAILED_OFF_CHAIN_TIMEOUT ServerSwapState = 6
	// The on chain timeout was claimed.
	ServerSwapState_FAILED_TIMEOUT ServerSwapState = 7
	//
	//The server could not publish the loop out on chain htlc before the deadline
	//provided.
	ServerSwapState_FAILED_SWAP_DEADLINE ServerSwapState = 8
	// The server could not publish the loop out on chain htlc.
	ServerSwapState_FAILED_HTLC_PUBLICATION ServerSwapState = 9
	// The server has published the loop out on chain timeout tx.
	ServerSwapState_TIMEOUT_PUBLISHED ServerSwapState = 10
	// The swap has failed for unknown reasons, it will not be completed.
	ServerSwapState_UNEXPECTED_FAILURE ServerSwapState = 11
	// The swap htlc has confirmed on chain.
	ServerSwapState_HTLC_CONFIRMED ServerSwapState = 12
)

var ServerSwapState_name = map[int32]string{
	0:  "INITIATED",
	1:  "HTLC_PUBLISHED",
	2:  "SUCCESS",
	3:  "FAILED_UNKNOWN",
	4:  "FAILED_NO_HTLC",
	5:  "FAILED_INVALID_HTLC_AMOUNT",
	6:  "FAILED_OFF_CHAIN_TIMEOUT",
	7:  "FAILED_TIMEOUT",
	8:  "FAILED_SWAP_DEADLINE",
	9:  "FAILED_HTLC_PUBLICATION",
	10: "TIMEOUT_PUBLISHED",
	11: "UNEXPECTED_FAILURE",
	12: "HTLC_CONFIRMED",
}

var ServerSwapState_value = map[string]int32{
	"INITIATED":                  0,
	"HTLC_PUBLISHED":             1,
	"SUCCESS":                    2,
	"FAILED_UNKNOWN":             3,
	"FAILED_NO_HTLC":             4,
	"FAILED_INVALID_HTLC_AMOUNT": 5,
	"FAILED_OFF_CHAIN_TIMEOUT":   6,
	"FAILED_TIMEOUT":             7,
	"FAILED_SWAP_DEADLINE":       8,
	"FAILED_HTLC_PUBLICATION":    9,
	"TIMEOUT_PUBLISHED":          10,
	"UNEXPECTED_FAILURE":         11,
	"HTLC_CONFIRMED":             12,
}

func (x ServerSwapState) String() string {
	return proto.EnumName(ServerSwapState_name, int32(x))
}

func (ServerSwapState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{1}
}

type ServerLoopOutRequest struct {
	ReceiverKey []byte `protobuf:"bytes,1,opt,name=receiver_key,json=receiverKey,proto3" json:"receiver_key,omitempty"`
	SwapHash    []byte `protobuf:"bytes,2,opt,name=swap_hash,json=swapHash,proto3" json:"swap_hash,omitempty"`
	Amt         uint64 `protobuf:"varint,3,opt,name=amt,proto3" json:"amt,omitempty"`
	/// The unix time in seconds we want the on-chain swap to be published by.
	SwapPublicationDeadline int64 `protobuf:"varint,4,opt,name=swap_publication_deadline,json=swapPublicationDeadline,proto3" json:"swap_publication_deadline,omitempty"`
	/// The protocol version that the client adheres to.
	ProtocolVersion      ProtocolVersion `protobuf:"varint,5,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ServerLoopOutRequest) Reset()         { *m = ServerLoopOutRequest{} }
func (m *ServerLoopOutRequest) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutRequest) ProtoMessage()    {}
func (*ServerLoopOutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{0}
}

func (m *ServerLoopOutRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutRequest.Unmarshal(m, b)
}
func (m *ServerLoopOutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutRequest.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutRequest.Merge(m, src)
}
func (m *ServerLoopOutRequest) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutRequest.Size(m)
}
func (m *ServerLoopOutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutRequest proto.InternalMessageInfo

func (m *ServerLoopOutRequest) GetReceiverKey() []byte {
	if m != nil {
		return m.ReceiverKey
	}
	return nil
}

func (m *ServerLoopOutRequest) GetSwapHash() []byte {
	if m != nil {
		return m.SwapHash
	}
	return nil
}

func (m *ServerLoopOutRequest) GetAmt() uint64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *ServerLoopOutRequest) GetSwapPublicationDeadline() int64 {
	if m != nil {
		return m.SwapPublicationDeadline
	}
	return 0
}

func (m *ServerLoopOutRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

type ServerLoopOutResponse struct {
	SwapInvoice   string `protobuf:"bytes,1,opt,name=swap_invoice,json=swapInvoice,proto3" json:"swap_invoice,omitempty"`
	PrepayInvoice string `protobuf:"bytes,2,opt,name=prepay_invoice,json=prepayInvoice,proto3" json:"prepay_invoice,omitempty"`
	SenderKey     []byte `protobuf:"bytes,3,opt,name=sender_key,json=senderKey,proto3" json:"sender_key,omitempty"`
	Expiry        int32  `protobuf:"varint,4,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// A human-readable message from the loop server.
	ServerMessage        string   `protobuf:"bytes,5,opt,name=server_message,json=serverMessage,proto3" json:"server_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopOutResponse) Reset()         { *m = ServerLoopOutResponse{} }
func (m *ServerLoopOutResponse) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutResponse) ProtoMessage()    {}
func (*ServerLoopOutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{1}
}

func (m *ServerLoopOutResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutResponse.Unmarshal(m, b)
}
func (m *ServerLoopOutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutResponse.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutResponse.Merge(m, src)
}
func (m *ServerLoopOutResponse) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutResponse.Size(m)
}
func (m *ServerLoopOutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutResponse proto.InternalMessageInfo

func (m *ServerLoopOutResponse) GetSwapInvoice() string {
	if m != nil {
		return m.SwapInvoice
	}
	return ""
}

func (m *ServerLoopOutResponse) GetPrepayInvoice() string {
	if m != nil {
		return m.PrepayInvoice
	}
	return ""
}

func (m *ServerLoopOutResponse) GetSenderKey() []byte {
	if m != nil {
		return m.SenderKey
	}
	return nil
}

func (m *ServerLoopOutResponse) GetExpiry() int32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *ServerLoopOutResponse) GetServerMessage() string {
	if m != nil {
		return m.ServerMessage
	}
	return ""
}

type ServerLoopOutQuoteRequest struct {
	/// The swap amount. If zero, a quote for a maximum amt swap will be given.
	Amt uint64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	/// The unix time in seconds we want the on-chain swap to be published by.
	SwapPublicationDeadline int64 `protobuf:"varint,2,opt,name=swap_publication_deadline,json=swapPublicationDeadline,proto3" json:"swap_publication_deadline,omitempty"`
	/// The protocol version that the client adheres to.
	ProtocolVersion      ProtocolVersion `protobuf:"varint,3,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ServerLoopOutQuoteRequest) Reset()         { *m = ServerLoopOutQuoteRequest{} }
func (m *ServerLoopOutQuoteRequest) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutQuoteRequest) ProtoMessage()    {}
func (*ServerLoopOutQuoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{2}
}

func (m *ServerLoopOutQuoteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutQuoteRequest.Unmarshal(m, b)
}
func (m *ServerLoopOutQuoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutQuoteRequest.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutQuoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutQuoteRequest.Merge(m, src)
}
func (m *ServerLoopOutQuoteRequest) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutQuoteRequest.Size(m)
}
func (m *ServerLoopOutQuoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutQuoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutQuoteRequest proto.InternalMessageInfo

func (m *ServerLoopOutQuoteRequest) GetAmt() uint64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *ServerLoopOutQuoteRequest) GetSwapPublicationDeadline() int64 {
	if m != nil {
		return m.SwapPublicationDeadline
	}
	return 0
}

func (m *ServerLoopOutQuoteRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

type ServerLoopOutQuote struct {
	SwapPaymentDest string `protobuf:"bytes,1,opt,name=swap_payment_dest,json=swapPaymentDest,proto3" json:"swap_payment_dest,omitempty"`
	/// The total estimated swap fee given the quote amt.
	SwapFee int64 `protobuf:"varint,2,opt,name=swap_fee,json=swapFee,proto3" json:"swap_fee,omitempty"`
	/// Deprecated, total swap fee given quote amt is calculated in swap_fee.
	SwapFeeRate          int64    `protobuf:"varint,3,opt,name=swap_fee_rate,json=swapFeeRate,proto3" json:"swap_fee_rate,omitempty"` // Deprecated: Do not use.
	PrepayAmt            uint64   `protobuf:"varint,4,opt,name=prepay_amt,json=prepayAmt,proto3" json:"prepay_amt,omitempty"`
	MinSwapAmount        uint64   `protobuf:"varint,5,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"` // Deprecated: Do not use.
	MaxSwapAmount        uint64   `protobuf:"varint,6,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"` // Deprecated: Do not use.
	CltvDelta            int32    `protobuf:"varint,7,opt,name=cltv_delta,json=cltvDelta,proto3" json:"cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopOutQuote) Reset()         { *m = ServerLoopOutQuote{} }
func (m *ServerLoopOutQuote) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutQuote) ProtoMessage()    {}
func (*ServerLoopOutQuote) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{3}
}

func (m *ServerLoopOutQuote) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutQuote.Unmarshal(m, b)
}
func (m *ServerLoopOutQuote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutQuote.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutQuote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutQuote.Merge(m, src)
}
func (m *ServerLoopOutQuote) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutQuote.Size(m)
}
func (m *ServerLoopOutQuote) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutQuote.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutQuote proto.InternalMessageInfo

func (m *ServerLoopOutQuote) GetSwapPaymentDest() string {
	if m != nil {
		return m.SwapPaymentDest
	}
	return ""
}

func (m *ServerLoopOutQuote) GetSwapFee() int64 {
	if m != nil {
		return m.SwapFee
	}
	return 0
}

// Deprecated: Do not use.
func (m *ServerLoopOutQuote) GetSwapFeeRate() int64 {
	if m != nil {
		return m.SwapFeeRate
	}
	return 0
}

func (m *ServerLoopOutQuote) GetPrepayAmt() uint64 {
	if m != nil {
		return m.PrepayAmt
	}
	return 0
}

// Deprecated: Do not use.
func (m *ServerLoopOutQuote) GetMinSwapAmount() uint64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *ServerLoopOutQuote) GetMaxSwapAmount() uint64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

func (m *ServerLoopOutQuote) GetCltvDelta() int32 {
	if m != nil {
		return m.CltvDelta
	}
	return 0
}

type ServerLoopOutTermsRequest struct {
	/// The protocol version that the client adheres to.
	ProtocolVersion      ProtocolVersion `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ServerLoopOutTermsRequest) Reset()         { *m = ServerLoopOutTermsRequest{} }
func (m *ServerLoopOutTermsRequest) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutTermsRequest) ProtoMessage()    {}
func (*ServerLoopOutTermsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{4}
}

func (m *ServerLoopOutTermsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutTermsRequest.Unmarshal(m, b)
}
func (m *ServerLoopOutTermsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutTermsRequest.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutTermsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutTermsRequest.Merge(m, src)
}
func (m *ServerLoopOutTermsRequest) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutTermsRequest.Size(m)
}
func (m *ServerLoopOutTermsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutTermsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutTermsRequest proto.InternalMessageInfo

func (m *ServerLoopOutTermsRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

type ServerLoopOutTerms struct {
	MinSwapAmount        uint64   `protobuf:"varint,1,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	MaxSwapAmount        uint64   `protobuf:"varint,2,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopOutTerms) Reset()         { *m = ServerLoopOutTerms{} }
func (m *ServerLoopOutTerms) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutTerms) ProtoMessage()    {}
func (*ServerLoopOutTerms) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{5}
}

func (m *ServerLoopOutTerms) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutTerms.Unmarshal(m, b)
}
func (m *ServerLoopOutTerms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutTerms.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutTerms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutTerms.Merge(m, src)
}
func (m *ServerLoopOutTerms) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutTerms.Size(m)
}
func (m *ServerLoopOutTerms) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutTerms.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutTerms proto.InternalMessageInfo

func (m *ServerLoopOutTerms) GetMinSwapAmount() uint64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *ServerLoopOutTerms) GetMaxSwapAmount() uint64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

type ServerLoopInRequest struct {
	SenderKey   []byte `protobuf:"bytes,1,opt,name=sender_key,json=senderKey,proto3" json:"sender_key,omitempty"`
	SwapHash    []byte `protobuf:"bytes,2,opt,name=swap_hash,json=swapHash,proto3" json:"swap_hash,omitempty"`
	Amt         uint64 `protobuf:"varint,3,opt,name=amt,proto3" json:"amt,omitempty"`
	SwapInvoice string `protobuf:"bytes,4,opt,name=swap_invoice,json=swapInvoice,proto3" json:"swap_invoice,omitempty"`
	LastHop     []byte `protobuf:"bytes,5,opt,name=last_hop,json=lastHop,proto3" json:"last_hop,omitempty"`
	/// The protocol version that the client adheres to.
	ProtocolVersion      ProtocolVersion `protobuf:"varint,6,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ServerLoopInRequest) Reset()         { *m = ServerLoopInRequest{} }
func (m *ServerLoopInRequest) String() string { return proto.CompactTextString(m) }
func (*ServerLoopInRequest) ProtoMessage()    {}
func (*ServerLoopInRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{6}
}

func (m *ServerLoopInRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopInRequest.Unmarshal(m, b)
}
func (m *ServerLoopInRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopInRequest.Marshal(b, m, deterministic)
}
func (m *ServerLoopInRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopInRequest.Merge(m, src)
}
func (m *ServerLoopInRequest) XXX_Size() int {
	return xxx_messageInfo_ServerLoopInRequest.Size(m)
}
func (m *ServerLoopInRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopInRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopInRequest proto.InternalMessageInfo

func (m *ServerLoopInRequest) GetSenderKey() []byte {
	if m != nil {
		return m.SenderKey
	}
	return nil
}

func (m *ServerLoopInRequest) GetSwapHash() []byte {
	if m != nil {
		return m.SwapHash
	}
	return nil
}

func (m *ServerLoopInRequest) GetAmt() uint64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *ServerLoopInRequest) GetSwapInvoice() string {
	if m != nil {
		return m.SwapInvoice
	}
	return ""
}

func (m *ServerLoopInRequest) GetLastHop() []byte {
	if m != nil {
		return m.LastHop
	}
	return nil
}

func (m *ServerLoopInRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

type ServerLoopInResponse struct {
	ReceiverKey []byte `protobuf:"bytes,1,opt,name=receiver_key,json=receiverKey,proto3" json:"receiver_key,omitempty"`
	Expiry      int32  `protobuf:"varint,2,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// A human-readable message from the loop server.
	ServerMessage        string   `protobuf:"bytes,3,opt,name=server_message,json=serverMessage,proto3" json:"server_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopInResponse) Reset()         { *m = ServerLoopInResponse{} }
func (m *ServerLoopInResponse) String() string { return proto.CompactTextString(m) }
func (*ServerLoopInResponse) ProtoMessage()    {}
func (*ServerLoopInResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{7}
}

func (m *ServerLoopInResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopInResponse.Unmarshal(m, b)
}
func (m *ServerLoopInResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopInResponse.Marshal(b, m, deterministic)
}
func (m *ServerLoopInResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopInResponse.Merge(m, src)
}
func (m *ServerLoopInResponse) XXX_Size() int {
	return xxx_messageInfo_ServerLoopInResponse.Size(m)
}
func (m *ServerLoopInResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopInResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopInResponse proto.InternalMessageInfo

func (m *ServerLoopInResponse) GetReceiverKey() []byte {
	if m != nil {
		return m.ReceiverKey
	}
	return nil
}

func (m *ServerLoopInResponse) GetExpiry() int32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *ServerLoopInResponse) GetServerMessage() string {
	if m != nil {
		return m.ServerMessage
	}
	return ""
}

type ServerLoopInQuoteRequest struct {
	/// The swap amount. If zero, a quote for a maximum amt swap will be given.
	Amt uint64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	/// The protocol version that the client adheres to.
	ProtocolVersion      ProtocolVersion `protobuf:"varint,2,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ServerLoopInQuoteRequest) Reset()         { *m = ServerLoopInQuoteRequest{} }
func (m *ServerLoopInQuoteRequest) String() string { return proto.CompactTextString(m) }
func (*ServerLoopInQuoteRequest) ProtoMessage()    {}
func (*ServerLoopInQuoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{8}
}

func (m *ServerLoopInQuoteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopInQuoteRequest.Unmarshal(m, b)
}
func (m *ServerLoopInQuoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopInQuoteRequest.Marshal(b, m, deterministic)
}
func (m *ServerLoopInQuoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopInQuoteRequest.Merge(m, src)
}
func (m *ServerLoopInQuoteRequest) XXX_Size() int {
	return xxx_messageInfo_ServerLoopInQuoteRequest.Size(m)
}
func (m *ServerLoopInQuoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopInQuoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopInQuoteRequest proto.InternalMessageInfo

func (m *ServerLoopInQuoteRequest) GetAmt() uint64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *ServerLoopInQuoteRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

type ServerLoopInQuoteResponse struct {
	SwapFee              int64    `protobuf:"varint,1,opt,name=swap_fee,json=swapFee,proto3" json:"swap_fee,omitempty"`
	SwapFeeRate          int64    `protobuf:"varint,2,opt,name=swap_fee_rate,json=swapFeeRate,proto3" json:"swap_fee_rate,omitempty"`       // Deprecated: Do not use.
	MinSwapAmount        uint64   `protobuf:"varint,4,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"` // Deprecated: Do not use.
	MaxSwapAmount        uint64   `protobuf:"varint,5,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"` // Deprecated: Do not use.
	CltvDelta            int32    `protobuf:"varint,6,opt,name=cltv_delta,json=cltvDelta,proto3" json:"cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopInQuoteResponse) Reset()         { *m = ServerLoopInQuoteResponse{} }
func (m *ServerLoopInQuoteResponse) String() string { return proto.CompactTextString(m) }
func (*ServerLoopInQuoteResponse) ProtoMessage()    {}
func (*ServerLoopInQuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{9}
}

func (m *ServerLoopInQuoteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopInQuoteResponse.Unmarshal(m, b)
}
func (m *ServerLoopInQuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopInQuoteResponse.Marshal(b, m, deterministic)
}
func (m *ServerLoopInQuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopInQuoteResponse.Merge(m, src)
}
func (m *ServerLoopInQuoteResponse) XXX_Size() int {
	return xxx_messageInfo_ServerLoopInQuoteResponse.Size(m)
}
func (m *ServerLoopInQuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopInQuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopInQuoteResponse proto.InternalMessageInfo

func (m *ServerLoopInQuoteResponse) GetSwapFee() int64 {
	if m != nil {
		return m.SwapFee
	}
	return 0
}

// Deprecated: Do not use.
func (m *ServerLoopInQuoteResponse) GetSwapFeeRate() int64 {
	if m != nil {
		return m.SwapFeeRate
	}
	return 0
}

// Deprecated: Do not use.
func (m *ServerLoopInQuoteResponse) GetMinSwapAmount() uint64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *ServerLoopInQuoteResponse) GetMaxSwapAmount() uint64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

func (m *ServerLoopInQuoteResponse) GetCltvDelta() int32 {
	if m != nil {
		return m.CltvDelta
	}
	return 0
}

type ServerLoopInTermsRequest struct {
	/// The protocol version that the client adheres to.
	ProtocolVersion      ProtocolVersion `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ServerLoopInTermsRequest) Reset()         { *m = ServerLoopInTermsRequest{} }
func (m *ServerLoopInTermsRequest) String() string { return proto.CompactTextString(m) }
func (*ServerLoopInTermsRequest) ProtoMessage()    {}
func (*ServerLoopInTermsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{10}
}

func (m *ServerLoopInTermsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopInTermsRequest.Unmarshal(m, b)
}
func (m *ServerLoopInTermsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopInTermsRequest.Marshal(b, m, deterministic)
}
func (m *ServerLoopInTermsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopInTermsRequest.Merge(m, src)
}
func (m *ServerLoopInTermsRequest) XXX_Size() int {
	return xxx_messageInfo_ServerLoopInTermsRequest.Size(m)
}
func (m *ServerLoopInTermsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopInTermsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopInTermsRequest proto.InternalMessageInfo

func (m *ServerLoopInTermsRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

type ServerLoopInTerms struct {
	MinSwapAmount        uint64   `protobuf:"varint,1,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	MaxSwapAmount        uint64   `protobuf:"varint,2,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopInTerms) Reset()         { *m = ServerLoopInTerms{} }
func (m *ServerLoopInTerms) String() string { return proto.CompactTextString(m) }
func (*ServerLoopInTerms) ProtoMessage()    {}
func (*ServerLoopInTerms) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{11}
}

func (m *ServerLoopInTerms) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopInTerms.Unmarshal(m, b)
}
func (m *ServerLoopInTerms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopInTerms.Marshal(b, m, deterministic)
}
func (m *ServerLoopInTerms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopInTerms.Merge(m, src)
}
func (m *ServerLoopInTerms) XXX_Size() int {
	return xxx_messageInfo_ServerLoopInTerms.Size(m)
}
func (m *ServerLoopInTerms) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopInTerms.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopInTerms proto.InternalMessageInfo

func (m *ServerLoopInTerms) GetMinSwapAmount() uint64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *ServerLoopInTerms) GetMaxSwapAmount() uint64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

// ServerLoopOutPushPreimageRequest pushes a preimage to the server. Note that
// this call returns with no error after the server acknowledges the preimage
// and does not block until the invoice is settled.
type ServerLoopOutPushPreimageRequest struct {
	// The protocol version that the client adheres to.
	ProtocolVersion ProtocolVersion `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	//
	//Preimage is the preimage of the loop out swap that we wish to push to the
	//server to speed up off-chain claim once the on-chain htlc has confirmed.
	Preimage             []byte   `protobuf:"bytes,2,opt,name=preimage,proto3" json:"preimage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopOutPushPreimageRequest) Reset()         { *m = ServerLoopOutPushPreimageRequest{} }
func (m *ServerLoopOutPushPreimageRequest) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutPushPreimageRequest) ProtoMessage()    {}
func (*ServerLoopOutPushPreimageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{12}
}

func (m *ServerLoopOutPushPreimageRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutPushPreimageRequest.Unmarshal(m, b)
}
func (m *ServerLoopOutPushPreimageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutPushPreimageRequest.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutPushPreimageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutPushPreimageRequest.Merge(m, src)
}
func (m *ServerLoopOutPushPreimageRequest) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutPushPreimageRequest.Size(m)
}
func (m *ServerLoopOutPushPreimageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutPushPreimageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutPushPreimageRequest proto.InternalMessageInfo

func (m *ServerLoopOutPushPreimageRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

func (m *ServerLoopOutPushPreimageRequest) GetPreimage() []byte {
	if m != nil {
		return m.Preimage
	}
	return nil
}

type ServerLoopOutPushPreimageResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerLoopOutPushPreimageResponse) Reset()         { *m = ServerLoopOutPushPreimageResponse{} }
func (m *ServerLoopOutPushPreimageResponse) String() string { return proto.CompactTextString(m) }
func (*ServerLoopOutPushPreimageResponse) ProtoMessage()    {}
func (*ServerLoopOutPushPreimageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{13}
}

func (m *ServerLoopOutPushPreimageResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerLoopOutPushPreimageResponse.Unmarshal(m, b)
}
func (m *ServerLoopOutPushPreimageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerLoopOutPushPreimageResponse.Marshal(b, m, deterministic)
}
func (m *ServerLoopOutPushPreimageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLoopOutPushPreimageResponse.Merge(m, src)
}
func (m *ServerLoopOutPushPreimageResponse) XXX_Size() int {
	return xxx_messageInfo_ServerLoopOutPushPreimageResponse.Size(m)
}
func (m *ServerLoopOutPushPreimageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLoopOutPushPreimageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLoopOutPushPreimageResponse proto.InternalMessageInfo

type SubscribeUpdatesRequest struct {
	// The protocol version that the client adheres to.
	ProtocolVersion ProtocolVersion `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3,enum=looprpc.ProtocolVersion" json:"protocol_version,omitempty"`
	// Swap hash is the hash of the swap to subscribe to updates for.
	SwapHash             []byte   `protobuf:"bytes,2,opt,name=swap_hash,json=swapHash,proto3" json:"swap_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeUpdatesRequest) Reset()         { *m = SubscribeUpdatesRequest{} }
func (m *SubscribeUpdatesRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeUpdatesRequest) ProtoMessage()    {}
func (*SubscribeUpdatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{14}
}

func (m *SubscribeUpdatesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeUpdatesRequest.Unmarshal(m, b)
}
func (m *SubscribeUpdatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeUpdatesRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeUpdatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeUpdatesRequest.Merge(m, src)
}
func (m *SubscribeUpdatesRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeUpdatesRequest.Size(m)
}
func (m *SubscribeUpdatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeUpdatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeUpdatesRequest proto.InternalMessageInfo

func (m *SubscribeUpdatesRequest) GetProtocolVersion() ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return ProtocolVersion_LEGACY
}

func (m *SubscribeUpdatesRequest) GetSwapHash() []byte {
	if m != nil {
		return m.SwapHash
	}
	return nil
}

type SubscribeLoopOutUpdatesResponse struct {
	// The unix timestamp in nanoseconds when the swap was updated.
	TimestampNs int64 `protobuf:"varint,1,opt,name=timestamp_ns,json=timestampNs,proto3" json:"timestamp_ns,omitempty"`
	// The swap's current state.
	State                ServerSwapState `protobuf:"varint,2,opt,name=state,proto3,enum=looprpc.ServerSwapState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SubscribeLoopOutUpdatesResponse) Reset()         { *m = SubscribeLoopOutUpdatesResponse{} }
func (m *SubscribeLoopOutUpdatesResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeLoopOutUpdatesResponse) ProtoMessage()    {}
func (*SubscribeLoopOutUpdatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{15}
}

func (m *SubscribeLoopOutUpdatesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeLoopOutUpdatesResponse.Unmarshal(m, b)
}
func (m *SubscribeLoopOutUpdatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeLoopOutUpdatesResponse.Marshal(b, m, deterministic)
}
func (m *SubscribeLoopOutUpdatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeLoopOutUpdatesResponse.Merge(m, src)
}
func (m *SubscribeLoopOutUpdatesResponse) XXX_Size() int {
	return xxx_messageInfo_SubscribeLoopOutUpdatesResponse.Size(m)
}
func (m *SubscribeLoopOutUpdatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeLoopOutUpdatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeLoopOutUpdatesResponse proto.InternalMessageInfo

func (m *SubscribeLoopOutUpdatesResponse) GetTimestampNs() int64 {
	if m != nil {
		return m.TimestampNs
	}
	return 0
}

func (m *SubscribeLoopOutUpdatesResponse) GetState() ServerSwapState {
	if m != nil {
		return m.State
	}
	return ServerSwapState_INITIATED
}

type SubscribeLoopInUpdatesResponse struct {
	// The unix timestamp in nanoseconds when the swap was updated.
	TimestampNs int64 `protobuf:"varint,1,opt,name=timestamp_ns,json=timestampNs,proto3" json:"timestamp_ns,omitempty"`
	// The swap's current state.
	State                ServerSwapState `protobuf:"varint,2,opt,name=state,proto3,enum=looprpc.ServerSwapState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SubscribeLoopInUpdatesResponse) Reset()         { *m = SubscribeLoopInUpdatesResponse{} }
func (m *SubscribeLoopInUpdatesResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeLoopInUpdatesResponse) ProtoMessage()    {}
func (*SubscribeLoopInUpdatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{16}
}

func (m *SubscribeLoopInUpdatesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeLoopInUpdatesResponse.Unmarshal(m, b)
}
func (m *SubscribeLoopInUpdatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeLoopInUpdatesResponse.Marshal(b, m, deterministic)
}
func (m *SubscribeLoopInUpdatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeLoopInUpdatesResponse.Merge(m, src)
}
func (m *SubscribeLoopInUpdatesResponse) XXX_Size() int {
	return xxx_messageInfo_SubscribeLoopInUpdatesResponse.Size(m)
}
func (m *SubscribeLoopInUpdatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeLoopInUpdatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeLoopInUpdatesResponse proto.InternalMessageInfo

func (m *SubscribeLoopInUpdatesResponse) GetTimestampNs() int64 {
	if m != nil {
		return m.TimestampNs
	}
	return 0
}

func (m *SubscribeLoopInUpdatesResponse) GetState() ServerSwapState {
	if m != nil {
		return m.State
	}
	return ServerSwapState_INITIATED
}

func init() {
	proto.RegisterEnum("looprpc.ProtocolVersion", ProtocolVersion_name, ProtocolVersion_value)
	proto.RegisterEnum("looprpc.ServerSwapState", ServerSwapState_name, ServerSwapState_value)
	proto.RegisterType((*ServerLoopOutRequest)(nil), "looprpc.ServerLoopOutRequest")
	proto.RegisterType((*ServerLoopOutResponse)(nil), "looprpc.ServerLoopOutResponse")
	proto.RegisterType((*ServerLoopOutQuoteRequest)(nil), "looprpc.ServerLoopOutQuoteRequest")
	proto.RegisterType((*ServerLoopOutQuote)(nil), "looprpc.ServerLoopOutQuote")
	proto.RegisterType((*ServerLoopOutTermsRequest)(nil), "looprpc.ServerLoopOutTermsRequest")
	proto.RegisterType((*ServerLoopOutTerms)(nil), "looprpc.ServerLoopOutTerms")
	proto.RegisterType((*ServerLoopInRequest)(nil), "looprpc.ServerLoopInRequest")
	proto.RegisterType((*ServerLoopInResponse)(nil), "looprpc.ServerLoopInResponse")
	proto.RegisterType((*ServerLoopInQuoteRequest)(nil), "looprpc.ServerLoopInQuoteRequest")
	proto.RegisterType((*ServerLoopInQuoteResponse)(nil), "looprpc.ServerLoopInQuoteResponse")
	proto.RegisterType((*ServerLoopInTermsRequest)(nil), "looprpc.ServerLoopInTermsRequest")
	proto.RegisterType((*ServerLoopInTerms)(nil), "looprpc.ServerLoopInTerms")
	proto.RegisterType((*ServerLoopOutPushPreimageRequest)(nil), "looprpc.ServerLoopOutPushPreimageRequest")
	proto.RegisterType((*ServerLoopOutPushPreimageResponse)(nil), "looprpc.ServerLoopOutPushPreimageResponse")
	proto.RegisterType((*SubscribeUpdatesRequest)(nil), "looprpc.SubscribeUpdatesRequest")
	proto.RegisterType((*SubscribeLoopOutUpdatesResponse)(nil), "looprpc.SubscribeLoopOutUpdatesResponse")
	proto.RegisterType((*SubscribeLoopInUpdatesResponse)(nil), "looprpc.SubscribeLoopInUpdatesResponse")
}

func init() { proto.RegisterFile("server.proto", fileDescriptor_ad098daeda4239f7) }

var fileDescriptor_ad098daeda4239f7 = []byte{
	// 1203 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x72, 0xe2, 0x46,
	0x10, 0x8e, 0x04, 0x06, 0xd3, 0x80, 0xad, 0x9d, 0xdd, 0xf5, 0x62, 0x76, 0xed, 0x60, 0x52, 0x71,
	0x1c, 0x1f, 0xbc, 0x5b, 0x9b, 0x5b, 0x6e, 0x5a, 0x10, 0x46, 0xb5, 0x20, 0x11, 0x21, 0xec, 0xe4,
	0x34, 0x91, 0x61, 0x62, 0x54, 0x01, 0x49, 0x2b, 0x09, 0xff, 0x54, 0x8e, 0x79, 0x8a, 0xbc, 0x44,
	0x72, 0xca, 0x39, 0x4f, 0x91, 0x57, 0x48, 0x55, 0xde, 0x22, 0xa5, 0xd1, 0x08, 0x24, 0x90, 0x7f,
	0xa8, 0x72, 0x6e, 0x56, 0xf7, 0x37, 0xd3, 0xfd, 0x7d, 0x3d, 0x5f, 0x63, 0x28, 0x79, 0xc4, 0xbd,
	0x22, 0xee, 0x89, 0xe3, 0xda, 0xbe, 0x8d, 0xf2, 0x13, 0xdb, 0x76, 0x5c, 0x67, 0x58, 0x7d, 0x73,
	0x69, 0xdb, 0x97, 0x13, 0xf2, 0xd6, 0x70, 0xcc, 0xb7, 0x86, 0x65, 0xd9, 0xbe, 0xe1, 0x9b, 0xb6,
	0xe5, 0x85, 0xb0, 0xfa, 0xbf, 0x1c, 0xbc, 0xe8, 0xd3, 0x73, 0x1d, 0xdb, 0x76, 0xd4, 0x99, 0xaf,
	0x91, 0x4f, 0x33, 0xe2, 0xf9, 0xe8, 0x00, 0x4a, 0x2e, 0x19, 0x12, 0xf3, 0x8a, 0xb8, 0xf8, 0x67,
	0x72, 0x5b, 0xe1, 0x6a, 0xdc, 0x51, 0x49, 0x2b, 0x46, 0xb1, 0x8f, 0xe4, 0x16, 0xbd, 0x86, 0x82,
	0x77, 0x6d, 0x38, 0x78, 0x6c, 0x78, 0xe3, 0x0a, 0x4f, 0xf3, 0x9b, 0x41, 0xa0, 0x6d, 0x78, 0x63,
	0x24, 0x40, 0xc6, 0x98, 0xfa, 0x95, 0x4c, 0x8d, 0x3b, 0xca, 0x6a, 0xc1, 0x9f, 0xe8, 0x5b, 0xd8,
	0xa5, 0x70, 0x67, 0x76, 0x31, 0x31, 0x87, 0xb4, 0x0b, 0x3c, 0x22, 0xc6, 0x68, 0x62, 0x5a, 0xa4,
	0x92, 0xad, 0x71, 0x47, 0x19, 0xed, 0x55, 0x00, 0xe8, 0x2d, 0xf2, 0x4d, 0x96, 0x46, 0x0d, 0x10,
	0x68, 0xbf, 0x43, 0x7b, 0x82, 0xaf, 0x88, 0xeb, 0x99, 0xb6, 0x55, 0xd9, 0xa8, 0x71, 0x47, 0x5b,
	0xef, 0x2b, 0x27, 0x8c, 0xe8, 0x49, 0x8f, 0x01, 0xce, 0xc2, 0xbc, 0xb6, 0xed, 0x24, 0x03, 0xf5,
	0xbf, 0x38, 0x78, 0xb9, 0xc4, 0xd5, 0x73, 0x6c, 0xcb, 0x23, 0x01, 0x59, 0xda, 0x9a, 0x69, 0x5d,
	0xd9, 0xe6, 0x90, 0x50, 0xb2, 0x05, 0xad, 0x18, 0xc4, 0xe4, 0x30, 0x84, 0xbe, 0x84, 0x2d, 0xc7,
	0x25, 0x8e, 0x71, 0x3b, 0x07, 0xf1, 0x14, 0x54, 0x0e, 0xa3, 0x11, 0x6c, 0x0f, 0xc0, 0x23, 0xd6,
	0x88, 0x89, 0x96, 0xa1, 0xa2, 0x14, 0xc2, 0x48, 0x20, 0xd9, 0x0e, 0xe4, 0xc8, 0x8d, 0x63, 0xba,
	0xb7, 0x94, 0xf0, 0x86, 0xc6, 0xbe, 0x82, 0xdb, 0xc3, 0xe9, 0xe1, 0x29, 0xf1, 0x3c, 0xe3, 0x92,
	0x50, 0x76, 0x05, 0xad, 0x1c, 0x46, 0xbb, 0x61, 0xb0, 0xfe, 0x3b, 0x07, 0xbb, 0x09, 0x06, 0xdf,
	0xcd, 0x6c, 0x9f, 0x44, 0x23, 0x63, 0x92, 0x73, 0x8f, 0x94, 0x9c, 0x5f, 0x5f, 0xf2, 0xcc, 0xba,
	0x92, 0xff, 0xc6, 0x03, 0x5a, 0x6d, 0x18, 0x1d, 0xc3, 0xb3, 0xb0, 0x2f, 0xe3, 0x76, 0x4a, 0x2c,
	0x1f, 0x8f, 0x88, 0xe7, 0x33, 0xd1, 0xb7, 0x69, 0x3f, 0x61, 0xbc, 0x19, 0xb0, 0xda, 0x05, 0xfa,
	0xa8, 0xf0, 0x4f, 0x24, 0x6a, 0x39, 0x1f, 0x7c, 0xb7, 0x08, 0x41, 0x87, 0x50, 0x8e, 0x52, 0xd8,
	0x35, 0x7c, 0x42, 0xfb, 0xcb, 0x7c, 0xe0, 0x2b, 0x5c, 0x38, 0xbb, 0x16, 0x21, 0x9a, 0xe1, 0xd3,
	0xa1, 0xb0, 0xd9, 0x05, 0xfa, 0x64, 0xa9, 0x3e, 0x85, 0x30, 0x22, 0x4e, 0x7d, 0x74, 0x0c, 0xdb,
	0x53, 0xd3, 0xc2, 0xf4, 0x2a, 0x63, 0x6a, 0xcf, 0x2c, 0x9f, 0xaa, 0x9f, 0xa5, 0x17, 0x95, 0xa7,
	0xa6, 0xd5, 0xbf, 0x36, 0x1c, 0x91, 0x26, 0x28, 0xd6, 0xb8, 0x49, 0x60, 0x73, 0x31, 0xac, 0x71,
	0x13, 0xc3, 0xee, 0x01, 0x0c, 0x27, 0xfe, 0x15, 0x1e, 0x91, 0x89, 0x6f, 0x54, 0xf2, 0x74, 0xe0,
	0x85, 0x20, 0xd2, 0x0c, 0x02, 0xf5, 0x1f, 0x97, 0x66, 0xa9, 0x13, 0x77, 0xea, 0x45, 0xb3, 0x4c,
	0x53, 0x9f, 0x5b, 0x57, 0xfd, 0xd1, 0x92, 0xf8, 0xb4, 0x02, 0x3a, 0x5c, 0xa5, 0x1b, 0x3e, 0x99,
	0x25, 0xaa, 0x87, 0xab, 0x54, 0x79, 0x86, 0x8b, 0xd3, 0xac, 0xff, 0xc3, 0xc1, 0xf3, 0x45, 0x19,
	0xd9, 0x8a, 0x28, 0x24, 0xad, 0xc0, 0x2d, 0x5b, 0x61, 0xcd, 0xed, 0xb1, 0x6c, 0xd1, 0xec, 0xaa,
	0x45, 0x77, 0x61, 0x73, 0x62, 0x78, 0x3e, 0x1e, 0xdb, 0x0e, 0x1d, 0x60, 0x49, 0xcb, 0x07, 0xdf,
	0x6d, 0xdb, 0x49, 0x95, 0x33, 0xb7, 0xae, 0x9c, 0x37, 0xf1, 0x55, 0x19, 0xf0, 0x5c, 0x6c, 0x8f,
	0x87, 0x56, 0xe5, 0xc2, 0xf7, 0xfc, 0x03, 0xbe, 0xcf, 0xa4, 0xf9, 0xfe, 0x13, 0x54, 0xe2, 0x95,
	0x1f, 0x70, 0x7d, 0x1a, 0x59, 0x7e, 0x5d, 0xb2, 0x7f, 0x27, 0x56, 0xcd, 0xbc, 0x26, 0xa3, 0x1c,
	0x37, 0x25, 0xf7, 0x80, 0x29, 0xf9, 0x74, 0x53, 0xa6, 0xb8, 0x2e, 0xbb, 0x86, 0xeb, 0x36, 0x1e,
	0xe7, 0xba, 0xdc, 0xb2, 0xeb, 0x70, 0x52, 0xca, 0xa7, 0x37, 0xdd, 0x10, 0x9e, 0xad, 0x14, 0x78,
	0x72, 0xcf, 0xfd, 0xca, 0x41, 0x2d, 0x61, 0xed, 0xde, 0xcc, 0x1b, 0xf7, 0x5c, 0x62, 0x4e, 0x8d,
	0x4b, 0xf2, 0x94, 0x74, 0x50, 0x15, 0x36, 0x1d, 0x76, 0x6f, 0xe4, 0xd2, 0xe8, 0xbb, 0xfe, 0x05,
	0x1c, 0xdc, 0xd3, 0x44, 0xf8, 0x54, 0xea, 0xbf, 0xc0, 0xab, 0xfe, 0xec, 0xc2, 0x1b, 0xba, 0xe6,
	0x05, 0x19, 0x38, 0x23, 0xc3, 0x27, 0x4f, 0xaa, 0xf7, 0xbd, 0x7b, 0xa4, 0xee, 0xc3, 0xe7, 0xf3,
	0xe2, 0xac, 0xc9, 0x79, 0x0f, 0x0b, 0xf7, 0xfa, 0xe6, 0x94, 0x78, 0xbe, 0x31, 0x75, 0xb0, 0xe5,
	0xb1, 0xe7, 0x5c, 0x9c, 0xc7, 0x14, 0x0f, 0x9d, 0xc0, 0x86, 0xe7, 0x47, 0x4f, 0x39, 0xde, 0x5c,
	0xc8, 0x3e, 0x98, 0x4b, 0x3f, 0xc8, 0x6b, 0x21, 0xac, 0xee, 0xc1, 0x7e, 0xa2, 0xaa, 0x6c, 0xfd,
	0xff, 0x45, 0x8f, 0xc7, 0xb0, 0xbd, 0xa4, 0x15, 0x02, 0xc8, 0x75, 0xa4, 0x53, 0xb1, 0xf1, 0x83,
	0xf0, 0x19, 0x42, 0xb0, 0xd5, 0x1d, 0x74, 0x74, 0x19, 0x77, 0x54, 0xb5, 0x87, 0xd5, 0x81, 0x2e,
	0x70, 0x68, 0x17, 0x5e, 0x2a, 0xa2, 0x2e, 0x9f, 0x49, 0xb8, 0x2f, 0x9d, 0x9e, 0xcb, 0x7a, 0x98,
	0x93, 0x15, 0x81, 0x47, 0x55, 0xd8, 0xe9, 0x69, 0x92, 0xdc, 0x15, 0x4f, 0x25, 0xdc, 0x1b, 0xf4,
	0xdb, 0x8b, 0x63, 0x99, 0xe3, 0x3f, 0x79, 0xd8, 0x5e, 0x6a, 0x02, 0x95, 0xa1, 0x20, 0x2b, 0xb2,
	0x2e, 0x8b, 0xba, 0xd4, 0x0c, 0xab, 0xb5, 0xf5, 0x4e, 0x03, 0xf7, 0x06, 0x1f, 0x3a, 0x72, 0xbf,
	0x2d, 0x35, 0x05, 0x0e, 0x15, 0x21, 0xdf, 0x1f, 0x34, 0x1a, 0x52, 0xbf, 0x2f, 0xf0, 0x01, 0xa0,
	0x25, 0xca, 0x1d, 0xa9, 0x89, 0x07, 0xca, 0x47, 0x45, 0x3d, 0x57, 0x84, 0x4c, 0x2c, 0xa6, 0xa8,
	0x38, 0x38, 0x2e, 0x64, 0xd1, 0x3e, 0x54, 0x59, 0x4c, 0x56, 0xce, 0xc4, 0x8e, 0xdc, 0xa4, 0x09,
	0x2c, 0x76, 0xd5, 0x81, 0xa2, 0x0b, 0x1b, 0xe8, 0x0d, 0x54, 0x58, 0x5e, 0x6d, 0xb5, 0x70, 0xa3,
	0x2d, 0xca, 0x0a, 0xd6, 0xe5, 0xae, 0x14, 0x74, 0x9a, 0x8b, 0xdd, 0x18, 0xc5, 0xf2, 0xa8, 0x02,
	0x2f, 0x58, 0xac, 0x7f, 0x2e, 0xf6, 0x70, 0x53, 0x12, 0x9b, 0x1d, 0x59, 0x91, 0x84, 0x4d, 0xf4,
	0x1a, 0x5e, 0xb1, 0xcc, 0xa2, 0xf7, 0x86, 0xa8, 0xcb, 0xaa, 0x22, 0x14, 0xd0, 0x4b, 0x78, 0xc6,
	0xee, 0x88, 0x91, 0x02, 0xb4, 0x03, 0x68, 0xa0, 0x48, 0xdf, 0xf7, 0xa4, 0x86, 0x2e, 0x35, 0x71,
	0x70, 0x7c, 0xa0, 0x49, 0x42, 0x71, 0x2e, 0x40, 0x43, 0x55, 0x5a, 0xb2, 0xd6, 0x95, 0x9a, 0x42,
	0xe9, 0xfd, 0x1f, 0x39, 0x00, 0xaa, 0x18, 0xd5, 0x0e, 0xa9, 0x50, 0x4a, 0xfc, 0x2e, 0xd7, 0x97,
	0x26, 0x9c, 0xf2, 0x6f, 0x41, 0xf5, 0xf5, 0x3d, 0x18, 0xa4, 0xc2, 0x96, 0x42, 0xae, 0x59, 0x28,
	0x28, 0x84, 0xf6, 0xd2, 0xe1, 0xd1, 0x6d, 0xfb, 0x77, 0xa5, 0xd9, 0x2b, 0x9d, 0xc0, 0xf3, 0x14,
	0x67, 0xa3, 0xaf, 0xd3, 0x8f, 0xa5, 0xac, 0xa0, 0xea, 0xf1, 0x63, 0xa0, 0xac, 0xda, 0x42, 0x8f,
	0xf0, 0x9f, 0xc4, 0x3b, 0xf4, 0x88, 0xff, 0xf8, 0xdd, 0xa5, 0x47, 0x78, 0x41, 0x07, 0x8a, 0xf1,
	0x1d, 0x7c, 0x90, 0x82, 0x4d, 0xfe, 0x00, 0x54, 0xab, 0x77, 0x43, 0x50, 0x07, 0xca, 0x4c, 0x5d,
	0x99, 0x6e, 0x6c, 0xf4, 0x26, 0x15, 0x1c, 0x5d, 0xb5, 0x77, 0x47, 0x96, 0x91, 0xd5, 0xa3, 0xde,
	0xc2, 0x56, 0xd3, 0x7b, 0x4b, 0x50, 0xad, 0xdf, 0x07, 0x61, 0xb7, 0x5e, 0xc6, 0x76, 0x6d, 0x72,
	0xdd, 0xa1, 0xda, 0xe2, 0x78, 0xfa, 0x36, 0xae, 0x1e, 0xad, 0x22, 0xd2, 0x57, 0xe6, 0x3b, 0x0e,
	0x11, 0xd8, 0x49, 0xdf, 0x70, 0x8f, 0xa8, 0xf3, 0x55, 0x7a, 0x9d, 0x95, 0x25, 0xf9, 0x8e, 0xbb,
	0xc8, 0xd1, 0x65, 0xff, 0xcd, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x2c, 0xcd, 0x43, 0xb7, 0xdb,
	0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SwapServerClient is the client API for SwapServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SwapServerClient interface {
	LoopOutTerms(ctx context.Context, in *ServerLoopOutTermsRequest, opts ...grpc.CallOption) (*ServerLoopOutTerms, error)
	NewLoopOutSwap(ctx context.Context, in *ServerLoopOutRequest, opts ...grpc.CallOption) (*ServerLoopOutResponse, error)
	LoopOutPushPreimage(ctx context.Context, in *ServerLoopOutPushPreimageRequest, opts ...grpc.CallOption) (*ServerLoopOutPushPreimageResponse, error)
	LoopOutQuote(ctx context.Context, in *ServerLoopOutQuoteRequest, opts ...grpc.CallOption) (*ServerLoopOutQuote, error)
	LoopInTerms(ctx context.Context, in *ServerLoopInTermsRequest, opts ...grpc.CallOption) (*ServerLoopInTerms, error)
	NewLoopInSwap(ctx context.Context, in *ServerLoopInRequest, opts ...grpc.CallOption) (*ServerLoopInResponse, error)
	LoopInQuote(ctx context.Context, in *ServerLoopInQuoteRequest, opts ...grpc.CallOption) (*ServerLoopInQuoteResponse, error)
	SubscribeLoopOutUpdates(ctx context.Context, in *SubscribeUpdatesRequest, opts ...grpc.CallOption) (SwapServer_SubscribeLoopOutUpdatesClient, error)
	SubscribeLoopInUpdates(ctx context.Context, in *SubscribeUpdatesRequest, opts ...grpc.CallOption) (SwapServer_SubscribeLoopInUpdatesClient, error)
}

type swapServerClient struct {
	cc *grpc.ClientConn
}

func NewSwapServerClient(cc *grpc.ClientConn) SwapServerClient {
	return &swapServerClient{cc}
}

func (c *swapServerClient) LoopOutTerms(ctx context.Context, in *ServerLoopOutTermsRequest, opts ...grpc.CallOption) (*ServerLoopOutTerms, error) {
	out := new(ServerLoopOutTerms)
	err := c.cc.Invoke(ctx, "/looprpc.SwapServer/LoopOutTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapServerClient) NewLoopOutSwap(ctx context.Context, in *ServerLoopOutRequest, opts ...grpc.CallOption) (*ServerLoopOutResponse, error) {
	out := new(ServerLoopOutResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapServer/NewLoopOutSwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapServerClient) LoopOutPushPreimage(ctx context.Context, in *ServerLoopOutPushPreimageRequest, opts ...grpc.CallOption) (*ServerLoopOutPushPreimageResponse, error) {
	out := new(ServerLoopOutPushPreimageResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapServer/LoopOutPushPreimage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapServerClient) LoopOutQuote(ctx context.Context, in *ServerLoopOutQuoteRequest, opts ...grpc.CallOption) (*ServerLoopOutQuote, error) {
	out := new(ServerLoopOutQuote)
	err := c.cc.Invoke(ctx, "/looprpc.SwapServer/LoopOutQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapServerClient) LoopInTerms(ctx context.Context, in *ServerLoopInTermsRequest, opts ...grpc.CallOption) (*ServerLoopInTerms, error) {
	out := new(ServerLoopInTerms)
	err := c.cc.Invoke(ctx, "/looprpc.SwapServer/LoopInTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapServerClient) NewLoopInSwap(ctx context.Context, in *ServerLoopInRequest, opts ...grpc.CallOption) (*ServerLoopInResponse, error) {
	out := new(ServerLoopInResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapServer/NewLoopInSwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapServerClient) LoopInQuote(ctx context.Context, in *ServerLoopInQuoteRequest, opts ...grpc.CallOption) (*ServerLoopInQuoteResponse, error) {
	out := new(ServerLoopInQuoteResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapServer/LoopInQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapServerClient) SubscribeLoopOutUpdates(ctx context.Context, in *SubscribeUpdatesRequest, opts ...grpc.CallOption) (SwapServer_SubscribeLoopOutUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SwapServer_serviceDesc.Streams[0], "/looprpc.SwapServer/SubscribeLoopOutUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &swapServerSubscribeLoopOutUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SwapServer_SubscribeLoopOutUpdatesClient interface {
	Recv() (*SubscribeLoopOutUpdatesResponse, error)
	grpc.ClientStream
}

type swapServerSubscribeLoopOutUpdatesClient struct {
	grpc.ClientStream
}

func (x *swapServerSubscribeLoopOutUpdatesClient) Recv() (*SubscribeLoopOutUpdatesResponse, error) {
	m := new(SubscribeLoopOutUpdatesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *swapServerClient) SubscribeLoopInUpdates(ctx context.Context, in *SubscribeUpdatesRequest, opts ...grpc.CallOption) (SwapServer_SubscribeLoopInUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SwapServer_serviceDesc.Streams[1], "/looprpc.SwapServer/SubscribeLoopInUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &swapServerSubscribeLoopInUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SwapServer_SubscribeLoopInUpdatesClient interface {
	Recv() (*SubscribeLoopInUpdatesResponse, error)
	grpc.ClientStream
}

type swapServerSubscribeLoopInUpdatesClient struct {
	grpc.ClientStream
}

func (x *swapServerSubscribeLoopInUpdatesClient) Recv() (*SubscribeLoopInUpdatesResponse, error) {
	m := new(SubscribeLoopInUpdatesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SwapServerServer is the server API for SwapServer service.
type SwapServerServer interface {
	LoopOutTerms(context.Context, *ServerLoopOutTermsRequest) (*ServerLoopOutTerms, error)
	NewLoopOutSwap(context.Context, *ServerLoopOutRequest) (*ServerLoopOutResponse, error)
	LoopOutPushPreimage(context.Context, *ServerLoopOutPushPreimageRequest) (*ServerLoopOutPushPreimageResponse, error)
	LoopOutQuote(context.Context, *ServerLoopOutQuoteRequest) (*ServerLoopOutQuote, error)
	LoopInTerms(context.Context, *ServerLoopInTermsRequest) (*ServerLoopInTerms, error)
	NewLoopInSwap(context.Context, *ServerLoopInRequest) (*ServerLoopInResponse, error)
	LoopInQuote(context.Context, *ServerLoopInQuoteRequest) (*ServerLoopInQuoteResponse, error)
	SubscribeLoopOutUpdates(*SubscribeUpdatesRequest, SwapServer_SubscribeLoopOutUpdatesServer) error
	SubscribeLoopInUpdates(*SubscribeUpdatesRequest, SwapServer_SubscribeLoopInUpdatesServer) error
}

// UnimplementedSwapServerServer can be embedded to have forward compatible implementations.
type UnimplementedSwapServerServer struct {
}

func (*UnimplementedSwapServerServer) LoopOutTerms(ctx context.Context, req *ServerLoopOutTermsRequest) (*ServerLoopOutTerms, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOutTerms not implemented")
}
func (*UnimplementedSwapServerServer) NewLoopOutSwap(ctx context.Context, req *ServerLoopOutRequest) (*ServerLoopOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewLoopOutSwap not implemented")
}
func (*UnimplementedSwapServerServer) LoopOutPushPreimage(ctx context.Context, req *ServerLoopOutPushPreimageRequest) (*ServerLoopOutPushPreimageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOutPushPreimage not implemented")
}
func (*UnimplementedSwapServerServer) LoopOutQuote(ctx context.Context, req *ServerLoopOutQuoteRequest) (*ServerLoopOutQuote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOutQuote not implemented")
}
func (*UnimplementedSwapServerServer) LoopInTerms(ctx context.Context, req *ServerLoopInTermsRequest) (*ServerLoopInTerms, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopInTerms not implemented")
}
func (*UnimplementedSwapServerServer) NewLoopInSwap(ctx context.Context, req *ServerLoopInRequest) (*ServerLoopInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewLoopInSwap not implemented")
}
func (*UnimplementedSwapServerServer) LoopInQuote(ctx context.Context, req *ServerLoopInQuoteRequest) (*ServerLoopInQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopInQuote not implemented")
}
func (*UnimplementedSwapServerServer) SubscribeLoopOutUpdates(req *SubscribeUpdatesRequest, srv SwapServer_SubscribeLoopOutUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeLoopOutUpdates not implemented")
}
func (*UnimplementedSwapServerServer) SubscribeLoopInUpdates(req *SubscribeUpdatesRequest, srv SwapServer_SubscribeLoopInUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeLoopInUpdates not implemented")
}

func RegisterSwapServerServer(s *grpc.Server, srv SwapServerServer) {
	s.RegisterService(&_SwapServer_serviceDesc, srv)
}

func _SwapServer_LoopOutTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerLoopOutTermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapServerServer).LoopOutTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapServer/LoopOutTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapServerServer).LoopOutTerms(ctx, req.(*ServerLoopOutTermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapServer_NewLoopOutSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerLoopOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapServerServer).NewLoopOutSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapServer/NewLoopOutSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapServerServer).NewLoopOutSwap(ctx, req.(*ServerLoopOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapServer_LoopOutPushPreimage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerLoopOutPushPreimageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapServerServer).LoopOutPushPreimage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapServer/LoopOutPushPreimage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapServerServer).LoopOutPushPreimage(ctx, req.(*ServerLoopOutPushPreimageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapServer_LoopOutQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerLoopOutQuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapServerServer).LoopOutQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapServer/LoopOutQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapServerServer).LoopOutQuote(ctx, req.(*ServerLoopOutQuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapServer_LoopInTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerLoopInTermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapServerServer).LoopInTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapServer/LoopInTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapServerServer).LoopInTerms(ctx, req.(*ServerLoopInTermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapServer_NewLoopInSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerLoopInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapServerServer).NewLoopInSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapServer/NewLoopInSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapServerServer).NewLoopInSwap(ctx, req.(*ServerLoopInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapServer_LoopInQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerLoopInQuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapServerServer).LoopInQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapServer/LoopInQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapServerServer).LoopInQuote(ctx, req.(*ServerLoopInQuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapServer_SubscribeLoopOutUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeUpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapServerServer).SubscribeLoopOutUpdates(m, &swapServerSubscribeLoopOutUpdatesServer{stream})
}

type SwapServer_SubscribeLoopOutUpdatesServer interface {
	Send(*SubscribeLoopOutUpdatesResponse) error
	grpc.ServerStream
}

type swapServerSubscribeLoopOutUpdatesServer struct {
	grpc.ServerStream
}

func (x *swapServerSubscribeLoopOutUpdatesServer) Send(m *SubscribeLoopOutUpdatesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SwapServer_SubscribeLoopInUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeUpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapServerServer).SubscribeLoopInUpdates(m, &swapServerSubscribeLoopInUpdatesServer{stream})
}

type SwapServer_SubscribeLoopInUpdatesServer interface {
	Send(*SubscribeLoopInUpdatesResponse) error
	grpc.ServerStream
}

type swapServerSubscribeLoopInUpdatesServer struct {
	grpc.ServerStream
}

func (x *swapServerSubscribeLoopInUpdatesServer) Send(m *SubscribeLoopInUpdatesResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SwapServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "looprpc.SwapServer",
	HandlerType: (*SwapServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoopOutTerms",
			Handler:    _SwapServer_LoopOutTerms_Handler,
		},
		{
			MethodName: "NewLoopOutSwap",
			Handler:    _SwapServer_NewLoopOutSwap_Handler,
		},
		{
			MethodName: "LoopOutPushPreimage",
			Handler:    _SwapServer_LoopOutPushPreimage_Handler,
		},
		{
			MethodName: "LoopOutQuote",
			Handler:    _SwapServer_LoopOutQuote_Handler,
		},
		{
			MethodName: "LoopInTerms",
			Handler:    _SwapServer_LoopInTerms_Handler,
		},
		{
			MethodName: "NewLoopInSwap",
			Handler:    _SwapServer_NewLoopInSwap_Handler,
		},
		{
			MethodName: "LoopInQuote",
			Handler:    _SwapServer_LoopInQuote_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeLoopOutUpdates",
			Handler:       _SwapServer_SubscribeLoopOutUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeLoopInUpdates",
			Handler:       _SwapServer_SubscribeLoopInUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "server.proto",
}

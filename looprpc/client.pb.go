// Code generated by protoc-gen-go. DO NOT EDIT.
// source: client.proto

package looprpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SwapType int32

const (
	// LOOP_OUT indicates an loop out swap (off-chain to on-chain)
	SwapType_LOOP_OUT SwapType = 0
	// LOOP_IN indicates a loop in swap (on-chain to off-chain)
	SwapType_LOOP_IN SwapType = 1
)

var SwapType_name = map[int32]string{
	0: "LOOP_OUT",
	1: "LOOP_IN",
}

var SwapType_value = map[string]int32{
	"LOOP_OUT": 0,
	"LOOP_IN":  1,
}

func (x SwapType) String() string {
	return proto.EnumName(SwapType_name, int32(x))
}

func (SwapType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{0}
}

type SwapState int32

const (
	//*
	//INITIATED is the initial state of a swap. At that point, the initiation
	//call to the server has been made and the payment process has been started
	//for the swap and prepayment invoices.
	SwapState_INITIATED SwapState = 0
	//*
	//PREIMAGE_REVEALED is reached when the sweep tx publication is first
	//attempted. From that point on, we should consider the preimage to no
	//longer be secret and we need to do all we can to get the sweep confirmed.
	//This state will mostly coalesce with StateHtlcConfirmed, except in the
	//case where we wait for fees to come down before we sweep.
	SwapState_PREIMAGE_REVEALED SwapState = 1
	//*
	//HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in
	//swap.
	SwapState_HTLC_PUBLISHED SwapState = 2
	//*
	//SUCCESS is the final swap state that is reached when the sweep tx has
	//the required confirmation depth.
	SwapState_SUCCESS SwapState = 3
	//*
	//FAILED is the final swap state for a failed swap with or without loss of
	//the swap amount.
	SwapState_FAILED SwapState = 4
	//*
	//INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been
	//paid, but we are still waiting for the htlc spend to confirm.
	SwapState_INVOICE_SETTLED SwapState = 5
)

var SwapState_name = map[int32]string{
	0: "INITIATED",
	1: "PREIMAGE_REVEALED",
	2: "HTLC_PUBLISHED",
	3: "SUCCESS",
	4: "FAILED",
	5: "INVOICE_SETTLED",
}

var SwapState_value = map[string]int32{
	"INITIATED":         0,
	"PREIMAGE_REVEALED": 1,
	"HTLC_PUBLISHED":    2,
	"SUCCESS":           3,
	"FAILED":            4,
	"INVOICE_SETTLED":   5,
}

func (x SwapState) String() string {
	return proto.EnumName(SwapState_name, int32(x))
}

func (SwapState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{1}
}

type FailureReason int32

const (
	//
	//FAILURE_REASON_NONE is set when the swap did not fail, it is either in
	//progress or succeeded.
	FailureReason_FAILURE_REASON_NONE FailureReason = 0
	//
	//FAILURE_REASON_OFFCHAIN indicates that a loop out failed because it wasn't
	//possible to find a route for one or both off chain payments that met the fee
	//and timelock limits required.
	FailureReason_FAILURE_REASON_OFFCHAIN FailureReason = 1
	//
	//FAILURE_REASON_TIMEOUT indicates that the swap failed because on chain htlc
	//did not confirm before its expiry, or it confirmed too late for us to reveal
	//our preimage and claim.
	FailureReason_FAILURE_REASON_TIMEOUT FailureReason = 2
	//
	//FAILURE_REASON_SWEEP_TIMEOUT indicates that a loop out permanently failed
	//because the on chain htlc wasn't swept before the server revoked the
	//htlc.
	FailureReason_FAILURE_REASON_SWEEP_TIMEOUT FailureReason = 3
	//
	//FAILURE_REASON_INSUFFICIENT_VALUE indicates that a loop out has failed
	//because the on chain htlc had a lower value than requested.
	FailureReason_FAILURE_REASON_INSUFFICIENT_VALUE FailureReason = 4
	//
	//FAILURE_REASON_TEMPORARY indicates that a swap cannot continue due to an
	//internal error. Manual intervention such as a restart is required.
	FailureReason_FAILURE_REASON_TEMPORARY FailureReason = 5
	//
	//FAILURE_REASON_INCORRECT_AMOUNT indicates that a loop in permanently failed
	//because the amount extended by an external loop in htlc is insufficient.
	FailureReason_FAILURE_REASON_INCORRECT_AMOUNT FailureReason = 6
)

var FailureReason_name = map[int32]string{
	0: "FAILURE_REASON_NONE",
	1: "FAILURE_REASON_OFFCHAIN",
	2: "FAILURE_REASON_TIMEOUT",
	3: "FAILURE_REASON_SWEEP_TIMEOUT",
	4: "FAILURE_REASON_INSUFFICIENT_VALUE",
	5: "FAILURE_REASON_TEMPORARY",
	6: "FAILURE_REASON_INCORRECT_AMOUNT",
}

var FailureReason_value = map[string]int32{
	"FAILURE_REASON_NONE":               0,
	"FAILURE_REASON_OFFCHAIN":           1,
	"FAILURE_REASON_TIMEOUT":            2,
	"FAILURE_REASON_SWEEP_TIMEOUT":      3,
	"FAILURE_REASON_INSUFFICIENT_VALUE": 4,
	"FAILURE_REASON_TEMPORARY":          5,
	"FAILURE_REASON_INCORRECT_AMOUNT":   6,
}

func (x FailureReason) String() string {
	return proto.EnumName(FailureReason_name, int32(x))
}

func (FailureReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{2}
}

type LoopOutRequest struct {
	//*
	//Requested swap amount in sat. This does not include the swap and miner fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//Base58 encoded destination address for the swap.
	Dest string `protobuf:"bytes,2,opt,name=dest,proto3" json:"dest,omitempty"`
	//*
	//Maximum off-chain fee in sat that may be paid for swap payment to the server.
	//This limit is applied during path finding. Typically this value is taken
	//from the response of the GetQuote call.
	MaxSwapRoutingFee int64 `protobuf:"varint,3,opt,name=max_swap_routing_fee,json=maxSwapRoutingFee,proto3" json:"max_swap_routing_fee,omitempty"`
	//*
	//Maximum off-chain fee in sat that may be paid for the prepay to the server.
	//This limit is applied during path finding. Typically this value is taken
	//from the response of the GetQuote call.
	MaxPrepayRoutingFee int64 `protobuf:"varint,4,opt,name=max_prepay_routing_fee,json=maxPrepayRoutingFee,proto3" json:"max_prepay_routing_fee,omitempty"`
	//*
	//Maximum we are willing to pay the server for the swap. This value is not
	//disclosed in the swap initiation call, but if the server asks for a
	//higher fee, we abort the swap. Typically this value is taken from the
	//response of the GetQuote call. It includes the prepay amount.
	MaxSwapFee int64 `protobuf:"varint,5,opt,name=max_swap_fee,json=maxSwapFee,proto3" json:"max_swap_fee,omitempty"`
	//*
	//Maximum amount of the swap fee that may be charged as a prepayment.
	MaxPrepayAmt int64 `protobuf:"varint,6,opt,name=max_prepay_amt,json=maxPrepayAmt,proto3" json:"max_prepay_amt,omitempty"`
	//*
	//Maximum in on-chain fees that we are willing to spend. If we want to
	//sweep the on-chain htlc and the fee estimate turns out higher than this
	//value, we cancel the swap. If the fee estimate is lower, we publish the
	//sweep tx.
	//
	//If the sweep tx is not confirmed, we are forced to ratchet up fees until it
	//is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
	//timeout. Because the initial publication revealed the preimage, we have no
	//other choice. The server may already have pulled the off-chain htlc. Only
	//when the fee becomes higher than the swap amount, we can only wait for fees
	//to come down and hope - if we are past the timeout - that the server is not
	//publishing the revocation.
	//
	//max_miner_fee is typically taken from the response of the GetQuote call.
	MaxMinerFee int64 `protobuf:"varint,7,opt,name=max_miner_fee,json=maxMinerFee,proto3" json:"max_miner_fee,omitempty"`
	//*
	//Deprecated, use outgoing_chan_set. The channel to loop out, the channel
	//to loop out is selected based on the lowest routing fee for the swap
	//payment to the server.
	LoopOutChannel uint64 `protobuf:"varint,8,opt,name=loop_out_channel,json=loopOutChannel,proto3" json:"loop_out_channel,omitempty"` // Deprecated: Do not use.
	//*
	//A restriction on the channel set that may be used to loop out. The actual
	//channel(s) that will be used are selected based on the lowest routing fee
	//for the swap payment to the server.
	OutgoingChanSet []uint64 `protobuf:"varint,11,rep,packed,name=outgoing_chan_set,json=outgoingChanSet,proto3" json:"outgoing_chan_set,omitempty"`
	//*
	//The number of blocks from the on-chain HTLC's confirmation height that it
	//should be swept within.
	SweepConfTarget int32 `protobuf:"varint,9,opt,name=sweep_conf_target,json=sweepConfTarget,proto3" json:"sweep_conf_target,omitempty"`
	//
	//The number of confirmations that we require for the on chain htlc that will
	//be published by the server before we reveal the preimage.
	HtlcConfirmations int32 `protobuf:"varint,13,opt,name=htlc_confirmations,json=htlcConfirmations,proto3" json:"htlc_confirmations,omitempty"`
	//*
	//The latest time (in unix seconds) we allow the server to wait before
	//publishing the HTLC on chain. Setting this to a larger value will give the
	//server the opportunity to batch multiple swaps together, and wait for
	//low-fee periods before publishing the HTLC, potentially resulting in a
	//lower total swap fee.
	SwapPublicationDeadline uint64 `protobuf:"varint,10,opt,name=swap_publication_deadline,json=swapPublicationDeadline,proto3" json:"swap_publication_deadline,omitempty"`
	//
	//An optional label for this swap. This field is limited to 500 characters
	//and may not start with the prefix [reserved], which is used to tag labels
	//produced by the daemon.
	Label                string   `protobuf:"bytes,12,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopOutRequest) Reset()         { *m = LoopOutRequest{} }
func (m *LoopOutRequest) String() string { return proto.CompactTextString(m) }
func (*LoopOutRequest) ProtoMessage()    {}
func (*LoopOutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{0}
}

func (m *LoopOutRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoopOutRequest.Unmarshal(m, b)
}
func (m *LoopOutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoopOutRequest.Marshal(b, m, deterministic)
}
func (m *LoopOutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopOutRequest.Merge(m, src)
}
func (m *LoopOutRequest) XXX_Size() int {
	return xxx_messageInfo_LoopOutRequest.Size(m)
}
func (m *LoopOutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopOutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoopOutRequest proto.InternalMessageInfo

func (m *LoopOutRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *LoopOutRequest) GetDest() string {
	if m != nil {
		return m.Dest
	}
	return ""
}

func (m *LoopOutRequest) GetMaxSwapRoutingFee() int64 {
	if m != nil {
		return m.MaxSwapRoutingFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxPrepayRoutingFee() int64 {
	if m != nil {
		return m.MaxPrepayRoutingFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxSwapFee() int64 {
	if m != nil {
		return m.MaxSwapFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxPrepayAmt() int64 {
	if m != nil {
		return m.MaxPrepayAmt
	}
	return 0
}

func (m *LoopOutRequest) GetMaxMinerFee() int64 {
	if m != nil {
		return m.MaxMinerFee
	}
	return 0
}

// Deprecated: Do not use.
func (m *LoopOutRequest) GetLoopOutChannel() uint64 {
	if m != nil {
		return m.LoopOutChannel
	}
	return 0
}

func (m *LoopOutRequest) GetOutgoingChanSet() []uint64 {
	if m != nil {
		return m.OutgoingChanSet
	}
	return nil
}

func (m *LoopOutRequest) GetSweepConfTarget() int32 {
	if m != nil {
		return m.SweepConfTarget
	}
	return 0
}

func (m *LoopOutRequest) GetHtlcConfirmations() int32 {
	if m != nil {
		return m.HtlcConfirmations
	}
	return 0
}

func (m *LoopOutRequest) GetSwapPublicationDeadline() uint64 {
	if m != nil {
		return m.SwapPublicationDeadline
	}
	return 0
}

func (m *LoopOutRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type LoopInRequest struct {
	//*
	//Requested swap amount in sat. This does not include the swap and miner
	//fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//Maximum we are willing to pay the server for the swap. This value is not
	//disclosed in the swap initiation call, but if the server asks for a
	//higher fee, we abort the swap. Typically this value is taken from the
	//response of the GetQuote call.
	MaxSwapFee int64 `protobuf:"varint,2,opt,name=max_swap_fee,json=maxSwapFee,proto3" json:"max_swap_fee,omitempty"`
	//*
	//Maximum in on-chain fees that we are willing to spend. If we want to
	//publish the on-chain htlc and the fee estimate turns out higher than this
	//value, we cancel the swap.
	//
	//max_miner_fee is typically taken from the response of the GetQuote call.
	MaxMinerFee int64 `protobuf:"varint,3,opt,name=max_miner_fee,json=maxMinerFee,proto3" json:"max_miner_fee,omitempty"`
	//*
	//The last hop to use for the loop in swap. If empty, the last hop is selected
	//based on the lowest routing fee for the swap payment from the server.
	LastHop []byte `protobuf:"bytes,4,opt,name=last_hop,json=lastHop,proto3" json:"last_hop,omitempty"`
	//*
	//If external_htlc is true, we expect the htlc to be published by an external
	//actor.
	ExternalHtlc bool `protobuf:"varint,5,opt,name=external_htlc,json=externalHtlc,proto3" json:"external_htlc,omitempty"`
	//*
	//The number of blocks that the on chain htlc should confirm within.
	HtlcConfTarget int32 `protobuf:"varint,6,opt,name=htlc_conf_target,json=htlcConfTarget,proto3" json:"htlc_conf_target,omitempty"`
	//
	//An optional label for this swap. This field is limited to 500 characters
	//and may not be one of the reserved values in loop/labels Reserved list.
	Label                string   `protobuf:"bytes,7,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopInRequest) Reset()         { *m = LoopInRequest{} }
func (m *LoopInRequest) String() string { return proto.CompactTextString(m) }
func (*LoopInRequest) ProtoMessage()    {}
func (*LoopInRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{1}
}

func (m *LoopInRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoopInRequest.Unmarshal(m, b)
}
func (m *LoopInRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoopInRequest.Marshal(b, m, deterministic)
}
func (m *LoopInRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopInRequest.Merge(m, src)
}
func (m *LoopInRequest) XXX_Size() int {
	return xxx_messageInfo_LoopInRequest.Size(m)
}
func (m *LoopInRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopInRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoopInRequest proto.InternalMessageInfo

func (m *LoopInRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *LoopInRequest) GetMaxSwapFee() int64 {
	if m != nil {
		return m.MaxSwapFee
	}
	return 0
}

func (m *LoopInRequest) GetMaxMinerFee() int64 {
	if m != nil {
		return m.MaxMinerFee
	}
	return 0
}

func (m *LoopInRequest) GetLastHop() []byte {
	if m != nil {
		return m.LastHop
	}
	return nil
}

func (m *LoopInRequest) GetExternalHtlc() bool {
	if m != nil {
		return m.ExternalHtlc
	}
	return false
}

func (m *LoopInRequest) GetHtlcConfTarget() int32 {
	if m != nil {
		return m.HtlcConfTarget
	}
	return 0
}

func (m *LoopInRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type SwapResponse struct {
	//*
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	//DEPRECATED: To make the API more consistent, this field is deprecated in
	//favor of id_bytes and will be removed in a future release.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // Deprecated: Do not use.
	//*
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	IdBytes []byte `protobuf:"bytes,3,opt,name=id_bytes,json=idBytes,proto3" json:"id_bytes,omitempty"`
	//*
	//DEPRECATED. This field stores the address of the onchain htlc, but
	//depending on the request, the semantics are different.
	//- For internal loop-in htlc_address contains the address of the
	//native segwit (P2WSH) htlc.
	//- For external loop-in htlc_address contains the address of the
	//nested segwit (NP2WSH) htlc.
	//- For loop-out htlc_address always contains the native segwit (P2WSH)
	//htlc address.
	HtlcAddress string `protobuf:"bytes,2,opt,name=htlc_address,json=htlcAddress,proto3" json:"htlc_address,omitempty"` // Deprecated: Do not use.
	//*
	//The nested segwit address of the on-chain htlc.
	//This field remains empty for loop-out.
	HtlcAddressNp2Wsh string `protobuf:"bytes,4,opt,name=htlc_address_np2wsh,json=htlcAddressNp2wsh,proto3" json:"htlc_address_np2wsh,omitempty"`
	//*
	//The native segwit address of the on-chain htlc.
	//Used for both loop-in and loop-out.
	HtlcAddressP2Wsh string `protobuf:"bytes,5,opt,name=htlc_address_p2wsh,json=htlcAddressP2wsh,proto3" json:"htlc_address_p2wsh,omitempty"`
	// A human-readable message received from the loop server.
	ServerMessage        string   `protobuf:"bytes,6,opt,name=server_message,json=serverMessage,proto3" json:"server_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapResponse) Reset()         { *m = SwapResponse{} }
func (m *SwapResponse) String() string { return proto.CompactTextString(m) }
func (*SwapResponse) ProtoMessage()    {}
func (*SwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{2}
}

func (m *SwapResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapResponse.Unmarshal(m, b)
}
func (m *SwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapResponse.Marshal(b, m, deterministic)
}
func (m *SwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapResponse.Merge(m, src)
}
func (m *SwapResponse) XXX_Size() int {
	return xxx_messageInfo_SwapResponse.Size(m)
}
func (m *SwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapResponse proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SwapResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SwapResponse) GetIdBytes() []byte {
	if m != nil {
		return m.IdBytes
	}
	return nil
}

// Deprecated: Do not use.
func (m *SwapResponse) GetHtlcAddress() string {
	if m != nil {
		return m.HtlcAddress
	}
	return ""
}

func (m *SwapResponse) GetHtlcAddressNp2Wsh() string {
	if m != nil {
		return m.HtlcAddressNp2Wsh
	}
	return ""
}

func (m *SwapResponse) GetHtlcAddressP2Wsh() string {
	if m != nil {
		return m.HtlcAddressP2Wsh
	}
	return ""
}

func (m *SwapResponse) GetServerMessage() string {
	if m != nil {
		return m.ServerMessage
	}
	return ""
}

type MonitorRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MonitorRequest) Reset()         { *m = MonitorRequest{} }
func (m *MonitorRequest) String() string { return proto.CompactTextString(m) }
func (*MonitorRequest) ProtoMessage()    {}
func (*MonitorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{3}
}

func (m *MonitorRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MonitorRequest.Unmarshal(m, b)
}
func (m *MonitorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MonitorRequest.Marshal(b, m, deterministic)
}
func (m *MonitorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitorRequest.Merge(m, src)
}
func (m *MonitorRequest) XXX_Size() int {
	return xxx_messageInfo_MonitorRequest.Size(m)
}
func (m *MonitorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MonitorRequest proto.InternalMessageInfo

type SwapStatus struct {
	//*
	//Requested swap amount in sat. This does not include the swap and miner
	//fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	//DEPRECATED: To make the API more consistent, this field is deprecated in
	//favor of id_bytes and will be removed in a future release.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"` // Deprecated: Do not use.
	//*
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	IdBytes []byte `protobuf:"bytes,11,opt,name=id_bytes,json=idBytes,proto3" json:"id_bytes,omitempty"`
	//*
	//Swap type
	Type SwapType `protobuf:"varint,3,opt,name=type,proto3,enum=looprpc.SwapType" json:"type,omitempty"`
	//*
	//State the swap is currently in, see State enum.
	State SwapState `protobuf:"varint,4,opt,name=state,proto3,enum=looprpc.SwapState" json:"state,omitempty"`
	//
	//A failure reason for the swap, only set if the swap has failed.
	FailureReason FailureReason `protobuf:"varint,14,opt,name=failure_reason,json=failureReason,proto3,enum=looprpc.FailureReason" json:"failure_reason,omitempty"`
	//*
	//Initiation time of the swap.
	InitiationTime int64 `protobuf:"varint,5,opt,name=initiation_time,json=initiationTime,proto3" json:"initiation_time,omitempty"`
	//*
	//Initiation time of the swap.
	LastUpdateTime int64 `protobuf:"varint,6,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	//*
	//DEPRECATED:  This field stores the address of the onchain htlc.
	//- For internal loop-in htlc_address contains the address of the
	//native segwit (P2WSH) htlc.
	//- For external loop-in htlc_address contains the nested segwit (NP2WSH)
	//address.
	//- For loop-out htlc_address always contains the native segwit (P2WSH)
	//htlc address.
	HtlcAddress string `protobuf:"bytes,7,opt,name=htlc_address,json=htlcAddress,proto3" json:"htlc_address,omitempty"` // Deprecated: Do not use.
	// HTLC address (native segwit), used in loop-in and loop-out swaps.
	HtlcAddressP2Wsh string `protobuf:"bytes,12,opt,name=htlc_address_p2wsh,json=htlcAddressP2wsh,proto3" json:"htlc_address_p2wsh,omitempty"`
	// HTLC address (nested segwit), used in loop-in swaps only.
	HtlcAddressNp2Wsh string `protobuf:"bytes,13,opt,name=htlc_address_np2wsh,json=htlcAddressNp2wsh,proto3" json:"htlc_address_np2wsh,omitempty"`
	/// Swap server cost
	CostServer int64 `protobuf:"varint,8,opt,name=cost_server,json=costServer,proto3" json:"cost_server,omitempty"`
	// On-chain transaction cost
	CostOnchain int64 `protobuf:"varint,9,opt,name=cost_onchain,json=costOnchain,proto3" json:"cost_onchain,omitempty"`
	// Off-chain routing fees
	CostOffchain int64 `protobuf:"varint,10,opt,name=cost_offchain,json=costOffchain,proto3" json:"cost_offchain,omitempty"`
	// An optional label given to the swap on creation.
	Label                string   `protobuf:"bytes,15,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapStatus) Reset()         { *m = SwapStatus{} }
func (m *SwapStatus) String() string { return proto.CompactTextString(m) }
func (*SwapStatus) ProtoMessage()    {}
func (*SwapStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{4}
}

func (m *SwapStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapStatus.Unmarshal(m, b)
}
func (m *SwapStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapStatus.Marshal(b, m, deterministic)
}
func (m *SwapStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapStatus.Merge(m, src)
}
func (m *SwapStatus) XXX_Size() int {
	return xxx_messageInfo_SwapStatus.Size(m)
}
func (m *SwapStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SwapStatus proto.InternalMessageInfo

func (m *SwapStatus) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

// Deprecated: Do not use.
func (m *SwapStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SwapStatus) GetIdBytes() []byte {
	if m != nil {
		return m.IdBytes
	}
	return nil
}

func (m *SwapStatus) GetType() SwapType {
	if m != nil {
		return m.Type
	}
	return SwapType_LOOP_OUT
}

func (m *SwapStatus) GetState() SwapState {
	if m != nil {
		return m.State
	}
	return SwapState_INITIATED
}

func (m *SwapStatus) GetFailureReason() FailureReason {
	if m != nil {
		return m.FailureReason
	}
	return FailureReason_FAILURE_REASON_NONE
}

func (m *SwapStatus) GetInitiationTime() int64 {
	if m != nil {
		return m.InitiationTime
	}
	return 0
}

func (m *SwapStatus) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

// Deprecated: Do not use.
func (m *SwapStatus) GetHtlcAddress() string {
	if m != nil {
		return m.HtlcAddress
	}
	return ""
}

func (m *SwapStatus) GetHtlcAddressP2Wsh() string {
	if m != nil {
		return m.HtlcAddressP2Wsh
	}
	return ""
}

func (m *SwapStatus) GetHtlcAddressNp2Wsh() string {
	if m != nil {
		return m.HtlcAddressNp2Wsh
	}
	return ""
}

func (m *SwapStatus) GetCostServer() int64 {
	if m != nil {
		return m.CostServer
	}
	return 0
}

func (m *SwapStatus) GetCostOnchain() int64 {
	if m != nil {
		return m.CostOnchain
	}
	return 0
}

func (m *SwapStatus) GetCostOffchain() int64 {
	if m != nil {
		return m.CostOffchain
	}
	return 0
}

func (m *SwapStatus) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type ListSwapsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSwapsRequest) Reset()         { *m = ListSwapsRequest{} }
func (m *ListSwapsRequest) String() string { return proto.CompactTextString(m) }
func (*ListSwapsRequest) ProtoMessage()    {}
func (*ListSwapsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{5}
}

func (m *ListSwapsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSwapsRequest.Unmarshal(m, b)
}
func (m *ListSwapsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSwapsRequest.Marshal(b, m, deterministic)
}
func (m *ListSwapsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSwapsRequest.Merge(m, src)
}
func (m *ListSwapsRequest) XXX_Size() int {
	return xxx_messageInfo_ListSwapsRequest.Size(m)
}
func (m *ListSwapsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSwapsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSwapsRequest proto.InternalMessageInfo

type ListSwapsResponse struct {
	//*
	//The list of all currently known swaps and their status.
	Swaps                []*SwapStatus `protobuf:"bytes,1,rep,name=swaps,proto3" json:"swaps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListSwapsResponse) Reset()         { *m = ListSwapsResponse{} }
func (m *ListSwapsResponse) String() string { return proto.CompactTextString(m) }
func (*ListSwapsResponse) ProtoMessage()    {}
func (*ListSwapsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{6}
}

func (m *ListSwapsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSwapsResponse.Unmarshal(m, b)
}
func (m *ListSwapsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSwapsResponse.Marshal(b, m, deterministic)
}
func (m *ListSwapsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSwapsResponse.Merge(m, src)
}
func (m *ListSwapsResponse) XXX_Size() int {
	return xxx_messageInfo_ListSwapsResponse.Size(m)
}
func (m *ListSwapsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSwapsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSwapsResponse proto.InternalMessageInfo

func (m *ListSwapsResponse) GetSwaps() []*SwapStatus {
	if m != nil {
		return m.Swaps
	}
	return nil
}

type SwapInfoRequest struct {
	//*
	//The swap identifier which currently is the hash that locks the HTLCs. When
	//using REST, this field must be encoded as URL safe base64.
	Id                   []byte   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapInfoRequest) Reset()         { *m = SwapInfoRequest{} }
func (m *SwapInfoRequest) String() string { return proto.CompactTextString(m) }
func (*SwapInfoRequest) ProtoMessage()    {}
func (*SwapInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{7}
}

func (m *SwapInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapInfoRequest.Unmarshal(m, b)
}
func (m *SwapInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapInfoRequest.Marshal(b, m, deterministic)
}
func (m *SwapInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapInfoRequest.Merge(m, src)
}
func (m *SwapInfoRequest) XXX_Size() int {
	return xxx_messageInfo_SwapInfoRequest.Size(m)
}
func (m *SwapInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapInfoRequest proto.InternalMessageInfo

func (m *SwapInfoRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type TermsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TermsRequest) Reset()         { *m = TermsRequest{} }
func (m *TermsRequest) String() string { return proto.CompactTextString(m) }
func (*TermsRequest) ProtoMessage()    {}
func (*TermsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{8}
}

func (m *TermsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TermsRequest.Unmarshal(m, b)
}
func (m *TermsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TermsRequest.Marshal(b, m, deterministic)
}
func (m *TermsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TermsRequest.Merge(m, src)
}
func (m *TermsRequest) XXX_Size() int {
	return xxx_messageInfo_TermsRequest.Size(m)
}
func (m *TermsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TermsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TermsRequest proto.InternalMessageInfo

type InTermsResponse struct {
	//*
	//Minimum swap amount (sat)
	MinSwapAmount int64 `protobuf:"varint,5,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	//*
	//Maximum swap amount (sat)
	MaxSwapAmount        int64    `protobuf:"varint,6,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InTermsResponse) Reset()         { *m = InTermsResponse{} }
func (m *InTermsResponse) String() string { return proto.CompactTextString(m) }
func (*InTermsResponse) ProtoMessage()    {}
func (*InTermsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{9}
}

func (m *InTermsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InTermsResponse.Unmarshal(m, b)
}
func (m *InTermsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InTermsResponse.Marshal(b, m, deterministic)
}
func (m *InTermsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InTermsResponse.Merge(m, src)
}
func (m *InTermsResponse) XXX_Size() int {
	return xxx_messageInfo_InTermsResponse.Size(m)
}
func (m *InTermsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InTermsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InTermsResponse proto.InternalMessageInfo

func (m *InTermsResponse) GetMinSwapAmount() int64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *InTermsResponse) GetMaxSwapAmount() int64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

type OutTermsResponse struct {
	//*
	//Minimum swap amount (sat)
	MinSwapAmount int64 `protobuf:"varint,5,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	//*
	//Maximum swap amount (sat)
	MaxSwapAmount int64 `protobuf:"varint,6,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	// The minimally accepted cltv delta of the on-chain htlc.
	MinCltvDelta int32 `protobuf:"varint,8,opt,name=min_cltv_delta,json=minCltvDelta,proto3" json:"min_cltv_delta,omitempty"`
	// The maximally accepted cltv delta of the on-chain htlc.
	MaxCltvDelta         int32    `protobuf:"varint,9,opt,name=max_cltv_delta,json=maxCltvDelta,proto3" json:"max_cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutTermsResponse) Reset()         { *m = OutTermsResponse{} }
func (m *OutTermsResponse) String() string { return proto.CompactTextString(m) }
func (*OutTermsResponse) ProtoMessage()    {}
func (*OutTermsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{10}
}

func (m *OutTermsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutTermsResponse.Unmarshal(m, b)
}
func (m *OutTermsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutTermsResponse.Marshal(b, m, deterministic)
}
func (m *OutTermsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutTermsResponse.Merge(m, src)
}
func (m *OutTermsResponse) XXX_Size() int {
	return xxx_messageInfo_OutTermsResponse.Size(m)
}
func (m *OutTermsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OutTermsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OutTermsResponse proto.InternalMessageInfo

func (m *OutTermsResponse) GetMinSwapAmount() int64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *OutTermsResponse) GetMaxSwapAmount() int64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

func (m *OutTermsResponse) GetMinCltvDelta() int32 {
	if m != nil {
		return m.MinCltvDelta
	}
	return 0
}

func (m *OutTermsResponse) GetMaxCltvDelta() int32 {
	if m != nil {
		return m.MaxCltvDelta
	}
	return 0
}

type QuoteRequest struct {
	//*
	//The amount to swap in satoshis.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//The confirmation target that should be used either for the sweep of the
	//on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
	//the confirmation of the on-chain HTLC broadcast by the swap client in the
	//case of a Loop In.
	ConfTarget int32 `protobuf:"varint,2,opt,name=conf_target,json=confTarget,proto3" json:"conf_target,omitempty"`
	//*
	//If external_htlc is true, we expect the htlc to be published by an external
	//actor.
	ExternalHtlc bool `protobuf:"varint,3,opt,name=external_htlc,json=externalHtlc,proto3" json:"external_htlc,omitempty"`
	//*
	//The latest time (in unix seconds) we allow the server to wait before
	//publishing the HTLC on chain. Setting this to a larger value will give the
	//server the opportunity to batch multiple swaps together, and wait for
	//low-fee periods before publishing the HTLC, potentially resulting in a
	//lower total swap fee. This only has an effect on loop out quotes.
	SwapPublicationDeadline uint64   `protobuf:"varint,4,opt,name=swap_publication_deadline,json=swapPublicationDeadline,proto3" json:"swap_publication_deadline,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *QuoteRequest) Reset()         { *m = QuoteRequest{} }
func (m *QuoteRequest) String() string { return proto.CompactTextString(m) }
func (*QuoteRequest) ProtoMessage()    {}
func (*QuoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{11}
}

func (m *QuoteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QuoteRequest.Unmarshal(m, b)
}
func (m *QuoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QuoteRequest.Marshal(b, m, deterministic)
}
func (m *QuoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuoteRequest.Merge(m, src)
}
func (m *QuoteRequest) XXX_Size() int {
	return xxx_messageInfo_QuoteRequest.Size(m)
}
func (m *QuoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuoteRequest proto.InternalMessageInfo

func (m *QuoteRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *QuoteRequest) GetConfTarget() int32 {
	if m != nil {
		return m.ConfTarget
	}
	return 0
}

func (m *QuoteRequest) GetExternalHtlc() bool {
	if m != nil {
		return m.ExternalHtlc
	}
	return false
}

func (m *QuoteRequest) GetSwapPublicationDeadline() uint64 {
	if m != nil {
		return m.SwapPublicationDeadline
	}
	return 0
}

type InQuoteResponse struct {
	//*
	//The fee that the swap server is charging for the swap.
	SwapFeeSat int64 `protobuf:"varint,1,opt,name=swap_fee_sat,json=swapFeeSat,proto3" json:"swap_fee_sat,omitempty"`
	//
	//An estimate of the on-chain fee that needs to be paid to publish the HTLC
	//If a miner fee of 0 is returned, it means the external_htlc flag was set for
	//a loop in and the fee estimation was skipped. If a miner fee of -1 is
	//returned, it means lnd's wallet tried to estimate the fee but was unable to
	//create a sample estimation transaction because not enough funds are
	//available. An information message should be shown to the user in this case.
	HtlcPublishFeeSat int64 `protobuf:"varint,3,opt,name=htlc_publish_fee_sat,json=htlcPublishFeeSat,proto3" json:"htlc_publish_fee_sat,omitempty"`
	//*
	//On-chain cltv expiry delta
	CltvDelta            int32    `protobuf:"varint,5,opt,name=cltv_delta,json=cltvDelta,proto3" json:"cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InQuoteResponse) Reset()         { *m = InQuoteResponse{} }
func (m *InQuoteResponse) String() string { return proto.CompactTextString(m) }
func (*InQuoteResponse) ProtoMessage()    {}
func (*InQuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{12}
}

func (m *InQuoteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InQuoteResponse.Unmarshal(m, b)
}
func (m *InQuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InQuoteResponse.Marshal(b, m, deterministic)
}
func (m *InQuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InQuoteResponse.Merge(m, src)
}
func (m *InQuoteResponse) XXX_Size() int {
	return xxx_messageInfo_InQuoteResponse.Size(m)
}
func (m *InQuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InQuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InQuoteResponse proto.InternalMessageInfo

func (m *InQuoteResponse) GetSwapFeeSat() int64 {
	if m != nil {
		return m.SwapFeeSat
	}
	return 0
}

func (m *InQuoteResponse) GetHtlcPublishFeeSat() int64 {
	if m != nil {
		return m.HtlcPublishFeeSat
	}
	return 0
}

func (m *InQuoteResponse) GetCltvDelta() int32 {
	if m != nil {
		return m.CltvDelta
	}
	return 0
}

type OutQuoteResponse struct {
	//*
	//The fee that the swap server is charging for the swap.
	SwapFeeSat int64 `protobuf:"varint,1,opt,name=swap_fee_sat,json=swapFeeSat,proto3" json:"swap_fee_sat,omitempty"`
	//*
	//The part of the swap fee that is requested as a prepayment.
	PrepayAmtSat int64 `protobuf:"varint,2,opt,name=prepay_amt_sat,json=prepayAmtSat,proto3" json:"prepay_amt_sat,omitempty"`
	//*
	//An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
	//a loop out.
	HtlcSweepFeeSat int64 `protobuf:"varint,3,opt,name=htlc_sweep_fee_sat,json=htlcSweepFeeSat,proto3" json:"htlc_sweep_fee_sat,omitempty"`
	//*
	//The node pubkey where the swap payment needs to be paid
	//to. This can be used to test connectivity before initiating the swap.
	SwapPaymentDest []byte `protobuf:"bytes,4,opt,name=swap_payment_dest,json=swapPaymentDest,proto3" json:"swap_payment_dest,omitempty"`
	//*
	//On-chain cltv expiry delta
	CltvDelta            int32    `protobuf:"varint,5,opt,name=cltv_delta,json=cltvDelta,proto3" json:"cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutQuoteResponse) Reset()         { *m = OutQuoteResponse{} }
func (m *OutQuoteResponse) String() string { return proto.CompactTextString(m) }
func (*OutQuoteResponse) ProtoMessage()    {}
func (*OutQuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{13}
}

func (m *OutQuoteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutQuoteResponse.Unmarshal(m, b)
}
func (m *OutQuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutQuoteResponse.Marshal(b, m, deterministic)
}
func (m *OutQuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutQuoteResponse.Merge(m, src)
}
func (m *OutQuoteResponse) XXX_Size() int {
	return xxx_messageInfo_OutQuoteResponse.Size(m)
}
func (m *OutQuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OutQuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OutQuoteResponse proto.InternalMessageInfo

func (m *OutQuoteResponse) GetSwapFeeSat() int64 {
	if m != nil {
		return m.SwapFeeSat
	}
	return 0
}

func (m *OutQuoteResponse) GetPrepayAmtSat() int64 {
	if m != nil {
		return m.PrepayAmtSat
	}
	return 0
}

func (m *OutQuoteResponse) GetHtlcSweepFeeSat() int64 {
	if m != nil {
		return m.HtlcSweepFeeSat
	}
	return 0
}

func (m *OutQuoteResponse) GetSwapPaymentDest() []byte {
	if m != nil {
		return m.SwapPaymentDest
	}
	return nil
}

func (m *OutQuoteResponse) GetCltvDelta() int32 {
	if m != nil {
		return m.CltvDelta
	}
	return 0
}

type TokensRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokensRequest) Reset()         { *m = TokensRequest{} }
func (m *TokensRequest) String() string { return proto.CompactTextString(m) }
func (*TokensRequest) ProtoMessage()    {}
func (*TokensRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{14}
}

func (m *TokensRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokensRequest.Unmarshal(m, b)
}
func (m *TokensRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokensRequest.Marshal(b, m, deterministic)
}
func (m *TokensRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokensRequest.Merge(m, src)
}
func (m *TokensRequest) XXX_Size() int {
	return xxx_messageInfo_TokensRequest.Size(m)
}
func (m *TokensRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TokensRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TokensRequest proto.InternalMessageInfo

type TokensResponse struct {
	//*
	//List of all tokens the daemon knows of, including old/expired tokens.
	Tokens               []*LsatToken `protobuf:"bytes,1,rep,name=tokens,proto3" json:"tokens,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TokensResponse) Reset()         { *m = TokensResponse{} }
func (m *TokensResponse) String() string { return proto.CompactTextString(m) }
func (*TokensResponse) ProtoMessage()    {}
func (*TokensResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{15}
}

func (m *TokensResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokensResponse.Unmarshal(m, b)
}
func (m *TokensResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokensResponse.Marshal(b, m, deterministic)
}
func (m *TokensResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokensResponse.Merge(m, src)
}
func (m *TokensResponse) XXX_Size() int {
	return xxx_messageInfo_TokensResponse.Size(m)
}
func (m *TokensResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TokensResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TokensResponse proto.InternalMessageInfo

func (m *TokensResponse) GetTokens() []*LsatToken {
	if m != nil {
		return m.Tokens
	}
	return nil
}

type LsatToken struct {
	//*
	//The base macaroon that was baked by the auth server.
	BaseMacaroon []byte `protobuf:"bytes,1,opt,name=base_macaroon,json=baseMacaroon,proto3" json:"base_macaroon,omitempty"`
	//*
	//The payment hash of the payment that was paid to obtain the token.
	PaymentHash []byte `protobuf:"bytes,2,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	//*
	//The preimage of the payment hash, knowledge of this is proof that the
	//payment has been paid. If the preimage is set to all zeros, this means the
	//payment is still pending and the token is not yet fully valid.
	PaymentPreimage []byte `protobuf:"bytes,3,opt,name=payment_preimage,json=paymentPreimage,proto3" json:"payment_preimage,omitempty"`
	//*
	//The amount of millisatoshis that was paid to get the token.
	AmountPaidMsat int64 `protobuf:"varint,4,opt,name=amount_paid_msat,json=amountPaidMsat,proto3" json:"amount_paid_msat,omitempty"`
	//*
	//The amount of millisatoshis paid in routing fee to pay for the token.
	RoutingFeePaidMsat int64 `protobuf:"varint,5,opt,name=routing_fee_paid_msat,json=routingFeePaidMsat,proto3" json:"routing_fee_paid_msat,omitempty"`
	//*
	//The creation time of the token as UNIX timestamp in seconds.
	TimeCreated int64 `protobuf:"varint,6,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	//*
	//Indicates whether the token is expired or still valid.
	Expired bool `protobuf:"varint,7,opt,name=expired,proto3" json:"expired,omitempty"`
	//*
	//Identifying attribute of this token in the store. Currently represents the
	//file name of the token where it's stored on the file system.
	StorageName          string   `protobuf:"bytes,8,opt,name=storage_name,json=storageName,proto3" json:"storage_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LsatToken) Reset()         { *m = LsatToken{} }
func (m *LsatToken) String() string { return proto.CompactTextString(m) }
func (*LsatToken) ProtoMessage()    {}
func (*LsatToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{16}
}

func (m *LsatToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LsatToken.Unmarshal(m, b)
}
func (m *LsatToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LsatToken.Marshal(b, m, deterministic)
}
func (m *LsatToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LsatToken.Merge(m, src)
}
func (m *LsatToken) XXX_Size() int {
	return xxx_messageInfo_LsatToken.Size(m)
}
func (m *LsatToken) XXX_DiscardUnknown() {
	xxx_messageInfo_LsatToken.DiscardUnknown(m)
}

var xxx_messageInfo_LsatToken proto.InternalMessageInfo

func (m *LsatToken) GetBaseMacaroon() []byte {
	if m != nil {
		return m.BaseMacaroon
	}
	return nil
}

func (m *LsatToken) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *LsatToken) GetPaymentPreimage() []byte {
	if m != nil {
		return m.PaymentPreimage
	}
	return nil
}

func (m *LsatToken) GetAmountPaidMsat() int64 {
	if m != nil {
		return m.AmountPaidMsat
	}
	return 0
}

func (m *LsatToken) GetRoutingFeePaidMsat() int64 {
	if m != nil {
		return m.RoutingFeePaidMsat
	}
	return 0
}

func (m *LsatToken) GetTimeCreated() int64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *LsatToken) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

func (m *LsatToken) GetStorageName() string {
	if m != nil {
		return m.StorageName
	}
	return ""
}

type MacaroonPermission struct {
	// The entity a permission grants access to.
	Entity string `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
	// The action that is granted.
	Action               string   `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MacaroonPermission) Reset()         { *m = MacaroonPermission{} }
func (m *MacaroonPermission) String() string { return proto.CompactTextString(m) }
func (*MacaroonPermission) ProtoMessage()    {}
func (*MacaroonPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{17}
}

func (m *MacaroonPermission) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MacaroonPermission.Unmarshal(m, b)
}
func (m *MacaroonPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MacaroonPermission.Marshal(b, m, deterministic)
}
func (m *MacaroonPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MacaroonPermission.Merge(m, src)
}
func (m *MacaroonPermission) XXX_Size() int {
	return xxx_messageInfo_MacaroonPermission.Size(m)
}
func (m *MacaroonPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_MacaroonPermission.DiscardUnknown(m)
}

var xxx_messageInfo_MacaroonPermission proto.InternalMessageInfo

func (m *MacaroonPermission) GetEntity() string {
	if m != nil {
		return m.Entity
	}
	return ""
}

func (m *MacaroonPermission) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

type BakeMacaroonRequest struct {
	// The list of permissions the new macaroon should grant.
	Permissions []*MacaroonPermission `protobuf:"bytes,1,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// The root key ID used to create the macaroon, must be a positive integer.
	RootKeyId            uint64   `protobuf:"varint,2,opt,name=root_key_id,json=rootKeyId,proto3" json:"root_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BakeMacaroonRequest) Reset()         { *m = BakeMacaroonRequest{} }
func (m *BakeMacaroonRequest) String() string { return proto.CompactTextString(m) }
func (*BakeMacaroonRequest) ProtoMessage()    {}
func (*BakeMacaroonRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{18}
}

func (m *BakeMacaroonRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BakeMacaroonRequest.Unmarshal(m, b)
}
func (m *BakeMacaroonRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BakeMacaroonRequest.Marshal(b, m, deterministic)
}
func (m *BakeMacaroonRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BakeMacaroonRequest.Merge(m, src)
}
func (m *BakeMacaroonRequest) XXX_Size() int {
	return xxx_messageInfo_BakeMacaroonRequest.Size(m)
}
func (m *BakeMacaroonRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BakeMacaroonRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BakeMacaroonRequest proto.InternalMessageInfo

func (m *BakeMacaroonRequest) GetPermissions() []*MacaroonPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *BakeMacaroonRequest) GetRootKeyId() uint64 {
	if m != nil {
		return m.RootKeyId
	}
	return 0
}

type BakeMacaroonResponse struct {
	// The hex encoded macaroon, serialized in binary format.
	Macaroon             string   `protobuf:"bytes,1,opt,name=macaroon,proto3" json:"macaroon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BakeMacaroonResponse) Reset()         { *m = BakeMacaroonResponse{} }
func (m *BakeMacaroonResponse) String() string { return proto.CompactTextString(m) }
func (*BakeMacaroonResponse) ProtoMessage()    {}
func (*BakeMacaroonResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{19}
}

func (m *BakeMacaroonResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BakeMacaroonResponse.Unmarshal(m, b)
}
func (m *BakeMacaroonResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BakeMacaroonResponse.Marshal(b, m, deterministic)
}
func (m *BakeMacaroonResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BakeMacaroonResponse.Merge(m, src)
}
func (m *BakeMacaroonResponse) XXX_Size() int {
	return xxx_messageInfo_BakeMacaroonResponse.Size(m)
}
func (m *BakeMacaroonResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BakeMacaroonResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BakeMacaroonResponse proto.InternalMessageInfo

func (m *BakeMacaroonResponse) GetMacaroon() string {
	if m != nil {
		return m.Macaroon
	}
	return ""
}

type MacaroonPermissionList struct {
	// A list of macaroon permissions.
	Permissions          []*MacaroonPermission `protobuf:"bytes,1,rep,name=permissions,proto3" json:"permissions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MacaroonPermissionList) Reset()         { *m = MacaroonPermissionList{} }
func (m *MacaroonPermissionList) String() string { return proto.CompactTextString(m) }
func (*MacaroonPermissionList) ProtoMessage()    {}
func (*MacaroonPermissionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{20}
}

func (m *MacaroonPermissionList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MacaroonPermissionList.Unmarshal(m, b)
}
func (m *MacaroonPermissionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MacaroonPermissionList.Marshal(b, m, deterministic)
}
func (m *MacaroonPermissionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MacaroonPermissionList.Merge(m, src)
}
func (m *MacaroonPermissionList) XXX_Size() int {
	return xxx_messageInfo_MacaroonPermissionList.Size(m)
}
func (m *MacaroonPermissionList) XXX_DiscardUnknown() {
	xxx_messageInfo_MacaroonPermissionList.DiscardUnknown(m)
}

var xxx_messageInfo_MacaroonPermissionList proto.InternalMessageInfo

func (m *MacaroonPermissionList) GetPermissions() []*MacaroonPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type ListPermissionsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPermissionsRequest) Reset()         { *m = ListPermissionsRequest{} }
func (m *ListPermissionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListPermissionsRequest) ProtoMessage()    {}
func (*ListPermissionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{21}
}

func (m *ListPermissionsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPermissionsRequest.Unmarshal(m, b)
}
func (m *ListPermissionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPermissionsRequest.Marshal(b, m, deterministic)
}
func (m *ListPermissionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPermissionsRequest.Merge(m, src)
}
func (m *ListPermissionsRequest) XXX_Size() int {
	return xxx_messageInfo_ListPermissionsRequest.Size(m)
}
func (m *ListPermissionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPermissionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPermissionsRequest proto.InternalMessageInfo

type ListPermissionsResponse struct {
	//
	//A map between all RPC method URIs and their required macaroon permissions to
	//access them.
	MethodPermissions    map[string]*MacaroonPermissionList `protobuf:"bytes,1,rep,name=method_permissions,json=methodPermissions,proto3" json:"method_permissions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *ListPermissionsResponse) Reset()         { *m = ListPermissionsResponse{} }
func (m *ListPermissionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListPermissionsResponse) ProtoMessage()    {}
func (*ListPermissionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{22}
}

func (m *ListPermissionsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPermissionsResponse.Unmarshal(m, b)
}
func (m *ListPermissionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPermissionsResponse.Marshal(b, m, deterministic)
}
func (m *ListPermissionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPermissionsResponse.Merge(m, src)
}
func (m *ListPermissionsResponse) XXX_Size() int {
	return xxx_messageInfo_ListPermissionsResponse.Size(m)
}
func (m *ListPermissionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPermissionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListPermissionsResponse proto.InternalMessageInfo

func (m *ListPermissionsResponse) GetMethodPermissions() map[string]*MacaroonPermissionList {
	if m != nil {
		return m.MethodPermissions
	}
	return nil
}

func init() {
	proto.RegisterEnum("looprpc.SwapType", SwapType_name, SwapType_value)
	proto.RegisterEnum("looprpc.SwapState", SwapState_name, SwapState_value)
	proto.RegisterEnum("looprpc.FailureReason", FailureReason_name, FailureReason_value)
	proto.RegisterType((*LoopOutRequest)(nil), "looprpc.LoopOutRequest")
	proto.RegisterType((*LoopInRequest)(nil), "looprpc.LoopInRequest")
	proto.RegisterType((*SwapResponse)(nil), "looprpc.SwapResponse")
	proto.RegisterType((*MonitorRequest)(nil), "looprpc.MonitorRequest")
	proto.RegisterType((*SwapStatus)(nil), "looprpc.SwapStatus")
	proto.RegisterType((*ListSwapsRequest)(nil), "looprpc.ListSwapsRequest")
	proto.RegisterType((*ListSwapsResponse)(nil), "looprpc.ListSwapsResponse")
	proto.RegisterType((*SwapInfoRequest)(nil), "looprpc.SwapInfoRequest")
	proto.RegisterType((*TermsRequest)(nil), "looprpc.TermsRequest")
	proto.RegisterType((*InTermsResponse)(nil), "looprpc.InTermsResponse")
	proto.RegisterType((*OutTermsResponse)(nil), "looprpc.OutTermsResponse")
	proto.RegisterType((*QuoteRequest)(nil), "looprpc.QuoteRequest")
	proto.RegisterType((*InQuoteResponse)(nil), "looprpc.InQuoteResponse")
	proto.RegisterType((*OutQuoteResponse)(nil), "looprpc.OutQuoteResponse")
	proto.RegisterType((*TokensRequest)(nil), "looprpc.TokensRequest")
	proto.RegisterType((*TokensResponse)(nil), "looprpc.TokensResponse")
	proto.RegisterType((*LsatToken)(nil), "looprpc.LsatToken")
	proto.RegisterType((*MacaroonPermission)(nil), "looprpc.MacaroonPermission")
	proto.RegisterType((*BakeMacaroonRequest)(nil), "looprpc.BakeMacaroonRequest")
	proto.RegisterType((*BakeMacaroonResponse)(nil), "looprpc.BakeMacaroonResponse")
	proto.RegisterType((*MacaroonPermissionList)(nil), "looprpc.MacaroonPermissionList")
	proto.RegisterType((*ListPermissionsRequest)(nil), "looprpc.ListPermissionsRequest")
	proto.RegisterType((*ListPermissionsResponse)(nil), "looprpc.ListPermissionsResponse")
	proto.RegisterMapType((map[string]*MacaroonPermissionList)(nil), "looprpc.ListPermissionsResponse.MethodPermissionsEntry")
}

func init() { proto.RegisterFile("client.proto", fileDescriptor_014de31d7ac8c57c) }

var fileDescriptor_014de31d7ac8c57c = []byte{
	// 2085 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xdb, 0x6e, 0x23, 0x49,
	0x19, 0x9e, 0xf6, 0x21, 0xb6, 0x7f, 0xb7, 0xdb, 0x9d, 0xca, 0x4c, 0xe2, 0xf1, 0xce, 0x32, 0x9e,
	0xde, 0x1d, 0xc8, 0x86, 0x25, 0x66, 0xb3, 0x42, 0xc0, 0x88, 0x45, 0xf2, 0x38, 0xce, 0xc6, 0x21,
	0x3e, 0xd0, 0x76, 0x66, 0xb5, 0x08, 0xa9, 0x55, 0xb1, 0x2b, 0x71, 0x6b, 0xdc, 0x87, 0xed, 0x2e,
	0x67, 0x12, 0xad, 0x10, 0x12, 0x2f, 0xb0, 0x17, 0xbc, 0x01, 0xcf, 0xc0, 0x1d, 0xaf, 0xc0, 0x15,
	0xfb, 0x0a, 0x48, 0xc0, 0x05, 0xef, 0x80, 0xea, 0xd0, 0xed, 0x6e, 0xdb, 0xc9, 0x0a, 0x21, 0xee,
	0xd2, 0xdf, 0xff, 0xd5, 0x5f, 0xf5, 0x9f, 0x7f, 0x07, 0xd4, 0xc9, 0xdc, 0x26, 0x2e, 0x3d, 0xf4,
	0x03, 0x8f, 0x7a, 0xa8, 0x30, 0xf7, 0x3c, 0x3f, 0xf0, 0x27, 0xf5, 0x67, 0xd7, 0x9e, 0x77, 0x3d,
	0x27, 0x4d, 0xec, 0xdb, 0x4d, 0xec, 0xba, 0x1e, 0xc5, 0xd4, 0xf6, 0xdc, 0x50, 0xd0, 0x8c, 0x6f,
	0x72, 0xa0, 0x9d, 0x7b, 0x9e, 0x3f, 0x58, 0x50, 0x93, 0x7c, 0xb5, 0x20, 0x21, 0x45, 0x3a, 0x64,
	0xb1, 0x43, 0x6b, 0x4a, 0x43, 0xd9, 0xcf, 0x9a, 0xec, 0x4f, 0x84, 0x20, 0x37, 0x25, 0x21, 0xad,
	0x65, 0x1a, 0xca, 0x7e, 0xc9, 0xe4, 0x7f, 0xa3, 0x26, 0x3c, 0x76, 0xf0, 0xad, 0x15, 0xbe, 0xc3,
	0xbe, 0x15, 0x78, 0x0b, 0x6a, 0xbb, 0xd7, 0xd6, 0x15, 0x21, 0xb5, 0x2c, 0x3f, 0xb6, 0xed, 0xe0,
	0xdb, 0xd1, 0x3b, 0xec, 0x9b, 0x42, 0x72, 0x42, 0x08, 0xfa, 0x14, 0x76, 0xd9, 0x01, 0x3f, 0x20,
	0x3e, 0xbe, 0x4b, 0x1d, 0xc9, 0xf1, 0x23, 0x3b, 0x0e, 0xbe, 0x1d, 0x72, 0x61, 0xe2, 0x50, 0x03,
	0xd4, 0xf8, 0x16, 0x46, 0xcd, 0x73, 0x2a, 0x48, 0xed, 0x8c, 0xf1, 0x21, 0x68, 0x09, 0xb5, 0xec,
	0xe1, 0x5b, 0x9c, 0xa3, 0xc6, 0xea, 0x5a, 0x0e, 0x45, 0x06, 0x54, 0x18, 0xcb, 0xb1, 0x5d, 0x12,
	0x70, 0x45, 0x05, 0x4e, 0x2a, 0x3b, 0xf8, 0xb6, 0xc7, 0x30, 0xa6, 0xe9, 0x63, 0xd0, 0x99, 0xcf,
	0x2c, 0x6f, 0x41, 0xad, 0xc9, 0x0c, 0xbb, 0x2e, 0x99, 0xd7, 0x8a, 0x0d, 0x65, 0x3f, 0xf7, 0x3a,
	0x53, 0x53, 0x4c, 0x6d, 0x2e, 0xbc, 0xd4, 0x16, 0x12, 0x74, 0x00, 0xdb, 0xde, 0x82, 0x5e, 0x7b,
	0xcc, 0x08, 0xc6, 0xb6, 0x42, 0x42, 0x6b, 0xe5, 0x46, 0x76, 0x3f, 0x67, 0x56, 0x23, 0x01, 0xe3,
	0x8e, 0x08, 0x65, 0xdc, 0xf0, 0x1d, 0x21, 0xbe, 0x35, 0xf1, 0xdc, 0x2b, 0x8b, 0xe2, 0xe0, 0x9a,
	0xd0, 0x5a, 0xa9, 0xa1, 0xec, 0xe7, 0xcd, 0x2a, 0x17, 0xb4, 0x3d, 0xf7, 0x6a, 0xcc, 0x61, 0xf4,
	0x23, 0x40, 0x33, 0x3a, 0x9f, 0x70, 0xaa, 0x1d, 0x38, 0x22, 0x58, 0xb5, 0x0a, 0x27, 0x6f, 0x33,
	0x49, 0x3b, 0x29, 0x40, 0xaf, 0xe0, 0x29, 0x77, 0x8e, 0xbf, 0xb8, 0x9c, 0xdb, 0x13, 0x0e, 0x5a,
	0x53, 0x82, 0xa7, 0x73, 0xdb, 0x25, 0x35, 0x60, 0xaf, 0x37, 0xf7, 0x18, 0x61, 0xb8, 0x94, 0x1f,
	0x4b, 0x31, 0x7a, 0x0c, 0xf9, 0x39, 0xbe, 0x24, 0xf3, 0x9a, 0xca, 0xe3, 0x2a, 0x3e, 0x8c, 0x7f,
	0x28, 0x50, 0x61, 0x19, 0xd1, 0x75, 0xef, 0x4f, 0x88, 0xd5, 0xb0, 0x64, 0xd6, 0xc2, 0xb2, 0xe6,
	0xf0, 0xec, 0xba, 0xc3, 0x9f, 0x42, 0x71, 0x8e, 0x43, 0x6a, 0xcd, 0x3c, 0x9f, 0xe7, 0x80, 0x6a,
	0x16, 0xd8, 0xf7, 0xa9, 0xe7, 0xa3, 0x0f, 0xa0, 0x42, 0x6e, 0x29, 0x09, 0x5c, 0x3c, 0xb7, 0x98,
	0xd1, 0x3c, 0xf0, 0x45, 0x53, 0x8d, 0xc0, 0x53, 0x3a, 0x9f, 0xa0, 0x7d, 0xd0, 0x63, 0x57, 0x45,
	0x5e, 0xdd, 0xe2, 0x8e, 0xd2, 0x22, 0x47, 0x49, 0xa7, 0xc6, 0x96, 0x16, 0x92, 0x96, 0xfe, 0x4b,
	0x01, 0x95, 0x27, 0x29, 0x09, 0x7d, 0xcf, 0x0d, 0x09, 0x42, 0x90, 0xb1, 0xa7, 0xdc, 0xce, 0x12,
	0x8f, 0x79, 0xc6, 0x9e, 0xb2, 0x47, 0xda, 0x53, 0xeb, 0xf2, 0x8e, 0x92, 0x90, 0xdb, 0xa0, 0x9a,
	0x05, 0x7b, 0xfa, 0x9a, 0x7d, 0xa2, 0x97, 0xa0, 0xf2, 0xfb, 0xf1, 0x74, 0x1a, 0x90, 0x30, 0x14,
	0xe5, 0xc1, 0x0f, 0x96, 0x19, 0xde, 0x12, 0x30, 0x3a, 0x84, 0x9d, 0x24, 0xcd, 0x72, 0xfd, 0xa3,
	0x77, 0xe1, 0x8c, 0x5b, 0x5c, 0x12, 0x21, 0x95, 0xcc, 0x3e, 0x17, 0xa0, 0x8f, 0x65, 0x06, 0x44,
	0x7c, 0x41, 0xcf, 0x73, 0xba, 0x9e, 0xa0, 0x0f, 0x39, 0xfb, 0x25, 0x68, 0x21, 0x09, 0x6e, 0x48,
	0x60, 0x39, 0x24, 0x0c, 0xf1, 0x35, 0xe1, 0x2e, 0x28, 0x99, 0x15, 0x81, 0xf6, 0x04, 0x68, 0xe8,
	0xa0, 0xf5, 0x3c, 0xd7, 0xa6, 0x5e, 0x20, 0xa3, 0x6a, 0xfc, 0x39, 0x07, 0xc0, 0xac, 0x1f, 0x51,
	0x4c, 0x17, 0xe1, 0xc6, 0xaa, 0x67, 0xde, 0xc8, 0xdc, 0xeb, 0x8d, 0xf2, 0xaa, 0x37, 0x72, 0xf4,
	0xce, 0x17, 0x81, 0xd6, 0x8e, 0xb6, 0x0f, 0x65, 0xff, 0x39, 0x64, 0x77, 0x8c, 0xef, 0x7c, 0x62,
	0x72, 0x31, 0xda, 0x87, 0x7c, 0x48, 0x31, 0x15, 0x55, 0xaf, 0x1d, 0xa1, 0x14, 0x8f, 0xbd, 0x85,
	0x98, 0x82, 0x80, 0x3e, 0x03, 0xed, 0x0a, 0xdb, 0xf3, 0x45, 0x40, 0xac, 0x80, 0xe0, 0xd0, 0x73,
	0x6b, 0x1a, 0x3f, 0xb2, 0x1b, 0x1f, 0x39, 0x11, 0x62, 0x93, 0x4b, 0xcd, 0xca, 0x55, 0xf2, 0x13,
	0xfd, 0x00, 0xaa, 0xb6, 0x6b, 0x53, 0x5b, 0xd4, 0x04, 0xb5, 0x9d, 0xa8, 0x7b, 0x68, 0x4b, 0x78,
	0x6c, 0x3b, 0xec, 0x45, 0x3a, 0x4f, 0xc3, 0x85, 0x3f, 0xc5, 0x94, 0x08, 0xa6, 0xe8, 0x21, 0x1a,
	0xc3, 0x2f, 0x38, 0xcc, 0x99, 0xab, 0x01, 0x2f, 0x6c, 0x0e, 0xf8, 0xe6, 0x00, 0xaa, 0xf7, 0x04,
	0xf0, 0x9e, 0xf4, 0xa8, 0xdc, 0x97, 0x1e, 0xcf, 0xa1, 0x3c, 0xf1, 0x42, 0x6a, 0x89, 0xf8, 0xf2,
	0x0e, 0x95, 0x35, 0x81, 0x41, 0x23, 0x8e, 0xa0, 0x17, 0xa0, 0x72, 0x82, 0xe7, 0x4e, 0x66, 0xd8,
	0x76, 0x79, 0xa3, 0xc9, 0x9a, 0xfc, 0xd0, 0x40, 0x40, 0xac, 0xbc, 0x04, 0xe5, 0xea, 0x4a, 0x70,
	0x40, 0xf4, 0x4c, 0xce, 0x91, 0xd8, 0xb2, 0x68, 0xaa, 0xc9, 0xa2, 0x41, 0xa0, 0x9f, 0xdb, 0x21,
	0x65, 0xd1, 0x0a, 0xa3, 0x54, 0xfa, 0x25, 0x6c, 0x27, 0x30, 0x59, 0x4c, 0x1f, 0x41, 0x9e, 0xf5,
	0x87, 0xb0, 0xa6, 0x34, 0xb2, 0xfb, 0xe5, 0xa3, 0x9d, 0xb5, 0x40, 0x2f, 0x42, 0x53, 0x30, 0x8c,
	0x17, 0x50, 0x65, 0x60, 0xd7, 0xbd, 0xf2, 0xa2, 0x9e, 0xa3, 0xc5, 0xa5, 0xa8, 0xb2, 0xc4, 0x33,
	0x34, 0x50, 0xc7, 0x24, 0x70, 0xe2, 0x2b, 0x7f, 0x0f, 0xd5, 0xae, 0x2b, 0x11, 0x79, 0xe1, 0xf7,
	0xa1, 0xea, 0xd8, 0xae, 0x68, 0x4a, 0xd8, 0xf1, 0x16, 0x2e, 0x95, 0x01, 0xaf, 0x38, 0xb6, 0xcb,
	0xf4, 0xb7, 0x38, 0xc8, 0x79, 0x51, 0xf3, 0x92, 0xbc, 0x2d, 0xc9, 0x13, 0xfd, 0x4b, 0xf0, 0xce,
	0x72, 0x45, 0x45, 0xcf, 0x9c, 0xe5, 0x8a, 0x19, 0x3d, 0x7b, 0x96, 0x2b, 0x66, 0xf5, 0xdc, 0x59,
	0xae, 0x98, 0xd3, 0xf3, 0x67, 0xb9, 0x62, 0x41, 0x2f, 0x1a, 0x7f, 0x55, 0x40, 0x1f, 0x2c, 0xe8,
	0xff, 0xf5, 0x09, 0x7c, 0xb8, 0xd9, 0xae, 0x35, 0x99, 0xd3, 0x1b, 0x6b, 0x4a, 0xe6, 0x14, 0xf3,
	0x70, 0xe7, 0x4d, 0xd5, 0xb1, 0xdd, 0xf6, 0x9c, 0xde, 0x1c, 0x33, 0x2c, 0x1a, 0x81, 0x09, 0x56,
	0x49, 0xb2, 0xf0, 0x6d, 0xcc, 0xfa, 0x0e, 0x73, 0xfe, 0xa4, 0x80, 0xfa, 0xeb, 0x85, 0x47, 0xc9,
	0xfd, 0x4d, 0x9f, 0x27, 0xde, 0xb2, 0xd3, 0x66, 0xf8, 0x1d, 0x30, 0x59, 0x76, 0xd9, 0xb5, 0xa6,
	0x9d, 0xdd, 0xd0, 0xb4, 0x1f, 0x1c, 0x58, 0xb9, 0x07, 0x07, 0x96, 0xf1, 0x8d, 0xc2, 0xa2, 0x2e,
	0x9f, 0x29, 0x5d, 0xde, 0x00, 0x35, 0x1a, 0x43, 0x56, 0x88, 0xa3, 0x07, 0x43, 0x28, 0xe6, 0xd0,
	0x08, 0xf3, 0x4d, 0x85, 0x17, 0x18, 0xbf, 0x31, 0x9c, 0xc5, 0x4c, 0xb9, 0xa9, 0x30, 0xd9, 0x50,
	0x88, 0xe4, 0x81, 0xf7, 0x01, 0x12, 0xbe, 0xcc, 0x73, 0x3b, 0x4b, 0x93, 0x84, 0x23, 0x85, 0x0b,
	0x73, 0x7a, 0xde, 0xf8, 0x9b, 0xc8, 0x82, 0xff, 0xf6, 0x49, 0x1f, 0x82, 0xb6, 0x5c, 0x58, 0x38,
	0x47, 0x4c, 0x50, 0xd5, 0x8f, 0x36, 0x16, 0xc6, 0xfa, 0xa1, 0xec, 0x23, 0x62, 0x77, 0x48, 0x3f,
	0xbb, 0xca, 0x24, 0x23, 0x26, 0x90, 0x2a, 0xf9, 0x8e, 0xc1, 0xfc, 0x8a, 0xef, 0x1c, 0xe2, 0x52,
	0x8b, 0x2f, 0x6c, 0x62, 0xaa, 0x56, 0xb9, 0x3f, 0x05, 0x7e, 0xcc, 0x62, 0xfb, 0xb0, 0x81, 0x46,
	0x15, 0x2a, 0x63, 0xef, 0x2d, 0x71, 0xe3, 0x62, 0xfb, 0x05, 0x68, 0x11, 0x20, 0x4d, 0x3c, 0x80,
	0x2d, 0xca, 0x11, 0x59, 0xdd, 0xcb, 0x36, 0x7e, 0x1e, 0x62, 0xca, 0xc9, 0xa6, 0x64, 0x18, 0x7f,
	0xc9, 0x40, 0x29, 0x46, 0x59, 0x92, 0x5c, 0xe2, 0x90, 0x58, 0x0e, 0x9e, 0xe0, 0xc0, 0xf3, 0x5c,
	0x59, 0xe3, 0x2a, 0x03, 0x7b, 0x12, 0x63, 0x2d, 0x2c, 0xb2, 0x63, 0x86, 0xc3, 0x19, 0xf7, 0x8e,
	0x6a, 0x96, 0x25, 0x76, 0x8a, 0xc3, 0x19, 0xfa, 0x08, 0xf4, 0x88, 0xe2, 0x07, 0xc4, 0x76, 0xd8,
	0xe4, 0x13, 0xf3, 0xb9, 0x2a, 0xf1, 0xa1, 0x84, 0x59, 0x83, 0x17, 0x45, 0x66, 0xf9, 0xd8, 0x9e,
	0x5a, 0x0e, 0xf3, 0xa2, 0xd8, 0x39, 0x35, 0x81, 0x0f, 0xb1, 0x3d, 0xed, 0x85, 0x98, 0xa2, 0x4f,
	0xe0, 0x49, 0x62, 0x31, 0x4d, 0xd0, 0x45, 0x15, 0xa3, 0x20, 0xde, 0x4c, 0xe3, 0x23, 0x2f, 0x40,
	0x65, 0x13, 0xc3, 0x9a, 0x04, 0x04, 0x53, 0x32, 0x95, 0x75, 0x5c, 0x66, 0x58, 0x5b, 0x40, 0xa8,
	0x06, 0x05, 0x72, 0xeb, 0xdb, 0x01, 0x99, 0xf2, 0x89, 0x51, 0x34, 0xa3, 0x4f, 0x76, 0x38, 0xa4,
	0x5e, 0x80, 0xaf, 0x89, 0xe5, 0x62, 0x87, 0xf0, 0xea, 0x2e, 0x99, 0x65, 0x89, 0xf5, 0xb1, 0x43,
	0x8c, 0x63, 0x40, 0x91, 0x5b, 0x86, 0x24, 0x70, 0xec, 0x30, 0xb4, 0x3d, 0x17, 0xed, 0xc2, 0x16,
	0x71, 0xa9, 0x4d, 0xef, 0xc4, 0xb6, 0x62, 0xca, 0x2f, 0x86, 0xe3, 0x09, 0xab, 0x19, 0xb9, 0xab,
	0xcb, 0x2f, 0x83, 0xc2, 0xce, 0x6b, 0xfc, 0x36, 0x76, 0x70, 0x54, 0xe4, 0x9f, 0x41, 0xd9, 0x8f,
	0x95, 0x46, 0xb1, 0x7c, 0x2f, 0x8e, 0xe5, 0xfa, 0xc5, 0x66, 0x92, 0x8f, 0xbe, 0x07, 0xe5, 0xc0,
	0xf3, 0xa8, 0xf5, 0x96, 0xdc, 0x59, 0x72, 0x55, 0xc8, 0x99, 0x25, 0x06, 0xfd, 0x8a, 0xdc, 0x75,
	0xa7, 0xc6, 0x11, 0x3c, 0x4e, 0xdf, 0x2a, 0xb3, 0xa7, 0x0e, 0xc5, 0x54, 0xf8, 0x4b, 0x66, 0xfc,
	0x6d, 0x7c, 0x01, 0xbb, 0xeb, 0xd7, 0xb2, 0xe9, 0xf2, 0x3f, 0x3e, 0xd6, 0xa8, 0xc1, 0x2e, 0x53,
	0xb3, 0x14, 0xc7, 0xe9, 0xfd, 0x4f, 0x05, 0xf6, 0xd6, 0x44, 0xf2, 0xa9, 0x57, 0x80, 0x1c, 0x42,
	0x67, 0xde, 0xd4, 0x5a, 0xbf, 0xfb, 0xa7, 0xcb, 0xa4, 0xdf, 0x7c, 0xfa, 0xb0, 0xc7, 0x8f, 0x26,
	0x24, 0x1d, 0x97, 0x06, 0x77, 0xe6, 0xb6, 0xb3, 0x8a, 0xd7, 0x09, 0xec, 0x6e, 0x26, 0xb3, 0x46,
	0xfc, 0x96, 0x44, 0x71, 0x66, 0x7f, 0xa2, 0x9f, 0x40, 0xfe, 0x06, 0xcf, 0x17, 0x62, 0xed, 0x2e,
	0x1f, 0x3d, 0x7f, 0xc0, 0x05, 0xec, 0x61, 0xa6, 0x60, 0xbf, 0xca, 0xfc, 0x4c, 0x39, 0x78, 0x09,
	0xc5, 0x68, 0x1f, 0x43, 0x2a, 0x14, 0xcf, 0x07, 0x83, 0xa1, 0x35, 0xb8, 0x18, 0xeb, 0x8f, 0x50,
	0x19, 0x0a, 0xfc, 0xab, 0xdb, 0xd7, 0x95, 0x83, 0x10, 0x4a, 0xf1, 0x3a, 0x86, 0x2a, 0x50, 0xea,
	0xf6, 0xbb, 0xe3, 0x6e, 0x6b, 0xdc, 0x39, 0xd6, 0x1f, 0xa1, 0x27, 0xb0, 0x3d, 0x34, 0x3b, 0xdd,
	0x5e, 0xeb, 0xf3, 0x8e, 0x65, 0x76, 0xde, 0x74, 0x5a, 0xe7, 0x9d, 0x63, 0x5d, 0x41, 0x08, 0xb4,
	0xd3, 0xf1, 0x79, 0xdb, 0x1a, 0x5e, 0xbc, 0x3e, 0xef, 0x8e, 0x4e, 0x3b, 0xc7, 0x7a, 0x86, 0xe9,
	0x1c, 0x5d, 0xb4, 0xdb, 0x9d, 0xd1, 0x48, 0xcf, 0x22, 0x80, 0xad, 0x93, 0x56, 0x97, 0x91, 0x73,
	0x68, 0x07, 0xaa, 0xdd, 0xfe, 0x9b, 0x41, 0xb7, 0xdd, 0xb1, 0x46, 0x9d, 0xf1, 0x98, 0x81, 0xf9,
	0x83, 0x7f, 0x2b, 0x50, 0x49, 0x6d, 0x74, 0x68, 0x0f, 0x76, 0xd8, 0x91, 0x0b, 0x93, 0xdd, 0xd4,
	0x1a, 0x0d, 0xfa, 0x56, 0x7f, 0xd0, 0xef, 0xe8, 0x8f, 0xd0, 0x7b, 0xb0, 0xb7, 0x22, 0x18, 0x9c,
	0x9c, 0xb4, 0x4f, 0x5b, 0xec, 0xf1, 0xa8, 0x0e, 0xbb, 0x2b, 0xc2, 0x71, 0xb7, 0xd7, 0x61, 0x56,
	0x66, 0x50, 0x03, 0x9e, 0xad, 0xc8, 0x46, 0x5f, 0x74, 0x3a, 0xc3, 0x98, 0x91, 0x45, 0x2f, 0xe1,
	0xc5, 0x0a, 0xa3, 0xdb, 0x1f, 0x5d, 0x9c, 0x9c, 0x74, 0xdb, 0xdd, 0x4e, 0x7f, 0x6c, 0xbd, 0x69,
	0x9d, 0x5f, 0x74, 0xf4, 0x1c, 0x7a, 0x06, 0xb5, 0xd5, 0x4b, 0x3a, 0xbd, 0xe1, 0xc0, 0x6c, 0x99,
	0x5f, 0xea, 0x79, 0xf4, 0x01, 0x3c, 0x5f, 0x53, 0xd2, 0x1e, 0x98, 0x66, 0xa7, 0x3d, 0xb6, 0x5a,
	0xbd, 0xc1, 0x45, 0x7f, 0xac, 0x6f, 0x1d, 0x7d, 0x5b, 0x14, 0x0b, 0x78, 0x9b, 0xff, 0x6c, 0x47,
	0x26, 0x14, 0xe4, 0x0f, 0x71, 0xb4, 0xb7, 0x4c, 0xac, 0xd4, 0x4f, 0xf3, 0xfa, 0x93, 0xd4, 0x12,
	0x15, 0xa5, 0x99, 0xb1, 0xf7, 0x87, 0x6f, 0xff, 0xfe, 0xc7, 0xcc, 0xb6, 0xa1, 0x36, 0x6f, 0x3e,
	0x69, 0x32, 0x46, 0xd3, 0x5b, 0xd0, 0x57, 0xca, 0x01, 0x1a, 0xc0, 0x96, 0xf8, 0x29, 0x87, 0x76,
	0x53, 0x2a, 0xe3, 0xdf, 0x76, 0xf7, 0x69, 0xdc, 0xe5, 0x1a, 0x75, 0xa3, 0x1c, 0x6b, 0xb4, 0x5d,
	0xa6, 0xf0, 0xe7, 0x50, 0x90, 0x3f, 0x23, 0x12, 0x8f, 0x4c, 0xff, 0xb0, 0xa8, 0x6f, 0xda, 0xf4,
	0x7e, 0xac, 0xa0, 0xdf, 0x40, 0x29, 0x5e, 0x12, 0xd1, 0xd3, 0x54, 0xe9, 0x24, 0x97, 0xc9, 0x7a,
	0x7d, 0x93, 0x28, 0xfd, 0x2c, 0xa4, 0xc5, 0xcf, 0xe2, 0x0b, 0x24, 0xba, 0x10, 0x69, 0xcd, 0x16,
	0x48, 0x54, 0x4b, 0x5d, 0x9f, 0xd8, 0x29, 0x37, 0x3e, 0xcc, 0xa8, 0x73, 0x95, 0x8f, 0x11, 0x4a,
	0xa9, 0x6c, 0x7e, 0x6d, 0x4f, 0x7f, 0x87, 0x7e, 0x0b, 0xaa, 0x0c, 0x00, 0x5f, 0xf3, 0xd0, 0xd2,
	0x59, 0xc9, 0x5d, 0xb4, 0xbe, 0x34, 0x66, 0x75, 0x21, 0xdc, 0xa0, 0xdd, 0x5b, 0xd0, 0x26, 0xe5,
	0xda, 0x2e, 0x63, 0xed, 0x7c, 0x7d, 0x48, 0x68, 0x4f, 0x2e, 0x62, 0x69, 0xed, 0xa9, 0x45, 0xc3,
	0x68, 0x70, 0xed, 0x75, 0x54, 0x4b, 0x69, 0xff, 0x8a, 0x71, 0x9a, 0x5f, 0x63, 0x87, 0x32, 0x0b,
	0xb4, 0xcf, 0x09, 0x15, 0x21, 0x7f, 0xd0, 0x86, 0xa5, 0xd7, 0x56, 0xd6, 0x6a, 0xe3, 0x29, 0xbf,
	0x64, 0x07, 0x6d, 0x27, 0x52, 0x21, 0xb6, 0x60, 0xa9, 0xfd, 0x41, 0x1b, 0x92, 0xda, 0xd3, 0x26,
	0x3c, 0xe7, 0xda, 0x9f, 0xa2, 0xbd, 0xa4, 0xf6, 0xa4, 0x05, 0x5f, 0x42, 0x85, 0xdd, 0x11, 0xed,
	0x0f, 0x61, 0x22, 0x93, 0x53, 0x4b, 0x4a, 0x7d, 0x6f, 0x0d, 0x4f, 0x57, 0x07, 0xaa, 0xf2, 0x2b,
	0x42, 0x4c, 0x9b, 0x62, 0x31, 0x41, 0x53, 0x50, 0x93, 0xe3, 0x09, 0x3d, 0x8b, 0x35, 0x6c, 0x98,
	0x95, 0xf5, 0xf7, 0xef, 0x91, 0x6e, 0xaa, 0xc1, 0x68, 0x9a, 0xb1, 0x92, 0x71, 0xa0, 0xba, 0x32,
	0x1e, 0xd0, 0xf3, 0xfb, 0x07, 0x87, 0xb8, 0xab, 0xf1, 0x5d, 0x93, 0x25, 0x6d, 0x54, 0x62, 0x34,
	0x5d, 0x6e, 0xf1, 0xff, 0xeb, 0x7d, 0xfa, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x63, 0xf7, 0x2e,
	0x73, 0x0e, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SwapClientClient is the client API for SwapClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SwapClientClient interface {
	//* loop: `out`
	//LoopOut initiates an loop out swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream that is
	//returned from Monitor().
	LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	//* loop: `in`
	//LoopIn initiates a loop in swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream
	//that is returned from Monitor().
	LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	//* loop: `monitor`
	//Monitor will return a stream of swap updates for currently active swaps.
	Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (SwapClient_MonitorClient, error)
	//* loop: `listswaps`
	//ListSwaps returns a list of all currently known swaps and their current
	//status.
	ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsResponse, error)
	//* loop: `swapinfo`
	//SwapInfo returns all known details about a single swap.
	SwapInfo(ctx context.Context, in *SwapInfoRequest, opts ...grpc.CallOption) (*SwapStatus, error)
	//* loop: `terms`
	//LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*OutTermsResponse, error)
	//* loop: `quote`
	//LoopOutQuote returns a quote for a loop out swap with the provided
	//parameters.
	LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*OutQuoteResponse, error)
	//* loop: `terms`
	//GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*InTermsResponse, error)
	//* loop: `quote`
	//GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*InQuoteResponse, error)
	//* loop: `listauth`
	//GetLsatTokens returns all LSAT tokens the daemon ever paid for.
	GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error)
	// loop: `bakemacaroon`
	//BakeMacaroon allows the creation of a new macaroon with custom read and
	//write permissions. No first-party caveats are added since this can be done
	//offline.
	BakeMacaroon(ctx context.Context, in *BakeMacaroonRequest, opts ...grpc.CallOption) (*BakeMacaroonResponse, error)
	// loop: `listpermissions`
	//ListPermissions lists all RPC method URIs and their required macaroon
	//permissions to access them.
	ListPermissions(ctx context.Context, in *ListPermissionsRequest, opts ...grpc.CallOption) (*ListPermissionsResponse, error)
}

type swapClientClient struct {
	cc *grpc.ClientConn
}

func NewSwapClientClient(cc *grpc.ClientConn) SwapClientClient {
	return &swapClientClient{cc}
}

func (c *swapClientClient) LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (SwapClient_MonitorClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SwapClient_serviceDesc.Streams[0], "/looprpc.SwapClient/Monitor", opts...)
	if err != nil {
		return nil, err
	}
	x := &swapClientMonitorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SwapClient_MonitorClient interface {
	Recv() (*SwapStatus, error)
	grpc.ClientStream
}

type swapClientMonitorClient struct {
	grpc.ClientStream
}

func (x *swapClientMonitorClient) Recv() (*SwapStatus, error) {
	m := new(SwapStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *swapClientClient) ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsResponse, error) {
	out := new(ListSwapsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/ListSwaps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) SwapInfo(ctx context.Context, in *SwapInfoRequest, opts ...grpc.CallOption) (*SwapStatus, error) {
	out := new(SwapStatus)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/SwapInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*OutTermsResponse, error) {
	out := new(OutTermsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOutTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*OutQuoteResponse, error) {
	out := new(OutQuoteResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOutQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*InTermsResponse, error) {
	out := new(InTermsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLoopInTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*InQuoteResponse, error) {
	out := new(InQuoteResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLoopInQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error) {
	out := new(TokensResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLsatTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) BakeMacaroon(ctx context.Context, in *BakeMacaroonRequest, opts ...grpc.CallOption) (*BakeMacaroonResponse, error) {
	out := new(BakeMacaroonResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/BakeMacaroon", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) ListPermissions(ctx context.Context, in *ListPermissionsRequest, opts ...grpc.CallOption) (*ListPermissionsResponse, error) {
	out := new(ListPermissionsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/ListPermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwapClientServer is the server API for SwapClient service.
type SwapClientServer interface {
	//* loop: `out`
	//LoopOut initiates an loop out swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream that is
	//returned from Monitor().
	LoopOut(context.Context, *LoopOutRequest) (*SwapResponse, error)
	//* loop: `in`
	//LoopIn initiates a loop in swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream
	//that is returned from Monitor().
	LoopIn(context.Context, *LoopInRequest) (*SwapResponse, error)
	//* loop: `monitor`
	//Monitor will return a stream of swap updates for currently active swaps.
	Monitor(*MonitorRequest, SwapClient_MonitorServer) error
	//* loop: `listswaps`
	//ListSwaps returns a list of all currently known swaps and their current
	//status.
	ListSwaps(context.Context, *ListSwapsRequest) (*ListSwapsResponse, error)
	//* loop: `swapinfo`
	//SwapInfo returns all known details about a single swap.
	SwapInfo(context.Context, *SwapInfoRequest) (*SwapStatus, error)
	//* loop: `terms`
	//LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(context.Context, *TermsRequest) (*OutTermsResponse, error)
	//* loop: `quote`
	//LoopOutQuote returns a quote for a loop out swap with the provided
	//parameters.
	LoopOutQuote(context.Context, *QuoteRequest) (*OutQuoteResponse, error)
	//* loop: `terms`
	//GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(context.Context, *TermsRequest) (*InTermsResponse, error)
	//* loop: `quote`
	//GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(context.Context, *QuoteRequest) (*InQuoteResponse, error)
	//* loop: `listauth`
	//GetLsatTokens returns all LSAT tokens the daemon ever paid for.
	GetLsatTokens(context.Context, *TokensRequest) (*TokensResponse, error)
	// loop: `bakemacaroon`
	//BakeMacaroon allows the creation of a new macaroon with custom read and
	//write permissions. No first-party caveats are added since this can be done
	//offline.
	BakeMacaroon(context.Context, *BakeMacaroonRequest) (*BakeMacaroonResponse, error)
	// loop: `listpermissions`
	//ListPermissions lists all RPC method URIs and their required macaroon
	//permissions to access them.
	ListPermissions(context.Context, *ListPermissionsRequest) (*ListPermissionsResponse, error)
}

// UnimplementedSwapClientServer can be embedded to have forward compatible implementations.
type UnimplementedSwapClientServer struct {
}

func (*UnimplementedSwapClientServer) LoopOut(ctx context.Context, req *LoopOutRequest) (*SwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOut not implemented")
}
func (*UnimplementedSwapClientServer) LoopIn(ctx context.Context, req *LoopInRequest) (*SwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopIn not implemented")
}
func (*UnimplementedSwapClientServer) Monitor(req *MonitorRequest, srv SwapClient_MonitorServer) error {
	return status.Errorf(codes.Unimplemented, "method Monitor not implemented")
}
func (*UnimplementedSwapClientServer) ListSwaps(ctx context.Context, req *ListSwapsRequest) (*ListSwapsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSwaps not implemented")
}
func (*UnimplementedSwapClientServer) SwapInfo(ctx context.Context, req *SwapInfoRequest) (*SwapStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapInfo not implemented")
}
func (*UnimplementedSwapClientServer) LoopOutTerms(ctx context.Context, req *TermsRequest) (*OutTermsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOutTerms not implemented")
}
func (*UnimplementedSwapClientServer) LoopOutQuote(ctx context.Context, req *QuoteRequest) (*OutQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOutQuote not implemented")
}
func (*UnimplementedSwapClientServer) GetLoopInTerms(ctx context.Context, req *TermsRequest) (*InTermsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLoopInTerms not implemented")
}
func (*UnimplementedSwapClientServer) GetLoopInQuote(ctx context.Context, req *QuoteRequest) (*InQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLoopInQuote not implemented")
}
func (*UnimplementedSwapClientServer) GetLsatTokens(ctx context.Context, req *TokensRequest) (*TokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLsatTokens not implemented")
}
func (*UnimplementedSwapClientServer) BakeMacaroon(ctx context.Context, req *BakeMacaroonRequest) (*BakeMacaroonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BakeMacaroon not implemented")
}
func (*UnimplementedSwapClientServer) ListPermissions(ctx context.Context, req *ListPermissionsRequest) (*ListPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPermissions not implemented")
}

func RegisterSwapClientServer(s *grpc.Server, srv SwapClientServer) {
	s.RegisterService(&_SwapClient_serviceDesc, srv)
}

func _SwapClient_LoopOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOut(ctx, req.(*LoopOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopIn(ctx, req.(*LoopInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_Monitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapClientServer).Monitor(m, &swapClientMonitorServer{stream})
}

type SwapClient_MonitorServer interface {
	Send(*SwapStatus) error
	grpc.ServerStream
}

type swapClientMonitorServer struct {
	grpc.ServerStream
}

func (x *swapClientMonitorServer) Send(m *SwapStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _SwapClient_ListSwaps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListSwaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/ListSwaps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListSwaps(ctx, req.(*ListSwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_SwapInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).SwapInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/SwapInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).SwapInfo(ctx, req.(*SwapInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopOutTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOutTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopOutQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOutQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLoopInTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLoopInQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLsatTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLsatTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLsatTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLsatTokens(ctx, req.(*TokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_BakeMacaroon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BakeMacaroonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).BakeMacaroon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/BakeMacaroon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).BakeMacaroon(ctx, req.(*BakeMacaroonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_ListPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/ListPermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListPermissions(ctx, req.(*ListPermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SwapClient_serviceDesc = grpc.ServiceDesc{
	ServiceName: "looprpc.SwapClient",
	HandlerType: (*SwapClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoopOut",
			Handler:    _SwapClient_LoopOut_Handler,
		},
		{
			MethodName: "LoopIn",
			Handler:    _SwapClient_LoopIn_Handler,
		},
		{
			MethodName: "ListSwaps",
			Handler:    _SwapClient_ListSwaps_Handler,
		},
		{
			MethodName: "SwapInfo",
			Handler:    _SwapClient_SwapInfo_Handler,
		},
		{
			MethodName: "LoopOutTerms",
			Handler:    _SwapClient_LoopOutTerms_Handler,
		},
		{
			MethodName: "LoopOutQuote",
			Handler:    _SwapClient_LoopOutQuote_Handler,
		},
		{
			MethodName: "GetLoopInTerms",
			Handler:    _SwapClient_GetLoopInTerms_Handler,
		},
		{
			MethodName: "GetLoopInQuote",
			Handler:    _SwapClient_GetLoopInQuote_Handler,
		},
		{
			MethodName: "GetLsatTokens",
			Handler:    _SwapClient_GetLsatTokens_Handler,
		},
		{
			MethodName: "BakeMacaroon",
			Handler:    _SwapClient_BakeMacaroon_Handler,
		},
		{
			MethodName: "ListPermissions",
			Handler:    _SwapClient_ListPermissions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Monitor",
			Handler:       _SwapClient_Monitor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client.proto",
}

syntax = "proto3";

import "google/api/annotations.proto";

package looprpc;

/**
SwapClient is a service that handles the client side process of onchain/offchain
swaps. The service is designed for a single client.
*/
service SwapClient {
    /** loop: `out`
    LoopOut initiates an loop out swap with the given parameters. The call
    returns after the swap has been set up with the swap server. From that
    point onwards, progress can be tracked via the SwapStatus stream that is
    returned from Monitor().
    */
    rpc LoopOut (LoopOutRequest) returns (SwapResponse) {
        option (google.api.http) = {
            post: "/v1/loop/out"
            body: "*"
        };
    }

    /** loop: `in`
    LoopIn initiates a loop in swap with the given parameters. The call
    returns after the swap has been set up with the swap server. From that
    point onwards, progress can be tracked via the SwapStatus stream
    that is returned from Monitor().
    */
    rpc LoopIn (LoopInRequest) returns (SwapResponse) {
        option (google.api.http) = {
            post: "/v1/loop/in"
            body: "*"
        };
    }

    /** loop: `monitor`
    Monitor will return a stream of swap updates for currently active swaps.
    */
    rpc Monitor (MonitorRequest) returns (stream SwapStatus);

    /** loop: `listswaps`
    ListSwaps returns a list of all currently known swaps and their current
    status.
    */
    rpc ListSwaps (ListSwapsRequest) returns (ListSwapsResponse) {
        option (google.api.http) = {
            get: "/v1/loop/swaps"
        };
    }

    /** loop: `swapinfo`
    SwapInfo returns all known details about a single swap.
    */
    rpc SwapInfo (SwapInfoRequest) returns (SwapStatus) {
        option (google.api.http) = {
            get: "/v1/loop/swap/{id}"
        };
    }

    /** loop: `terms`
    LoopOutTerms returns the terms that the server enforces for a loop out swap.
    */
    rpc LoopOutTerms (TermsRequest) returns (OutTermsResponse) {
        option (google.api.http) = {
            get: "/v1/loop/out/terms"
        };
    }

    /** loop: `quote`
    LoopOutQuote returns a quote for a loop out swap with the provided
    parameters.
    */
    rpc LoopOutQuote (QuoteRequest) returns (OutQuoteResponse) {
        option (google.api.http) = {
            get: "/v1/loop/out/quote/{amt}"
        };
    }

    /** loop: `terms`
    GetTerms returns the terms that the server enforces for swaps.
    */
    rpc GetLoopInTerms (TermsRequest) returns (InTermsResponse) {
        option (google.api.http) = {
            get: "/v1/loop/in/terms"
        };
    }

    /** loop: `quote`
    GetQuote returns a quote for a swap with the provided parameters.
    */
    rpc GetLoopInQuote (QuoteRequest) returns (InQuoteResponse) {
        option (google.api.http) = {
            get: "/v1/loop/in/quote/{amt}"
        };
    }

    /** loop: `listauth`
    GetLsatTokens returns all LSAT tokens the daemon ever paid for.
    */
    rpc GetLsatTokens (TokensRequest) returns (TokensResponse) {
        option (google.api.http) = {
            get: "/v1/lsat/tokens"
        };
    }

    /* loop: `bakemacaroon`
    BakeMacaroon allows the creation of a new macaroon with custom read and
    write permissions. No first-party caveats are added since this can be done
    offline.
    */
    rpc BakeMacaroon (BakeMacaroonRequest) returns (BakeMacaroonResponse) {
        option (google.api.http) = {
            post: "/v1/macaroon"
            body: "*"
        };
    }

    /* loop: `listpermissions`
    ListPermissions lists all RPC method URIs and their required macaroon
    permissions to access them.
    */
    rpc ListPermissions (ListPermissionsRequest)
        returns (ListPermissionsResponse) {
        option (google.api.http) = {
            get: "/v1/permissions"
        };
    }
}

message LoopOutRequest {
    /**
    Requested swap amount in sat. This does not include the swap and miner fee.
    */
    int64 amt = 1;

    /**
    Base58 encoded destination address for the swap.
    */
    string dest = 2;

    /**
    Maximum off-chain fee in sat that may be paid for swap payment to the server.
    This limit is applied during path finding. Typically this value is taken
    from the response of the GetQuote call.
    */
    int64 max_swap_routing_fee = 3;

    /**
    Maximum off-chain fee in sat that may be paid for the prepay to the server.
    This limit is applied during path finding. Typically this value is taken
    from the response of the GetQuote call.
    */
    int64 max_prepay_routing_fee = 4;

    /**
    Maximum we are willing to pay the server for the swap. This value is not
    disclosed in the swap initiation call, but if the server asks for a
    higher fee, we abort the swap. Typically this value is taken from the
    response of the GetQuote call. It includes the prepay amount.
    */
    int64 max_swap_fee = 5;

    /**
    Maximum amount of the swap fee that may be charged as a prepayment.
    */
    int64 max_prepay_amt = 6;

    /**
    Maximum in on-chain fees that we are willing to spend. If we want to
    sweep the on-chain htlc and the fee estimate turns out higher than this
    value, we cancel the swap. If the fee estimate is lower, we publish the
    sweep tx.

    If the sweep tx is not confirmed, we are forced to ratchet up fees until it
    is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
    timeout. Because the initial publication revealed the preimage, we have no
    other choice. The server may already have pulled the off-chain htlc. Only
    when the fee becomes higher than the swap amount, we can only wait for fees
    to come down and hope - if we are past the timeout - that the server is not
    publishing the revocation.

    max_miner_fee is typically taken from the response of the GetQuote call.
    */
    int64 max_miner_fee = 7;

    /**
    Deprecated, use outgoing_chan_set. The channel to loop out, the channel
    to loop out is selected based on the lowest routing fee for the swap
    payment to the server.
    */
    uint64 loop_out_channel = 8 [deprecated = true];

    /**
    A restriction on the channel set that may be used to loop out. The actual
    channel(s) that will be used are selected based on the lowest routing fee
    for the swap payment to the server.
    */
    repeated uint64 outgoing_chan_set = 11;

    /**
    The number of blocks from the on-chain HTLC's confirmation height that it
    should be swept within.
    */
    int32 sweep_conf_target = 9;

    /*
    The number of confirmations that we require for the on chain htlc that will
    be published by the server before we reveal the preimage.
    */
    int32 htlc_confirmations = 13;

    /**
    The latest time (in unix seconds) we allow the server to wait before
    publishing the HTLC on chain. Setting this to a larger value will give the
    server the opportunity to batch multiple swaps together, and wait for
    low-fee periods before publishing the HTLC, potentially resulting in a
    lower total swap fee.
    */
    uint64 swap_publication_deadline = 10;

    /*
    An optional label for this swap. This field is limited to 500 characters
    and may not start with the prefix [reserved], which is used to tag labels
    produced by the daemon.
    */
    string label = 12;
}

message LoopInRequest {
    /**
    Requested swap amount in sat. This does not include the swap and miner 
    fee.
    */
    int64 amt = 1;

    /**
    Maximum we are willing to pay the server for the swap. This value is not
    disclosed in the swap initiation call, but if the server asks for a
    higher fee, we abort the swap. Typically this value is taken from the
    response of the GetQuote call.
    */
    int64 max_swap_fee = 2;

    /**
    Maximum in on-chain fees that we are willing to spend. If we want to
    publish the on-chain htlc and the fee estimate turns out higher than this
    value, we cancel the swap. 

    max_miner_fee is typically taken from the response of the GetQuote call.
    */
    int64 max_miner_fee = 3;

    /**
    The last hop to use for the loop in swap. If empty, the last hop is selected
    based on the lowest routing fee for the swap payment from the server.
    */
    bytes last_hop = 4;

    /**
    If external_htlc is true, we expect the htlc to be published by an external
    actor.
    */
    bool external_htlc = 5;

    /**
    The number of blocks that the on chain htlc should confirm within.
    */
    int32 htlc_conf_target = 6;

    /*
    An optional label for this swap. This field is limited to 500 characters
    and may not be one of the reserved values in loop/labels Reserved list.
    */
    string label = 7;
}

message SwapResponse {
    /**
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    DEPRECATED: To make the API more consistent, this field is deprecated in
    favor of id_bytes and will be removed in a future release.
    */
    string id = 1 [deprecated = true];

    /**
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    */
    bytes id_bytes = 3;

    /**
    DEPRECATED. This field stores the address of the onchain htlc, but
    depending on the request, the semantics are different.
    - For internal loop-in htlc_address contains the address of the
    native segwit (P2WSH) htlc.
    - For external loop-in htlc_address contains the address of the
    nested segwit (NP2WSH) htlc.
    - For loop-out htlc_address always contains the native segwit (P2WSH)
    htlc address.
    */
    string htlc_address = 2 [deprecated = true];

    /**
    The nested segwit address of the on-chain htlc.
    This field remains empty for loop-out.
    */
    string htlc_address_np2wsh = 4;

    /**
    The native segwit address of the on-chain htlc.
    Used for both loop-in and loop-out.
    */
    string htlc_address_p2wsh = 5;

    // A human-readable message received from the loop server.
    string server_message = 6;
}

message MonitorRequest {
}

message SwapStatus {
    /**
    Requested swap amount in sat. This does not include the swap and miner
    fee.
    */
    int64 amt = 1;

    /**
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    DEPRECATED: To make the API more consistent, this field is deprecated in
    favor of id_bytes and will be removed in a future release.
    */
    string id = 2 [deprecated = true];

    /**
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    */
    bytes id_bytes = 11;

    /**
    Swap type
    */
    SwapType type = 3;

    /**
    State the swap is currently in, see State enum.
    */
    SwapState state = 4;

    /*
    A failure reason for the swap, only set if the swap has failed.
    */
    FailureReason failure_reason = 14;

    /**
    Initiation time of the swap.
    */
    int64 initiation_time = 5;

    /**
    Initiation time of the swap.
    */
    int64 last_update_time = 6;

    /**
    DEPRECATED:  This field stores the address of the onchain htlc.
    - For internal loop-in htlc_address contains the address of the
    native segwit (P2WSH) htlc.
    - For external loop-in htlc_address contains the nested segwit (NP2WSH)
    address.
    - For loop-out htlc_address always contains the native segwit (P2WSH)
    htlc address.
    */
    string htlc_address = 7 [deprecated = true];

    // HTLC address (native segwit), used in loop-in and loop-out swaps.
    string htlc_address_p2wsh = 12;

    // HTLC address (nested segwit), used in loop-in swaps only.
    string htlc_address_np2wsh = 13;

    /// Swap server cost
    int64 cost_server = 8;

    // On-chain transaction cost
    int64 cost_onchain = 9;

    // Off-chain routing fees
    int64 cost_offchain = 10;

    // An optional label given to the swap on creation.
    string label = 15;
}

enum SwapType {
    // LOOP_OUT indicates an loop out swap (off-chain to on-chain)
    LOOP_OUT = 0;

    // LOOP_IN indicates a loop in swap (on-chain to off-chain)
    LOOP_IN = 1;
}

enum SwapState {
    /**
    INITIATED is the initial state of a swap. At that point, the initiation
    call to the server has been made and the payment process has been started
    for the swap and prepayment invoices.
    */
    INITIATED = 0;

    /**
    PREIMAGE_REVEALED is reached when the sweep tx publication is first
    attempted. From that point on, we should consider the preimage to no
    longer be secret and we need to do all we can to get the sweep confirmed.
    This state will mostly coalesce with StateHtlcConfirmed, except in the
    case where we wait for fees to come down before we sweep.
    */
    PREIMAGE_REVEALED = 1;

    /**
    HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in
    swap.
    */
    HTLC_PUBLISHED = 2;

    /**
    SUCCESS is the final swap state that is reached when the sweep tx has
    the required confirmation depth.
    */
    SUCCESS = 3;

    /**
    FAILED is the final swap state for a failed swap with or without loss of
    the swap amount.
    */
    FAILED = 4;

    /**
    INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been
    paid, but we are still waiting for the htlc spend to confirm.
    */
    INVOICE_SETTLED = 5;
}

enum FailureReason {
    /*
    FAILURE_REASON_NONE is set when the swap did not fail, it is either in
    progress or succeeded.
    */
    FAILURE_REASON_NONE = 0;

    /*
    FAILURE_REASON_OFFCHAIN indicates that a loop out failed because it wasn't
    possible to find a route for one or both off chain payments that met the fee
    and timelock limits required.
    */
    FAILURE_REASON_OFFCHAIN = 1;

    /*
    FAILURE_REASON_TIMEOUT indicates that the swap failed because on chain htlc
    did not confirm before its expiry, or it confirmed too late for us to reveal
    our preimage and claim.
    */
    FAILURE_REASON_TIMEOUT = 2;

    /*
    FAILURE_REASON_SWEEP_TIMEOUT indicates that a loop out permanently failed
    because the on chain htlc wasn't swept before the server revoked the
    htlc.
    */
    FAILURE_REASON_SWEEP_TIMEOUT = 3;

    /*
    FAILURE_REASON_INSUFFICIENT_VALUE indicates that a loop out has failed
    because the on chain htlc had a lower value than requested.
    */
    FAILURE_REASON_INSUFFICIENT_VALUE = 4;

    /*
    FAILURE_REASON_TEMPORARY indicates that a swap cannot continue due to an
    internal error. Manual intervention such as a restart is required.
    */
    FAILURE_REASON_TEMPORARY = 5;

    /*
    FAILURE_REASON_INCORRECT_AMOUNT indicates that a loop in permanently failed
    because the amount extended by an external loop in htlc is insufficient.
    */
    FAILURE_REASON_INCORRECT_AMOUNT = 6;
}

message ListSwapsRequest {
}

message ListSwapsResponse {
    /**
    The list of all currently known swaps and their status.
    */
    repeated SwapStatus swaps = 1;
}

message SwapInfoRequest {
    /**
    The swap identifier which currently is the hash that locks the HTLCs. When
    using REST, this field must be encoded as URL safe base64.
    */
    bytes id = 1;
}

message TermsRequest {
}

message InTermsResponse {

    reserved 1, 2, 3, 4, 7;

    /**
    Minimum swap amount (sat)
    */
    int64 min_swap_amount = 5;

    /**
    Maximum swap amount (sat)
    */
    int64 max_swap_amount = 6;
}

message OutTermsResponse {

    reserved 1, 2, 3, 4, 7;

    /**
    Minimum swap amount (sat)
    */
    int64 min_swap_amount = 5;

    /**
    Maximum swap amount (sat)
    */
    int64 max_swap_amount = 6;

    // The minimally accepted cltv delta of the on-chain htlc.
    int32 min_cltv_delta = 8;

    // The maximally accepted cltv delta of the on-chain htlc.
    int32 max_cltv_delta = 9;
}

message QuoteRequest {
    /**
    The amount to swap in satoshis.
    */
    int64 amt = 1;

    /**
    The confirmation target that should be used either for the sweep of the
    on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
    the confirmation of the on-chain HTLC broadcast by the swap client in the
    case of a Loop In.
    */
    int32 conf_target = 2;

    /**
    If external_htlc is true, we expect the htlc to be published by an external
    actor.
    */
    bool external_htlc = 3;

    /**
    The latest time (in unix seconds) we allow the server to wait before
    publishing the HTLC on chain. Setting this to a larger value will give the
    server the opportunity to batch multiple swaps together, and wait for
    low-fee periods before publishing the HTLC, potentially resulting in a
    lower total swap fee. This only has an effect on loop out quotes.
    */
    uint64 swap_publication_deadline = 4;
}

message InQuoteResponse {
    reserved 2, 4;

    /**
    The fee that the swap server is charging for the swap.
    */
    int64 swap_fee_sat = 1;

    /*
    An estimate of the on-chain fee that needs to be paid to publish the HTLC
    If a miner fee of 0 is returned, it means the external_htlc flag was set for
    a loop in and the fee estimation was skipped. If a miner fee of -1 is
    returned, it means lnd's wallet tried to estimate the fee but was unable to
    create a sample estimation transaction because not enough funds are
    available. An information message should be shown to the user in this case.
    */
    int64 htlc_publish_fee_sat = 3;

    /**
    On-chain cltv expiry delta
    */
    int32 cltv_delta = 5;
}

message OutQuoteResponse {
    /**
    The fee that the swap server is charging for the swap.
    */
    int64 swap_fee_sat = 1;

    /**
    The part of the swap fee that is requested as a prepayment.
    */
    int64 prepay_amt_sat = 2;

    /**
    An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
    a loop out.
    */
    int64 htlc_sweep_fee_sat = 3;

    /**
    The node pubkey where the swap payment needs to be paid
    to. This can be used to test connectivity before initiating the swap.
    */
    bytes swap_payment_dest = 4;

    /**
    On-chain cltv expiry delta
    */
    int32 cltv_delta = 5;
}

message TokensRequest {
}

message TokensResponse {
    /**
    List of all tokens the daemon knows of, including old/expired tokens.
    */
    repeated LsatToken tokens = 1;
}

message LsatToken {
    /**
    The base macaroon that was baked by the auth server.
    */
    bytes base_macaroon = 1;

    /**
    The payment hash of the payment that was paid to obtain the token.
    */
    bytes payment_hash = 2;

    /**
    The preimage of the payment hash, knowledge of this is proof that the
    payment has been paid. If the preimage is set to all zeros, this means the
    payment is still pending and the token is not yet fully valid.
    */
    bytes payment_preimage = 3;

    /**
    The amount of millisatoshis that was paid to get the token.
    */
    int64 amount_paid_msat = 4;

    /**
    The amount of millisatoshis paid in routing fee to pay for the token.
    */
    int64 routing_fee_paid_msat = 5;

    /**
    The creation time of the token as UNIX timestamp in seconds.
    */
    int64 time_created = 6;

    /**
    Indicates whether the token is expired or still valid.
    */
    bool expired = 7;

    /**
    Identifying attribute of this token in the store. Currently represents the
    file name of the token where it's stored on the file system.
    */
    string storage_name = 8;
}

message MacaroonPermission {
    // The entity a permission grants access to.
    string entity = 1;

    // The action that is granted.
    string action = 2;
}

message BakeMacaroonRequest {
    // The list of permissions the new macaroon should grant.
    repeated MacaroonPermission permissions = 1;

    // The root key ID used to create the macaroon, must be a positive integer.
    uint64 root_key_id = 2;
}

message BakeMacaroonResponse {
    // The hex encoded macaroon, serialized in binary format.
    string macaroon = 1;
}

message MacaroonPermissionList {
    // A list of macaroon permissions.
    repeated MacaroonPermission permissions = 1;
}

message ListPermissionsRequest {
}

message ListPermissionsResponse {
    /*
    A map between all RPC method URIs and their required macaroon permissions to
    access them.
    */
    map<string, MacaroonPermissionList> method_permissions = 1;
}
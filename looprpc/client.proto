syntax = "proto3";

import "swapserverrpc/common.proto";

package looprpc;

option go_package = "github.com/lightninglabs/loop/looprpc";

/*
SwapClient is a service that handles the client side process of onchain/offchain
swaps. The service is designed for a single client.
*/
service SwapClient {
    /* loop: `out`
    LoopOut initiates an loop out swap with the given parameters. The call
    returns after the swap has been set up with the swap server. From that
    point onwards, progress can be tracked via the SwapStatus stream that is
    returned from Monitor().
    */
    rpc LoopOut (LoopOutRequest) returns (SwapResponse);

    /* loop: `in`
    LoopIn initiates a loop in swap with the given parameters. The call
    returns after the swap has been set up with the swap server. From that
    point onwards, progress can be tracked via the SwapStatus stream
    that is returned from Monitor().
    */
    rpc LoopIn (LoopInRequest) returns (SwapResponse);

    /* loop: `monitor`
    Monitor will return a stream of swap updates for currently active swaps.
    */
    rpc Monitor (MonitorRequest) returns (stream SwapStatus);

    /* loop: `listswaps`
    ListSwaps returns a list of all currently known swaps and their current
    status.
    */
    rpc ListSwaps (ListSwapsRequest) returns (ListSwapsResponse);

    /* loop: `swapinfo`
    SwapInfo returns all known details about a single swap.
    */
    rpc SwapInfo (SwapInfoRequest) returns (SwapStatus);

    /* loop: `abandonswap`
    AbandonSwap allows the client to abandon a swap.
    */
    rpc AbandonSwap (AbandonSwapRequest) returns (AbandonSwapResponse);

    /* loop: `terms`
    LoopOutTerms returns the terms that the server enforces for a loop out swap.
    */
    rpc LoopOutTerms (TermsRequest) returns (OutTermsResponse);

    /* loop: `quote`
    LoopOutQuote returns a quote for a loop out swap with the provided
    parameters.
    */
    rpc LoopOutQuote (QuoteRequest) returns (OutQuoteResponse);

    /* loop: `terms`
    GetTerms returns the terms that the server enforces for swaps.
    */
    rpc GetLoopInTerms (TermsRequest) returns (InTermsResponse);

    /* loop: `quote`
    GetQuote returns a quote for a swap with the provided parameters.
    */
    rpc GetLoopInQuote (QuoteRequest) returns (InQuoteResponse);

    /*
    Probe asks he sever to probe the route to us to have a better upfront
    estimate about routing fees when loopin-in.
    */
    rpc Probe (ProbeRequest) returns (ProbeResponse);

    /* loop: `listauth`
    GetL402Tokens returns all L402 tokens the daemon ever paid for.
    */
    rpc GetL402Tokens (TokensRequest) returns (TokensResponse);

    /*
    Deprecated: use GetL402Tokens.
    This API is provided to maintain backward compatibility with gRPC clients
    (e.g. `loop listauth`, Terminal Web, RTL).
    Type LsatToken used by GetLsatTokens in the past was renamed to L402Token,
    but this does not affect binary encoding, so we can use type L402Token here.
    */
    rpc GetLsatTokens (TokensRequest) returns (TokensResponse);

    /* loop: `fetchl402`
    FetchL402Token fetches an L402 token from the server, this is required in
    order to receive reservation notifications from the server.
    */
    rpc FetchL402Token (FetchL402TokenRequest) returns (FetchL402TokenResponse);

    /* loop: `getinfo`
    GetInfo gets basic information about the loop daemon.
    */
    rpc GetInfo (GetInfoRequest) returns (GetInfoResponse);

    /* loop: `getparams`
    GetLiquidityParams gets the parameters that the daemon's liquidity manager
    is currently configured with. This may be nil if nothing is configured.
    [EXPERIMENTAL]: endpoint is subject to change.
    */
    rpc GetLiquidityParams (GetLiquidityParamsRequest)
        returns (LiquidityParameters);

    /* loop: `setparams`
    SetLiquidityParams sets a new set of parameters for the daemon's liquidity
    manager. Note that the full set of parameters must be provided, because
    this call fully overwrites our existing parameters.
    [EXPERIMENTAL]: endpoint is subject to change.
    */
    rpc SetLiquidityParams (SetLiquidityParamsRequest)
        returns (SetLiquidityParamsResponse);

    /* loop: `suggestswaps`
    SuggestSwaps returns a list of recommended swaps based on the current
    state of your node's channels and it's liquidity manager parameters.
    Note that only loop out suggestions are currently supported.
    [EXPERIMENTAL]: endpoint is subject to change.
    */
    rpc SuggestSwaps (SuggestSwapsRequest) returns (SuggestSwapsResponse);

    /* loop: `listreservations`
    ListReservations returns a list of all reservations the server opened to us.
    */
    rpc ListReservations (ListReservationsRequest)
        returns (ListReservationsResponse);

    /* loop: `instantout`
    InstantOut initiates an instant out swap with the given parameters.
    */
    rpc InstantOut (InstantOutRequest) returns (InstantOutResponse);

    /* loop: `instantoutquote`
    InstantOutQuote returns a quote for an instant out swap with the provided
    parameters.
    */
    rpc InstantOutQuote (InstantOutQuoteRequest)
        returns (InstantOutQuoteResponse);

    /* loop: `listinstantouts`
    ListInstantOuts returns a list of all currently known instant out swaps and
    their current status.
    */
    rpc ListInstantOuts (ListInstantOutsRequest)
        returns (ListInstantOutsResponse);

    /* loop: `static newstaticaddress`
    NewStaticAddress requests a new static address for loop-ins from the server.
    */
    rpc NewStaticAddress (NewStaticAddressRequest)
        returns (NewStaticAddressResponse);

    /* loop: `static listunspentdeposits`
    ListUnspentDeposits returns a list of utxos deposited at a static address.
    */
    rpc ListUnspentDeposits (ListUnspentDepositsRequest)
        returns (ListUnspentDepositsResponse);

    /* loop:`static withdraw`
    WithdrawDeposits withdraws a selection or all deposits of a static address.
     */
    rpc WithdrawDeposits (WithdrawDepositsRequest)
        returns (WithdrawDepositsResponse);

    /* loop:`listdeposits`
    ListStaticAddressDeposits returns a list of filtered static address
    deposits.
    */
    rpc ListStaticAddressDeposits (ListStaticAddressDepositsRequest)
        returns (ListStaticAddressDepositsResponse);

    /* loop:`listwithdrawals`
    ListStaticAddressWithdrawals returns a list of static address withdrawals.
    */
    rpc ListStaticAddressWithdrawals (ListStaticAddressWithdrawalRequest)
        returns (ListStaticAddressWithdrawalResponse);

    /* loop:`listswaps`
    ListStaticAddressSwaps returns a list of filtered static address
    swaps.
    */
    rpc ListStaticAddressSwaps (ListStaticAddressSwapsRequest)
        returns (ListStaticAddressSwapsResponse);

    /* loop:`static summary`
    GetStaticAddressSummary returns a summary of static address related
    statistics.
    */
    rpc GetStaticAddressSummary (StaticAddressSummaryRequest)
        returns (StaticAddressSummaryResponse);

    /* loop:`in`
    StaticAddressLoopIn initiates a static address loop-in swap.
    */
    rpc StaticAddressLoopIn (StaticAddressLoopInRequest)
        returns (StaticAddressLoopInResponse);

    /* loop:`openchannel`
    StaticOpenChannel opens a channel funded by selected static address
    deposits.
    */
    rpc StaticOpenChannel (OpenChannelRequest)
        returns (StaticOpenChannelResponse);
}

message StaticOpenChannelResponse {
    /*
    The transaction hash of the channel opening transaction.
    */
    string channel_open_tx_hash = 1;

    /*
    An optional error string.
    */
    string error = 2;
};

message LoopOutRequest {
    /*
    Requested swap amount in sat. This does not include the swap and miner fee.
    */
    int64 amt = 1;

    /*
    Base58 encoded destination address for the swap.
    */
    string dest = 2;

    /*
    Maximum off-chain fee in sat that may be paid for swap payment to the
    server. This limit is applied during path finding. Typically this value is
    taken from the response of the GetQuote call.
    */
    int64 max_swap_routing_fee = 3;

    /*
    Maximum off-chain fee in sat that may be paid for the prepay to the server.
    This limit is applied during path finding. Typically this value is taken
    from the response of the GetQuote call.
    */
    int64 max_prepay_routing_fee = 4;

    /*
    Maximum we are willing to pay the server for the swap. This value is not
    disclosed in the swap initiation call, but if the server asks for a
    higher fee, we abort the swap. Typically this value is taken from the
    response of the GetQuote call. It includes the prepay amount.
    */
    int64 max_swap_fee = 5;

    /*
    Maximum amount of the swap fee that may be charged as a prepayment.
    */
    int64 max_prepay_amt = 6;

    /*
    Maximum in on-chain fees that we are willing to spend. If we want to
    sweep the on-chain htlc and the fee estimate turns out higher than this
    value, we cancel the swap. If the fee estimate is lower, we publish the
    sweep tx.

    If the sweep tx is not confirmed, we are forced to ratchet up fees until it
    is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
    timeout. Because the initial publication revealed the preimage, we have no
    other choice. The server may already have pulled the off-chain htlc. Only
    when the fee becomes higher than the swap amount, we can only wait for fees
    to come down and hope - if we are past the timeout - that the server is not
    publishing the revocation.

    max_miner_fee is typically taken from the response of the GetQuote call.
    */
    int64 max_miner_fee = 7;

    /*
    Deprecated, use outgoing_chan_set. The channel to loop out, the channel
    to loop out is selected based on the lowest routing fee for the swap
    payment to the server.
    */
    uint64 loop_out_channel = 8 [deprecated = true];

    /*
    A restriction on the channel set that may be used to loop out. The actual
    channel(s) that will be used are selected based on the lowest routing fee
    for the swap payment to the server.
    */
    repeated uint64 outgoing_chan_set = 11;

    /*
    The number of blocks from the on-chain HTLC's confirmation height that it
    should be swept within.
    */
    int32 sweep_conf_target = 9;

    /*
    The number of confirmations that we require for the on chain htlc that will
    be published by the server before we reveal the preimage.
    */
    int32 htlc_confirmations = 13;

    /*
    The latest time (in unix seconds) we allow the server to wait before
    publishing the HTLC on chain. Setting this to a larger value will give the
    server the opportunity to batch multiple swaps together, and wait for
    low-fee periods before publishing the HTLC, potentially resulting in a
    lower total swap fee.
    */
    uint64 swap_publication_deadline = 10;

    /*
    An optional label for this swap. This field is limited to 500 characters
    and may not start with the prefix [reserved], which is used to tag labels
    produced by the daemon.
    */
    string label = 12;

    /*
    An optional identification string that will be appended to the user agent
    string sent to the server to give information about the usage of loop. This
    initiator part is meant for user interfaces to add their name to give the
    full picture of the binary used (loopd, LiT) and the method used for
    triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
    */
    string initiator = 14;

    /*
    An alternative destination address source for the swap. This field
    represents the name of the account in the backing lnd instance.
    Refer to lnd's wallet import functions for reference.
     */
    string account = 15;

    /*
    The address type of the account specified in the account field.
     */
    AddressType account_addr_type = 16;

    /*
    A flag indicating whether the defined destination address does not belong to
    the wallet. This is used to flag whether this loop out swap could have its
    associated sweep batched.
    */
    bool is_external_addr = 17;

    /*
    The reservations to use for the swap. If this field is set, loop will try
    to use the instant out flow using the given reservations. If the
    reservations are not sufficient, the swap will fail. The swap amount must
    be equal to the sum of the amounts of the reservations.
    */
    repeated bytes reservation_ids = 18;

    /*
    The timeout in seconds to use for off-chain payments. Note that the swap
    payment is attempted multiple times where each attempt will set this value
    as the timeout for the payment.
    */
    uint32 payment_timeout = 19;

    /*
    The optional asset information to use for the swap. If set, the swap will
    be paid in the specified asset using the provided edge node. An Asset client
    must be connected to the loop client to use this feature.
    */
    AssetLoopOutRequest asset_info = 20;

    /*
    The optional RFQ information to use for the swap. If set, the swap will
    use the provided RFQs to pay for the swap invoice.
    */
    AssetRfqInfo asset_rfq_info = 21;
}

/*
`AddressType` has to be one of:

- `unknown`: Unknown address type
- `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 1)
*/
enum AddressType {
    ADDRESS_TYPE_UNKNOWN = 0;
    TAPROOT_PUBKEY = 1;
}

message LoopInRequest {
    /*
    Requested swap amount in sat. This does not include the swap and miner
    fee.
    */
    int64 amt = 1;

    /*
    Maximum we are willing to pay the server for the swap. This value is not
    disclosed in the swap initiation call, but if the server asks for a
    higher fee, we abort the swap. Typically this value is taken from the
    response of the GetQuote call.
    */
    int64 max_swap_fee = 2;

    /*
    Maximum in on-chain fees that we are willing to spend. If we want to
    publish the on-chain htlc and the fee estimate turns out higher than this
    value, we cancel the swap.

    max_miner_fee is typically taken from the response of the GetQuote call.
    */
    int64 max_miner_fee = 3;

    /*
    The last hop to use for the loop in swap. If empty, the last hop is selected
    based on the lowest routing fee for the swap payment from the server.
    */
    bytes last_hop = 4;

    /*
    If external_htlc is true, we expect the htlc to be published by an external
    actor.
    */
    bool external_htlc = 5;

    /*
    The number of blocks that the on chain htlc should confirm within.
    */
    int32 htlc_conf_target = 6;

    /*
    An optional label for this swap. This field is limited to 500 characters
    and may not be one of the reserved values in loop/labels Reserved list.
    */
    string label = 7;

    /*
    An optional identification string that will be appended to the user agent
    string sent to the server to give information about the usage of loop. This
    initiator part is meant for user interfaces to add their name to give the
    full picture of the binary used (loopd, LiT) and the method used for
    triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
    */
    string initiator = 8;

    /*
    Optional route hints to reach the destination through private channels.
    */
    repeated looprpc.RouteHint route_hints = 9;

    /*
    Private indicates whether the destination node should be considered
    private. In which case, loop will generate hophints to assist with
    probing and payment.
    */
    bool private = 10;
}

message SwapResponse {
    /*
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    DEPRECATED: To make the API more consistent, this field is deprecated in
    favor of id_bytes and will be removed in a future release.
    */
    string id = 1 [deprecated = true];

    /*
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    */
    bytes id_bytes = 3;

    /*
    DEPRECATED. This field stores the address of the onchain htlc, but
    depending on the request, the semantics are different.
    - For internal loop-in htlc_address contains the address of the
    native segwit (P2WSH) htlc.
/    - For loop-out htlc_address always contains the native segwit (P2WSH)
    htlc address.
    */
    string htlc_address = 2 [deprecated = true];

    reserved 4;

    /*
    The native segwit address of the on-chain htlc.
    Used for both loop-in and loop-out.
    */
    string htlc_address_p2wsh = 5;

    // The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
    string htlc_address_p2tr = 7;

    // A human-readable message received from the loop server.
    string server_message = 6;
}

message MonitorRequest {
}

message SwapStatus {
    /*
    Requested swap amount in sat. This does not include the swap and miner
    fee.
    */
    int64 amt = 1;

    /*
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    DEPRECATED: To make the API more consistent, this field is deprecated in
    favor of id_bytes and will be removed in a future release.
    */
    string id = 2 [deprecated = true];

    /*
    Swap identifier to track status in the update stream that is returned from
    the Start() call. Currently this is the hash that locks the htlcs.
    */
    bytes id_bytes = 11;

    /*
    The type of the swap.
    */
    SwapType type = 3;

    /*
    State the swap is currently in, see State enum.
    */
    SwapState state = 4;

    /*
    A failure reason for the swap, only set if the swap has failed.
    */
    FailureReason failure_reason = 14;

    /*
    Initiation time of the swap.
    */
    int64 initiation_time = 5;

    /*
    Initiation time of the swap.
    */
    int64 last_update_time = 6;

    /*
    DEPRECATED:  This field stores the address of the onchain htlc.
    - For internal loop-in htlc_address contains the address of the
    native segwit (P2WSH) htlc.
    - For loop-out htlc_address always contains the native segwit (P2WSH)
    htlc address.
    */
    string htlc_address = 7 [deprecated = true];

    // HTLC address (native segwit), used in loop-in and loop-out swaps.
    string htlc_address_p2wsh = 12;

    // The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
    string htlc_address_p2tr = 18;

    // Swap server cost
    int64 cost_server = 8;

    // On-chain transaction cost
    int64 cost_onchain = 9;

    // Off-chain routing fees
    int64 cost_offchain = 10;

    // Optional last hop if provided in the loop in request.
    bytes last_hop = 16;

    // Optional outgoing channel set if provided in the loop out request.
    repeated uint64 outgoing_chan_set = 17;

    // An optional label given to the swap on creation.
    string label = 15;

    // If the swap was an asset swap, the asset information will be returned.
    AssetLoopOutInfo asset_info = 19;
}

enum SwapType {
    // LOOP_OUT indicates an loop out swap (off-chain to on-chain)
    LOOP_OUT = 0;

    // LOOP_IN indicates a loop in swap (on-chain to off-chain)
    LOOP_IN = 1;
}

enum SwapState {
    /*
    INITIATED is the initial state of a swap. At that point, the initiation
    call to the server has been made and the payment process has been started
    for the swap and prepayment invoices.
    */
    INITIATED = 0;

    /*
    PREIMAGE_REVEALED is reached when the sweep tx publication is first
    attempted. From that point on, we should consider the preimage to no
    longer be secret and we need to do all we can to get the sweep confirmed.
    This state will mostly coalesce with StateHtlcConfirmed, except in the
    case where we wait for fees to come down before we sweep.
    */
    PREIMAGE_REVEALED = 1;

    /*
    HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in
    swap.
    */
    HTLC_PUBLISHED = 2;

    /*
    SUCCESS is the final swap state that is reached when the sweep tx has
    the required confirmation depth.
    */
    SUCCESS = 3;

    /*
    FAILED is the final swap state for a failed swap with or without loss of
    the swap amount.
    */
    FAILED = 4;

    /*
    INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been
    paid, but we are still waiting for the htlc spend to confirm.
    */
    INVOICE_SETTLED = 5;
}

enum FailureReason {
    /*
    FAILURE_REASON_NONE is set when the swap did not fail, it is either in
    progress or succeeded.
    */
    FAILURE_REASON_NONE = 0;

    /*
    FAILURE_REASON_OFFCHAIN indicates that a loop out failed because it wasn't
    possible to find a route for one or both off chain payments that met the fee
    and timelock limits required.
    */
    FAILURE_REASON_OFFCHAIN = 1;

    /*
    FAILURE_REASON_TIMEOUT indicates that the swap failed because on chain htlc
    did not confirm before its expiry, or it confirmed too late for us to reveal
    our preimage and claim.
    */
    FAILURE_REASON_TIMEOUT = 2;

    /*
    FAILURE_REASON_SWEEP_TIMEOUT indicates that a loop out permanently failed
    because the on chain htlc wasn't swept before the server revoked the
    htlc.
    */
    FAILURE_REASON_SWEEP_TIMEOUT = 3;

    /*
    FAILURE_REASON_INSUFFICIENT_VALUE indicates that a loop out has failed
    because the on chain htlc had a lower value than requested.
    */
    FAILURE_REASON_INSUFFICIENT_VALUE = 4;

    /*
    FAILURE_REASON_TEMPORARY indicates that a swap cannot continue due to an
    internal error. Manual intervention such as a restart is required.
    */
    FAILURE_REASON_TEMPORARY = 5;

    /*
    FAILURE_REASON_INCORRECT_AMOUNT indicates that a loop in permanently failed
    because the amount extended by an external loop in htlc is insufficient.
    */
    FAILURE_REASON_INCORRECT_AMOUNT = 6;

    /*
    FAILURE_REASON_ABANDONED indicates that a swap permanently failed because
    the client manually abandoned the swap.
    */
    FAILURE_REASON_ABANDONED = 7;

    /*
    FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE indicates that a swap
    wasn't published due to insufficient confirmed balance.
    */
    FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE = 8;

    /*
    FAILURE_REASON_INCORRECT_HTLC_AMT_SWEPT indicates that a swap
    wasn't published due to insufficient confirmed balance.
    */
    FAILURE_REASON_INCORRECT_HTLC_AMT_SWEPT = 9;
}

message ListSwapsRequest {
    // Optional filter to only return swaps that match the filter.
    ListSwapsFilter list_swap_filter = 1;

    // Set a maximum number of swaps to return in the response.
    uint64 max_swaps = 2;
}

message ListSwapsFilter {
    enum SwapTypeFilter {
        // ANY indicates that no filter is applied.
        ANY = 0;
        // LOOP_OUT indicates an loop out swap (off-chain to on-chain).
        LOOP_OUT = 1;

        // LOOP_IN indicates a loop in swap (on-chain to off-chain).
        LOOP_IN = 2;
    }
    // The type of the swap.
    SwapTypeFilter swap_type = 1;

    // If set, only pending swaps are returned.
    bool pending_only = 2;

    // If specified on creation, the outgoing channel set of the swap.
    repeated uint64 outgoing_chan_set = 3;

    // Label of swap to filter for.
    string label = 4;

    // If specified on creation, the last hop of the swap.
    bytes loop_in_last_hop = 5;

    // If specified, only returns asset swaps.
    bool asset_swap_only = 6;

    // If specified, returns swaps initiated after this Unix (ns) timestamp.
    int64 start_timestamp_ns = 7;
}

message ListSwapsResponse {
    /*
    The list of all currently known swaps and their status.
    */
    repeated SwapStatus swaps = 1;

    // Timestamp to use for paging start_timestamp_ns.
    int64 next_start_time = 2;
}

message SwapInfoRequest {
    /*
    The swap identifier which currently is the hash that locks the HTLCs. When
    using REST, this field must be encoded as URL safe base64.
    */
    bytes id = 1;
}

message TermsRequest {
}

message InTermsResponse {
    reserved 1, 2, 3, 4, 7;

    /*
    Minimum swap amount (sat)
    */
    int64 min_swap_amount = 5;

    /*
    Maximum swap amount (sat)
    */
    int64 max_swap_amount = 6;
}

message OutTermsResponse {
    reserved 1, 2, 3, 4, 7;

    /*
    Minimum swap amount (sat)
    */
    int64 min_swap_amount = 5;

    /*
    Maximum swap amount (sat)
    */
    int64 max_swap_amount = 6;

    // The minimally accepted cltv delta of the on-chain htlc.
    int32 min_cltv_delta = 8;

    // The maximally accepted cltv delta of the on-chain htlc.
    int32 max_cltv_delta = 9;
}

message QuoteRequest {
    /*
    The amount to swap in satoshis. In the loop-in case this can either be taken
    from the connected lnd wallet or coin-selected from static address deposits.
    This is controlled by the select_deposits flag. If deposit_outpoints are
    specified, the coins are taken out of that.
    */
    int64 amt = 1;

    /*
    The confirmation target that should be used either for the sweep of the
    on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
    the confirmation of the on-chain HTLC broadcast by the swap client in the
    case of a Loop In.
    */
    int32 conf_target = 2;

    /*
    If external_htlc is true, we expect the htlc to be published by an external
    actor.
    */
    bool external_htlc = 3;

    /*
    The latest time (in unix seconds) we allow the server to wait before
    publishing the HTLC on chain. Setting this to a larger value will give the
    server the opportunity to batch multiple swaps together, and wait for
    low-fee periods before publishing the HTLC, potentially resulting in a
    lower total swap fee. This only has an effect on loop out quotes.
    */
    uint64 swap_publication_deadline = 4;

    /*
    Optionally the client can specify the last hop pubkey when requesting a
    loop-in quote. This is useful to get better off-chain routing fee from the
    server.
    */
    bytes loop_in_last_hop = 5;

    /*
    Optional route hints to reach the destination through private channels.
    */
    repeated looprpc.RouteHint loop_in_route_hints = 6;

    /*
    Private indicates whether the destination node should be considered
    private. In which case, loop will generate hophints to assist with
    probing and payment.
    */
    bool private = 7;

    /*
    Static address deposit outpoints that will be quoted for. This option only
    pertains to loop in swaps. If the amt field is set as well the respective
    partial amount will be swapped. Cannot be used in conjunction with
    auto_select_deposits.
    */
    repeated string deposit_outpoints = 8;

    /*
    The optional asset information to use for the swap. If set, the quote will
    be returned in the specified asset.
    */
    AssetLoopOutRequest asset_info = 9;

    /*
    In the legacy loop-in case this field must be set to false.
    If set to true, the swap amount will be automatically selected from the
    static address deposits. If set to true, deposit_outpoints must be empty.
    This option only pertains to loop in swaps.
    */
    bool auto_select_deposits = 10;

    /*
    If set to true the server will immediately publish the swap in exchange for
    a higher fee. This can be useful if the client expects change from a swap.
    Note that this feature is only available for static address loop in swaps.
    */
    bool fast = 11;
}

message InQuoteResponse {
    reserved 2, 4;

    /*
    The fee that the swap server is charging for the swap.
    */
    int64 swap_fee_sat = 1;

    /*
    An estimate of the on-chain fee that needs to be paid to publish the HTLC
    If a miner fee of 0 is returned, it means the external_htlc flag was set for
    a loop in and the fee estimation was skipped. If a miner fee of -1 is
    returned, it means lnd's wallet tried to estimate the fee but was unable to
    create a sample estimation transaction because not enough funds are
    available. An information message should be shown to the user in this case.
    */
    int64 htlc_publish_fee_sat = 3;

    /*
    On-chain cltv expiry delta
    */
    int32 cltv_delta = 5;

    /*
    The confirmation target to be used to publish the on-chain HTLC.
    */
    int32 conf_target = 6;

    /*
    If the quote request was for a static address loop in and only contained
    deposit outpoints the quote response will return the total amount of the
    selected deposits.
    */
    int64 quoted_amt = 7;
}

message OutQuoteResponse {
    /*
    The fee that the swap server is charging for the swap.
    */
    int64 swap_fee_sat = 1;

    /*
    The part of the swap fee that is requested as a prepayment.
    */
    int64 prepay_amt_sat = 2;

    /*
    An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
    a loop out.
    */
    int64 htlc_sweep_fee_sat = 3;

    /*
    The node pubkey where the swap payment needs to be paid
    to. This can be used to test connectivity before initiating the swap.
    */
    bytes swap_payment_dest = 4;

    /*
    On-chain cltv expiry delta
    */
    int32 cltv_delta = 5;

    /*
    The confirmation target to be used for the sweep of the on-chain HTLC.
    */
    int32 conf_target = 6;

    /*
    If the request was for an asset swap, the quote will return the rfq ids
    that will be used to pay for the swap and prepay invoices.
    */
    AssetRfqInfo asset_rfq_info = 7;
}

message ProbeRequest {
    /*
    The amount to probe.
    */
    int64 amt = 1;

    /*
    Optional last hop of the route to probe.
    */
    bytes last_hop = 2;

    /*
    Optional route hints to reach the destination through private channels.
    */
    repeated looprpc.RouteHint route_hints = 3;
}

message ProbeResponse {
}

message TokensRequest {
}

message TokensResponse {
    /*
    List of all tokens the daemon knows of, including old/expired tokens.
    */
    repeated L402Token tokens = 1;
}

message FetchL402TokenRequest {
}

message FetchL402TokenResponse {
}

message L402Token {
    /*
    The base macaroon that was baked by the auth server.
    */
    bytes base_macaroon = 1;

    /*
    The payment hash of the payment that was paid to obtain the token.
    */
    bytes payment_hash = 2;

    /*
    The preimage of the payment hash, knowledge of this is proof that the
    payment has been paid. If the preimage is set to all zeros, this means the
    payment is still pending and the token is not yet fully valid.
    */
    bytes payment_preimage = 3;

    /*
    The amount of millisatoshis that was paid to get the token.
    */
    int64 amount_paid_msat = 4;

    /*
    The amount of millisatoshis paid in routing fee to pay for the token.
    */
    int64 routing_fee_paid_msat = 5;

    /*
    The creation time of the token as UNIX timestamp in seconds.
    */
    int64 time_created = 6;

    /*
    Indicates whether the token is expired or still valid.
    */
    bool expired = 7;

    /*
    Identifying attribute of this token in the store. Currently represents the
    file name of the token where it's stored on the file system.
    */
    string storage_name = 8;

    /*
    The l402 ID of the token.
    */
    string id = 9;
}

message LoopStats {
    /*
    Number of currently pending swaps.
     */
    uint64 pending_count = 1;

    /*
    Number of succeeded swaps.
     */
    uint64 success_count = 2;

    /*
    Number failed swaps.
     */
    uint64 fail_count = 3;

    /*
    The sum of all pending swap amounts.
     */
    int64 sum_pending_amt = 4;

    /*
    The sum of all succeeded swap amounts.
     */
    int64 sum_succeeded_amt = 5;
}

message GetInfoRequest {
}

message GetInfoResponse {
    /*
    The current daemon version.
     */
    string version = 1;

    /*
    The network the daemon is running on.
     */
    string network = 2;

    /*
    Host and port of the loopd grpc server.
     */
    string rpc_listen = 3;

    /*
    Host and port of the loopd rest server.
     */
    string rest_listen = 4;

    /*
    Loop's macaroon path that clients use to talk to the daemon.
     */
    string macaroon_path = 5;

    /*
    Loop's tls cert path
     */
    string tls_cert_path = 6;

    /*
    Statistics about loop outs.
     */
    LoopStats loop_out_stats = 7;

    /*
    Statistics about loop ins.
     */
    LoopStats loop_in_stats = 8;

    /*
    The Git commit hash the Loop binary build was based on. If the build had
    uncommited changes, this field will contain the most recent commit hash,
    suffixed by "-dirty".
     */
    string commit_hash = 9;
}

message GetLiquidityParamsRequest {
}

message LiquidityParameters {
    /*
    A set of liquidity rules that describe the desired liquidity balance.
    */
    repeated LiquidityRule rules = 1;

    /*
    The parts per million of swap amount that is allowed to be allocated to swap
    fees. This value is applied across swap categories and may not be set in
    conjunction with sweep fee rate, swap fee ppm, routing fee ppm, prepay
    routing, max prepay and max miner fee.
    */
    uint64 fee_ppm = 16;

    /*
    The limit we place on our estimated sweep cost for a swap in sat/vByte. If
    the estimated fee for our sweep transaction within the specified
    confirmation target is above this value, we will not suggest any swaps.
    */
    uint64 sweep_fee_rate_sat_per_vbyte = 2;

    /*
    The maximum fee paid to the server for facilitating the swap, expressed
    as parts per million of the swap volume.
    */
    uint64 max_swap_fee_ppm = 3;

    /*
    The maximum fee paid to route the swap invoice off chain, expressed as
    parts per million of the volume being routed.
    */
    uint64 max_routing_fee_ppm = 4;

    /*
    The maximum fee paid to route the prepay invoice off chain, expressed as
    parts per million of the volume being routed.
    */
    uint64 max_prepay_routing_fee_ppm = 5;

    /*
    The maximum no-show penalty in satoshis paid for a swap.
    */
    uint64 max_prepay_sat = 6;

    /*
    The maximum miner fee we will pay to sweep the swap on chain. Note that we
    will not suggest a swap if the estimate is above the sweep limit set by
    these parameters, and we use the current fee estimate to sweep on chain so
    this value is only a cap placed on the amount we spend on fees in the case
    where the swap needs to be claimed on chain, but fees have suddenly spiked.
    */
    uint64 max_miner_fee_sat = 7;

    /*
    The number of blocks from the on-chain HTLC's confirmation height that it
    should be swept within.
    */
    int32 sweep_conf_target = 8;

    /*
    The amount of time we require pass since a channel was part of a failed
    swap due to off chain payment failure until it will be considered for swap
    suggestions again, expressed in seconds.
    */
    uint64 failure_backoff_sec = 9;

    /*
    Set to true to enable automatic dispatch of swaps. All swaps will be limited
    to the fee categories set by these parameters, and total expenditure will
    be limited to the autoloop budget.
    */
    bool autoloop = 10;

    /*
    The total budget for automatically dispatched swaps since the budget start
    time, expressed in satoshis.
    */
    uint64 autoloop_budget_sat = 11;

    /*
    Deprecated, use autoloop_budget_refresh_period_sec. The start time for
    autoloop budget, expressed as a unix timestamp in seconds. If this value is
    0, the budget will be applied for all automatically dispatched swaps. Swaps
    that were completed before this date will not be included in budget
    calculations.
    */
    uint64 autoloop_budget_start_sec = 12 [deprecated = true];

    /*
    The maximum number of automatically dispatched swaps that we allow to be in
    flight at any point in time.
    */
    uint64 auto_max_in_flight = 13;

    /*
    The minimum amount, expressed in satoshis, that the autoloop client will
    dispatch a swap for. This value is subject to the server-side limits
    specified by the LoopOutTerms endpoint.
    */
    uint64 min_swap_amount = 14;

    /*
    The maximum amount, expressed in satoshis, that the autoloop client will
    dispatch a swap for. This value is subject to the server-side limits
    specified by the LoopOutTerms endpoint.
    */
    uint64 max_swap_amount = 15;

    /*
    The confirmation target for loop in on-chain htlcs.
    */
    int32 htlc_conf_target = 17;

    /*
    The destination address to use for autoloop loop outs. Set to "default" in
    order to revert to default behavior.
    */
    string autoloop_dest_address = 18;

    /*
    The period over which the autoloop budget is refreshed, expressed in
    seconds.
    */
    uint64 autoloop_budget_refresh_period_sec = 19;

    /*
    The time at which the autoloop budget was last refreshed, expressed as a
    UNIX timestamp in seconds.
    */
    uint64 autoloop_budget_last_refresh = 20;

    /*
    Set to true to enable easy autoloop. If set, all channel/peer rules will be
    overridden and the client will automatically dispatch swaps in order to meet
    the configured local balance target size. Currently only loop out is
    supported, meaning that easy autoloop can only reduce the funds that are
    held as balance in channels.
    */
    bool easy_autoloop = 21;

    /*
    The local balance target size, expressed in satoshis. This is used by easy
    autoloop to determine how much liquidity should be maintained in channels.
    */
    uint64 easy_autoloop_local_target_sat = 22;

    /*
   An alternative destination address source for the swap. This field
   represents the name of the account in the backing lnd instance.
   Refer to lnd's wallet import functions for reference.
    */
    string account = 23;

    /*
    The address type of the account specified in the account field.
    */
    AddressType account_addr_type = 24;

    /*
    A map of asset parameters to use for swaps. The key is the asset id and the
    value is the parameters to use for swaps in that asset.
    */
    map<string, EasyAssetAutoloopParams> easy_asset_params = 25;

    /*
     * Set to true to enable fast swap publication. If set, the server will
     * publish the HTLC immediately after receiving the swap request. This
     * setting has direct implications on the swap fees, as fast swaps may
     * not be able to be batched with other swaps.
     */
    bool fast_swap_publication = 26;
}

message EasyAssetAutoloopParams {
    /*
    Set to true to enable easy autoloop for this asset. If set the client will
    automatically dispatch swaps in order to meet the configured local balance
    target size. Currently only loop out is supported, meaning that easy
    autoloop can only reduce the funds that are held as balance in channels.
    */
    bool enabled = 1;

    /*
    The local balance target size, expressed in the asset's base units. This is
    used by easy autoloop to determine how much liquidity should be maintained
    in channels.
    */
    uint64 local_target_asset_amt = 2;
}

enum LiquidityRuleType {
    UNKNOWN = 0;
    THRESHOLD = 1;
}

message LiquidityRule {
    /*
    The short channel ID of the channel that this rule should be applied to.
    This field may not be set when the pubkey field is set.
    */
    uint64 channel_id = 1;

    // The type of swap that will be dispatched for this rule.
    SwapType swap_type = 6;

    /*
    The public key of the peer that this rule should be applied to. This field
    may not be set when the channel id field is set.
    */
    bytes pubkey = 5;

    /*
    Type indicates the type of rule that this message rule represents. Setting
    this value will determine which fields are used in the message. The comments
    on each field in this message will be prefixed with the LiquidityRuleType
    they belong to.
    */
    LiquidityRuleType type = 2;

    /*
    THRESHOLD: The percentage of total capacity that incoming capacity should
    not drop beneath.
    */
    uint32 incoming_threshold = 3;

    /*
    THRESHOLD: The percentage of total capacity that outgoing capacity should
    not drop beneath.
    */
    uint32 outgoing_threshold = 4;
}

message SetLiquidityParamsRequest {
    /*
    Parameters is the desired new set of parameters for the liquidity management
    subsystem. Note that the current set of parameters will be completely
    overwritten by the parameters provided (if they are valid), so the full set
    of parameters should be provided for each call.
    */
    LiquidityParameters parameters = 1;
}

message SetLiquidityParamsResponse {
}

message SuggestSwapsRequest {
}

enum AutoReason {
    AUTO_REASON_UNKNOWN = 0;

    /*
    Budget not started indicates that we do not recommend any swaps because
    the start time for our budget has not arrived yet.
    */
    AUTO_REASON_BUDGET_NOT_STARTED = 1;

    /*
    Sweep fees indicates that the estimated fees to sweep swaps are too high
    right now.
    */
    AUTO_REASON_SWEEP_FEES = 2;

    /*
    Budget elapsed indicates that the autoloop budget for the period has been
    elapsed.
    */
    AUTO_REASON_BUDGET_ELAPSED = 3;

    /*
    In flight indicates that the limit on in-flight automatically dispatched
    swaps has already been reached.
    */
    AUTO_REASON_IN_FLIGHT = 4;

    /*
    Swap fee indicates that the server fee for a specific swap is too high.
    */
    AUTO_REASON_SWAP_FEE = 5;

    /*
    Miner fee indicates that the miner fee for a specific swap is to high.
    */
    AUTO_REASON_MINER_FEE = 6;

    /*
    Prepay indicates that the prepay fee for a specific swap is too high.
    */
    AUTO_REASON_PREPAY = 7;

    /*
    Failure backoff indicates that a swap has recently failed for this target,
    and the backoff period has not yet passed.
    */
    AUTO_REASON_FAILURE_BACKOFF = 8;

    /*
    Loop out indicates that a loop out swap is currently utilizing the channel,
    so it is not eligible.
    */
    AUTO_REASON_LOOP_OUT = 9;

    /*
    Loop In indicates that a loop in swap is currently in flight for the peer,
    so it is not eligible.
    */
    AUTO_REASON_LOOP_IN = 10;

    /*
    Liquidity ok indicates that a target meets the liquidity balance expressed
    in its rule, so no swap is needed.
    */
    AUTO_REASON_LIQUIDITY_OK = 11;

    /*
    Budget insufficient indicates that we cannot perform a swap because we do
    not have enough pending budget available. This differs from budget elapsed,
    because we still have some budget available, but we have allocated it to
    other swaps.
    */
    AUTO_REASON_BUDGET_INSUFFICIENT = 12;

    /*
    Fee insufficient indicates that the fee estimate for a swap is higher than
    the portion of total swap amount that we allow fees to consume.
    */
    AUTO_REASON_FEE_INSUFFICIENT = 13;
}

message Disqualified {
    /*
    The short channel ID of the channel that was excluded from our suggestions.
    */
    uint64 channel_id = 1;

    /*
    The public key of the peer that was excluded from our suggestions.
    */
    bytes pubkey = 3;

    /*
    The reason that we excluded the channel from the our suggestions.
    */
    AutoReason reason = 2;
}

message SuggestSwapsResponse {
    /*
    The set of recommended loop outs.
    */
    repeated LoopOutRequest loop_out = 1;

    /*
    The set of recommended loop in swaps
    */
    repeated LoopInRequest loop_in = 3;

    /*
    Disqualified contains the set of channels that swaps are not recommended
    for.
    */
    repeated Disqualified disqualified = 2;
}

message AbandonSwapRequest {
    /*
    The swap identifier which currently is the hash that locks the HTLCs. When
    using REST, this field must be encoded as URL safe base64.
    */
    bytes id = 1;

    /*
    A flag that tries to ensure that the client understands that they are
    risking loss of funds by abandoning a swap. This could happen if an
    abandoned swap would wait on a timeout sweep by the client.
     */
    bool i_know_what_i_am_doing = 2;
}

message AbandonSwapResponse {
}

message ListReservationsRequest {
}

message ListReservationsResponse {
    /*
    The list of all currently known reservations and their status.
    */
    repeated ClientReservation reservations = 1;
}

message ClientReservation {
    /*
    The reservation id that identifies this reservation.
    */
    bytes reservation_id = 1;

    /*
    The state the reservation is in.
    */
    string state = 2;

    /*
    The amount that the reservation is for.
    */
    uint64 amount = 3;

    /*
    The transaction id of the reservation.
    */
    string tx_id = 4;

    /*
    The vout of the reservation.
    */
    uint32 vout = 5;

    /*
    The expiry of the reservation.
    */
    uint32 expiry = 6;
}

message InstantOutRequest {
    /*
    The reservations to use for the swap.
    */
    repeated bytes reservation_ids = 1;

    /*
    A restriction on the channel set that may be used to loop out. The actual
    channel(s) that will be used are selected based on the lowest routing fee
    for the swap payment to the server.
    */
    repeated uint64 outgoing_chan_set = 2;

    /*
    An optional address to sweep the onchain funds to. If not set, the funds
    will be swept to the wallet's internal address.
    */
    string dest_addr = 3;
}

message InstantOutResponse {
    /*
    The hash of the swap preimage.
    */
    bytes instant_out_hash = 1;

    /*
    The transaction id of the sweep transaction.
    */
    string sweep_tx_id = 2;

    /*
    The state of the swap.
    */
    string state = 3;
}

message InstantOutQuoteRequest {
    /*
    The amount to swap in satoshis.
    */
    uint64 amt = 1;

    /*
    Deprecated: use 'reservation_ids' instead.
    The amount of reservations to use for the swap.
    */
    int32 num_reservations = 2 [deprecated = true];

    /*
    The reservations to use for the swap.
    */
    repeated bytes reservation_ids = 3;
}

message InstantOutQuoteResponse {
    /*
    The fee that the swap service is charging for the swap.
    */
    int64 service_fee_sat = 1;

    /*
    The estimated on-chain fee that needs to be paid to publish the Sweepless
    Sweep.
    */
    int64 sweep_fee_sat = 2;
}

message ListInstantOutsRequest {
}

message ListInstantOutsResponse {
    /*
    The list of all currently known instant out swaps and their status.
    */
    repeated InstantOut swaps = 1;
}

message InstantOut {
    /*
    The swap hash that identifies this swap.
    */
    bytes swap_hash = 1;

    /*
    The state the swap is in.
    */
    string state = 2;

    /*
    The amount of the swap.
    */
    uint64 amount = 3;

    /*
    The used reservations for the swap.
    */
    repeated bytes reservation_ids = 4;

    /*
    The sweep transaction id of the swap.
    */
    string sweep_tx_id = 5;
}

message NewStaticAddressRequest {
    /*
    The client's public key for the 2-of-2 MuSig2 taproot static address.
    */
    bytes client_key = 1;
}

message NewStaticAddressResponse {
    /*
    The taproot static address.
    */
    string address = 1;

    /*
    The CSV expiry of the static address.
    */
    uint32 expiry = 2;
}

message ListUnspentDepositsRequest {
    /*
    The number of minimum confirmations a utxo must have to be listed.
     */
    int32 min_confs = 1;

    /*
    The number of maximum confirmations a utxo may have to be listed. A zero
    value indicates that there is no maximum.
    */
    int32 max_confs = 2;
}

message ListUnspentDepositsResponse {
    /*
    A list of utxos behind the static address.
    */
    repeated Utxo utxos = 1;
}

message Utxo {
    /*
    The static address of the utxo.
    */
    string static_address = 1;

    /*
    The value of the unspent coin in satoshis.
    */
    int64 amount_sat = 2;

    /*
    The outpoint in the form txid:index.
    */
    string outpoint = 3;

    /*
    The number of confirmations for the Utxo.
    */
    int64 confirmations = 4;
}

message WithdrawDepositsRequest {
    /*
    The outpoints of the deposits to withdraw.
    */
    repeated OutPoint outpoints = 1;

    /*
    If set to true, all deposits will be withdrawn.
    */
    bool all = 2;

    /*
    The address to withdraw the funds to.
    */
    string dest_addr = 3;

    /*
    The fee rate in sat/vbyte to use for the withdrawal transaction.
    */
    int64 sat_per_vbyte = 4;

    /*
    The amount in satoshis that should be withdrawn from the selected deposits.
    If there is change, it will be sent back to the static address. The fees for
    the transaction are taken from the change output. If the change is below
    the dust limit, there won't be a change output and the dust goes towards
    fees.
    */
    int64 amount = 5;
}

message WithdrawDepositsResponse {
    /*
    The transaction hash of the withdrawal transaction.
    */
    string withdrawal_tx_hash = 1;

    /*
    The destination address of the withdrawal transaction.
    */
    string address = 2;
}

message ListStaticAddressDepositsRequest {
    /*
    Filters the list of all stored deposits by deposit state.
    */
    DepositState state_filter = 1;

    /*
    Filters the list of all stored deposits by the outpoint.
    */
    repeated string outpoints = 2;
}

message ListStaticAddressDepositsResponse {
    /*
    A list of all deposits that match the filtered state.
    */
    repeated Deposit filtered_deposits = 1;
}

message ListStaticAddressWithdrawalRequest {
}

message ListStaticAddressWithdrawalResponse {
    /*
    A list of all static address withdrawals.
    */
    repeated StaticAddressWithdrawal withdrawals = 1;
}

message ListStaticAddressSwapsRequest {
}

message ListStaticAddressSwapsResponse {
    /*
    A list of all swaps known static address loop-in swaps.
    */
    repeated StaticAddressLoopInSwap swaps = 1;
}

message StaticAddressSummaryRequest {
}

message StaticAddressSummaryResponse {
    /*
    The static address of the client.
    */
    string static_address = 1;

    /*
    The CSV expiry of the static address.
    */
    uint64 relative_expiry_blocks = 2;

    /*
    The total number of deposits.
    */
    uint32 total_num_deposits = 3;

    /*
    The total value of unconfirmed deposits.
    */
    int64 value_unconfirmed_satoshis = 4;

    /*
    The total value of confirmed deposits.
    */
    int64 value_deposited_satoshis = 5;

    /*
    The total value of all expired deposits.
    */
    int64 value_expired_satoshis = 6;

    /*
    The total value of all deposits that have been withdrawn.
    */
    int64 value_withdrawn_satoshis = 7;

    /*
    The total value of all loop-ins that have been finalized.
    */
    int64 value_looped_in_satoshis = 8;

    /*
    The total value of all htlc timeout sweeps that the client swept.
    */
    int64 value_htlc_timeout_sweeps_satoshis = 9;

    /*
    The total value of all deposits that have been used for channel openings.
    */
    int64 value_channels_opened = 10;
}

enum DepositState {
    /*
    UNKNOWN_STATE is the default state of a deposit.
    */
    UNKNOWN_STATE = 0;

    /*
    DEPOSITED indicates that the deposit has been sufficiently confirmed on
    chain.
    */
    DEPOSITED = 1;

    /*
    WITHDRAWING indicates that the deposit is currently being withdrawn. It
    flips to WITHDRAWN once the withdrawal transaction has been sufficiently
    confirmed.
    */
    WITHDRAWING = 2;

    /*
    WITHDRAWN indicates that the deposit has been withdrawn.
    */
    WITHDRAWN = 3;

    /*
    LOOPING_IN indicates that the deposit is currently being used in a static
    address loop-in swap.
    */
    LOOPING_IN = 4;

    /*
    LOOPED_IN indicates that the deposit was used in a static address loop-in
    swap.
    */
    LOOPED_IN = 5;

    /*
    SWEEP_HTLC_TIMEOUT indicates that the deposit is part of an active loop-in
    of which the respective htlc was published by the server and the timeout
    path has opened up for the client to sweep.
    */
    SWEEP_HTLC_TIMEOUT = 6;

    /*
    HTLC_TIMEOUT_SWEPT indicates that the timeout path of the htlc has been
    swept by the client.
    */
    HTLC_TIMEOUT_SWEPT = 7;

    /*
    PUBLISH_EXPIRED indicates that the deposit has expired and the sweep
    transaction has been published.
    */
    PUBLISH_EXPIRED = 8;

    /*
    WAIT_FOR_EXPIRY_SWEEP indicates that the deposit has expired and the sweep
    transaction has not yet been sufficiently confirmed.
    */
    WAIT_FOR_EXPIRY_SWEEP = 9;

    /*
    EXPIRED indicates that the deposit has expired and the sweep transaction
    has been sufficiently confirmed.
    */
    EXPIRED = 10;

    /*
    OPENING_CHANNEL indicates that the channel open in which the deposit was
    used is in progress.
    */
    OPENING_CHANNEL = 11;

    /*
    CHANNEL_PUBLISHED indicates that the channel open was finalized and
    published and that it should be managed from lnd from now on.
    */
    CHANNEL_PUBLISHED = 12;
}

message Deposit {
    /*
    The identifier of the deposit.
    */
    bytes id = 1;

    /*
    The state of the deposit.
    */
    DepositState state = 2;

    /*
    The outpoint of the deposit in format txid:index.
    */
    string outpoint = 3;

    /*
    The value of the deposit in satoshis.
    */
    int64 value = 4;

    /*
    The block height at which the deposit was confirmed.
    */
    int64 confirmation_height = 5;

    /*
    The number of blocks that are left until the deposit cannot be used for a
    loop-in swap anymore.
    */
    int64 blocks_until_expiry = 6;

    /*
    The swap hash of the swap that this deposit is part of. This field is only
    set if the deposit is part of a loop-in swap.
    */
    bytes swap_hash = 7;
}

message StaticAddressWithdrawal {
    /*
    The transaction id of the withdrawal transaction.
    */
    string tx_id = 1;

    /*
    The selected deposits that is withdrawn from.
    */
    repeated Deposit deposits = 2;

    /*
    The sum of the deposit values that was selected for withdrawal.
    */
    int64 total_deposit_amount_satoshis = 3;

    /*
    The actual amount that was withdrawn from the selected deposits. This value
    represents the sum of selected deposit values minus tx fees minus optional
    change output.
    */
    int64 withdrawn_amount_satoshis = 4;

    /*
    An optional change.
    */
    int64 change_amount_satoshis = 5;

    /*
    The confirmation block height of the withdrawal transaction.
    */
    uint32 confirmation_height = 6;
}

message StaticAddressLoopInSwap {
    /*
    The swap hash of the swap. It represents the unique identifier of the swap.
    */
    bytes swap_hash = 1;

    /*
     */
    repeated string deposit_outpoints = 2;

    /*
     */
    StaticAddressLoopInSwapState state = 3;

    /*
    The swap amount of the swap. It is the sum of the values of the deposit
    outpoints that were used for this swap.
    */
    int64 swap_amount_satoshis = 4;

    /*
    The invoiced swap amount. It is the swap amount minus the quoted server
    fees.
    */
    int64 payment_request_amount_satoshis = 5;

    /*
    The deposits that were used for this swap.
    */
    repeated Deposit deposits = 6;
}

enum StaticAddressLoopInSwapState {
    /*
     */
    UNKNOWN_STATIC_ADDRESS_SWAP_STATE = 0;

    /*
     */
    INIT_HTLC = 1;

    /*
     */
    SIGN_HTLC_TX = 2;

    /*
     */
    MONITOR_INVOICE_HTLC_TX = 3;

    /*
     */
    PAYMENT_RECEIVED = 4;

    /*
     */
    SWEEP_STATIC_ADDRESS_HTLC_TIMEOUT = 5;

    /*
     */
    MONITOR_HTLC_TIMEOUT_SWEEP = 6;

    /*
     */
    HTLC_STATIC_ADDRESS_TIMEOUT_SWEPT = 7;

    /*
     */
    SUCCEEDED = 8;

    /*
     */
    SUCCEEDED_TRANSITIONING_FAILED = 9;

    /*
     */
    UNLOCK_DEPOSITS = 10;

    /*
     */
    FAILED_STATIC_ADDRESS_SWAP = 11;
}

message StaticAddressLoopInRequest {
    /*
    The outpoints of the deposits to loop-in.
    */
    repeated string outpoints = 1;

    /*
    Maximum satoshis we are willing to pay the server for the swap. This value
    is not disclosed in the swap initiation call, but if the server asks for a
    higher fee, we abort the swap. Typically this value is taken from the
    response of the GetQuote call.
    */
    int64 max_swap_fee_satoshis = 2;

    /*
    Optionally the client can specify the last hop pubkey when requesting a
    loop-in quote. This is useful to get better off-chain routing fee from the
    server.
    */
    bytes last_hop = 3;

    /*
    An optional label for this swap. This field is limited to 500 characters and
    may not be one of the reserved values in loop/labels Reserved list.
    */
    string label = 4;

    /*
    An optional identification string that will be appended to the user agent
    string sent to the server to give information about the usage of loop. This
    initiator part is meant for user interfaces to add their name to give the
    full picture of the binary used (loopd, LiT) and the method used for
    triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
    */
    string initiator = 5;

    /*
    Optional route hints to reach the destination through private channels.
    */
    repeated looprpc.RouteHint route_hints = 6;

    /*
    Private indicates whether the destination node should be considered private.
    In which case, loop will generate hop hints to assist with probing and
    payment.
    */
    bool private = 7;

    /*
    The swap payment timeout allows the user to specify an upper limit for the
    amount of time the server is allowed to take to fulfill the off-chain swap
    payment. If the timeout is reached the swap will be aborted on the server
    side and the client can retry the swap with different parameters.
    */
    uint32 payment_timeout_seconds = 8;

    /*
    The optional swap amount the client is attempting to swap. It can be
    provided in combination with the outpoints or separately. If provided with
    outpoints the client takes out this amount from the sum of provided
    outpoints and sends the change back to the static address. If the amount is
    provided without outpoints, the client will select deposits automatically.
    The coin selection strategy is simplified by sorting all available deposits
    in descending order by amount, and equal amounts in ascending order of
    blocks until expiry, and then selecting the largest deposits first until the
    amount is reached. The change will be sent back to the static address. If a
    subset of outpoints suffice to cover the specified amount the swap will be
    canceled to allow the user to safe on transaction fees.
    */
    int64 amount = 9;

    // If set, request the server to use fast publication behavior.
    bool fast = 10;
}

message StaticAddressLoopInResponse {
    /*
    The swap hash that identifies this swap.
    */
    bytes swap_hash = 1;

    /*
    The state the swap is in.
    */
    string state = 2;

    /*
    The amount of the swap.
    */
    uint64 amount = 3;

    /*
    The htlc cltv expiry height of the swap.
    */
    int32 htlc_cltv = 4;

    /*
    The quoted swap fee in satoshis.
    */
    int64 quoted_swap_fee_satoshis = 5;

    /*
    The maximum total swap fee the client is willing to pay for the swap.
    */
    int64 max_swap_fee_satoshis = 6;

    /*
    The block height at which the swap was initiated.
    */
    uint32 initiation_height = 7;

    /*
    The static address protocol version.
    */
    string protocol_version = 8;

    /*
    An optional label for this swap.
    */
    string label = 9;

    /*
    An optional identification string that will be appended to the user agent
    string sent to the server to give information about the usage of loop. This
    initiator part is meant for user interfaces to add their name to give the
    full picture of the binary used (loopd, LiT) and the method used for
    triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
    */
    string initiator = 10;

    /*
    The swap payment timeout allows the user to specify an upper limit for the
    amount of time the server is allowed to take to fulfill the off-chain swap
    payment. If the timeout is reached the swap will be aborted on the server
    side and the client can retry the swap with different parameters.
    */
    uint32 payment_timeout_seconds = 11;

    /*
    The deposits that are used for this swap.
    */
    repeated Deposit used_deposits = 12;

    /*
    The amount that is being swapped (may be less than total deposit value if
    change is returned).
    */
    uint64 swap_amount = 13;

    /*
    The change amount that will be returned to the static address.
    */
    int64 change = 14;

    /*
    If set, indicates that the server was requested to use fast publication
    behavior.
    */
    bool fast = 15;
}

message AssetLoopOutRequest {
    /*
    The asset id to use to pay for the swap invoice. If set an
    asset client is needed to set to be able to pay the invoice.
    */
    bytes asset_id = 1;

    /*
    The node identity public key of the peer to ask for a quote for sending out
    the assets and converting them to satoshis. This must be specified if
    an asset id is set.
    */
    bytes asset_edge_node = 2;

    /*
    An optional maximum multiplier for the rfq rate. If not set, the default
    will be 1.1. This means if we request a loop out quote for 1 BTC, the off
    chain cost will be at most 1.1 BTC.
    */
    double max_limit_multiplier = 3;

    /*
    An optional expiry unix timestamp for when the rfq quote should expire.
    */
    int64 expiry = 4;
}

message AssetRfqInfo {
    /*
    The Prepay RFQ ID to use to pay for the prepay invoice.
    */
    bytes prepay_rfq_id = 1;

    /*
    The maximum asset amt we'll pay for the prepay payment. This includes the
    max limit multiplier that was set in the request.
    */
    uint64 max_prepay_asset_amt = 2;

    /*
    The asset to BTC conversion rate for the prepay invoice.
    */
    FixedPoint prepay_asset_rate = 6;

    /*
    The Swap RFQ ID to use to pay for the swap invoice.
    */
    bytes swap_rfq_id = 3;

    /*
    The maximum asset amt we'll pay for the swap payment. This includes the
    max limit multiplier that was set in the request.
    */
    uint64 max_swap_asset_amt = 4;

    /*
    The asset to BTC conversion rate for the swap invoice.
    */
    FixedPoint swap_asset_rate = 7;

    /*
    The name of the asset to swap.
    */
    string asset_name = 5;
}

// FixedPoint is a scaled integer representation of a fractional number.
//
// This type consists of two integer fields: a coefficient and a scale.
// Using this format enables precise and consistent representation of fractional
// numbers while avoiding floating-point data types, which are prone to
// precision errors.
//
// The relationship between the fractional representation and its fixed-point
// representation is expressed as:
// ```
// V = F_c / (10^F_s)
// ```
// where:
//
// * `V` is the fractional value.
//
// * `F_c` is the coefficient component of the fixed-point representation. It is
//    the scaled-up fractional value represented as an integer.
//
// * `F_s` is the scale component. It is an integer specifying how
//   many decimal places `F_c` should be divided by to obtain the fractional
//   representation.
message FixedPoint {
    // The coefficient is the fractional value scaled-up as an integer. This
    // integer is represented as a string as it may be too large to fit in a
    // uint64.
    string coefficient = 1;

    // The scale is the component that determines how many decimal places
    // the coefficient should be divided by to obtain the fractional value.
    uint32 scale = 2;
}

message AssetLoopOutInfo {
    /*
    The asset id that was used to pay for the swap invoice.
    */
    string asset_id = 1;
    /*
    The human readable name of the asset.
    */
    string asset_name = 2;
    /*
    The total asset offchain cost of the swap.
    */
    uint64 asset_cost_offchain = 3;
}

message OpenChannelRequest {
    // A manual fee rate set in sat/vbyte that should be used when crafting the
    // funding transaction.
    uint64 sat_per_vbyte = 1;

    /*
    The pubkey of the node to open a channel with. When using REST, this field
    must be encoded as base64.
    */
    bytes node_pubkey = 2;

    // The number of satoshis the wallet should commit to the channel
    int64 local_funding_amount = 3;

    // The number of satoshis to push to the remote side as part of the initial
    // commitment state
    int64 push_sat = 4;

    // Whether this channel should be private, not announced to the greater
    // network.
    bool private = 5;

    // The minimum value in millisatoshi we will require for incoming HTLCs on
    // the channel.
    int64 min_htlc_msat = 6;

    // The delay we require on the remote's commitment transaction. If this is
    // not set, it will be scaled automatically with the channel size.
    uint32 remote_csv_delay = 7;

    // The minimum number of confirmations each one of your outputs used for
    // the funding transaction must satisfy.
    int32 min_confs = 8;

    // Whether unconfirmed outputs should be used as inputs for the funding
    // transaction.
    bool spend_unconfirmed = 9;

    /*
    Close address is an optional address which specifies the address to which
    funds should be paid out to upon cooperative close. This field may only be
    set if the peer supports the option upfront feature bit (call listpeers
    to check). The remote peer will only accept cooperative closes to this
    address if it is set.

    Note: If this value is set on channel creation, you will *not* be able to
    cooperatively close out to a different address.
    */
    string close_address = 10;

    /*
    Funding shims are an optional argument that allow the caller to intercept
    certain funding functionality. For example, a shim can be provided to use a
    particular key for the commitment key (ideally cold) rather than use one
    that is generated by the wallet as normal, or signal that signing will be
    carried out in an interactive manner (PSBT based).
    */
    FundingShim funding_shim = 11;

    /*
    The maximum amount of coins in millisatoshi that can be pending within
    the channel. It only applies to the remote party.
    */
    uint64 remote_max_value_in_flight_msat = 12;

    /*
    The maximum number of concurrent HTLCs we will allow the remote party to add
    to the commitment transaction.
    */
    uint32 remote_max_htlcs = 13;

    /*
    Max local csv is the maximum csv delay we will allow for our own commitment
    transaction.
    */
    uint32 max_local_csv = 14;

    /*
    The explicit commitment type to use. Note this field will only be used if
    the remote peer supports explicit channel negotiation.
    */
    CommitmentType commitment_type = 15;

    /*
    If this is true, then a zero-conf channel open will be attempted.
    */
    bool zero_conf = 16;

    /*
    If this is true, then an option-scid-alias channel-type open will be
    attempted.
    */
    bool scid_alias = 17;

    /*
    The base fee charged regardless of the number of milli-satoshis sent.
    */
    uint64 base_fee = 18;

    /*
    The fee rate in ppm (parts per million) that will be charged in
    proportion of the value of each forwarded HTLC.
    */
    uint64 fee_rate = 19;

    /*
    If use_base_fee is true the open channel announcement will update the
    channel base fee with the value specified in base_fee. In the case of
    a base_fee of 0 use_base_fee is needed downstream to distinguish whether
    to use the default base fee value specified in the config or 0.
    */
    bool use_base_fee = 20;

    /*
    If use_fee_rate is true the open channel announcement will update the
    channel fee rate with the value specified in fee_rate. In the case of
    a fee_rate of 0 use_fee_rate is needed downstream to distinguish whether
    to use the default fee rate value specified in the config or 0.
    */
    bool use_fee_rate = 21;

    /*
    The number of satoshis we require the remote peer to reserve. This value,
    if specified, must be above the dust limit and below 20% of the channel
    capacity.
    */
    uint64 remote_chan_reserve_sat = 22;

    /*
    If set, then lnd will attempt to commit all the coins under control of the
    internal wallet to open the channel, and the LocalFundingAmount field must
    be zero and is ignored.
    */
    bool fund_max = 23;

    /*
    An optional note-to-self to go along with the channel containing some
    useful information. This is only ever stored locally and in no way impacts
    the channel's operation.
    */
    string memo = 24;

    /*
    A list of selected static address deposits that are allocated for channel
    funding.
    */
    repeated OutPoint outpoints = 25;
}

enum CommitmentType {
    /*
    Returned when the commitment type isn't known or unavailable.
    */
    UNKNOWN_COMMITMENT_TYPE = 0;

    /*
    A channel that uses the modern commitment format where the key in the
    output of the remote party does not change each state. This makes back
    up and recovery easier as when the channel is closed, the funds go
    directly to that key.
    */
    STATIC_REMOTE_KEY = 1;

    /*
    A channel that uses a commitment format that has anchor outputs on the
    commitments, allowing fee bumping after a force close transaction has
    been broadcast.
    */
    ANCHORS = 2;

    /*
    A channel that uses musig2 for the funding output, and the new tapscript
    features where relevant.
    */
    SIMPLE_TAPROOT = 3;
}

message OpenStatusUpdate {
    oneof update {
        /*
        Signals that the channel is now fully negotiated and the funding
        transaction published.
        */
        PendingUpdate chan_pending = 1;

        /*
        Signals that the channel's funding transaction has now reached the
        required number of confirmations on chain and can be used.
        */
        ChannelOpenUpdate chan_open = 3;

        /*
        Signals that the funding process has been suspended and the construction
        of a PSBT that funds the channel PK script is now required.
        */
        ReadyForPsbtFunding psbt_fund = 5;
    }

    /*
    The pending channel ID of the created channel. This value may be used to
    further the funding flow manually via the FundingStateStep method.
    */
    bytes pending_chan_id = 4;
}

message PendingUpdate {
    bytes txid = 1;
    uint32 output_index = 2;
    int64 fee_per_vbyte = 3;
    bool local_close_tx = 4;
}

message ChannelOpenUpdate {
    ChannelPoint channel_point = 1;
}

message ReadyForPsbtFunding {
    /*
    The P2WSH address of the channel funding multisig address that the below
    specified amount in satoshis needs to be sent to.
    */
    string funding_address = 1;

    /*
    The exact amount in satoshis that needs to be sent to the above address to
    fund the pending channel.
    */
    int64 funding_amount = 2;

    /*
    A raw PSBT that contains the pending channel output. If a base PSBT was
    provided in the PsbtShim, this is the base PSBT with one additional output.
    If no base PSBT was specified, this is an otherwise empty PSBT with exactly
    one output.
    */
    bytes psbt = 3;
}

message FundingShim {
    oneof shim {
        /*
        A channel shim where the channel point was fully constructed outside
        of lnd's wallet and the transaction might already be published.
        */
        ChanPointShim chan_point_shim = 1;

        /*
        A channel shim that uses a PSBT to fund and sign the channel funding
        transaction.
        */
        PsbtShim psbt_shim = 2;
    }
}

message FundingShimCancel {
    // The pending channel ID of the channel to cancel the funding shim for.
    bytes pending_chan_id = 1;
}

message PsbtShim {
    /*
    A unique identifier of 32 random bytes that will be used as the pending
    channel ID to identify the PSBT state machine when interacting with it and
    on the wire protocol to initiate the funding request.
    */
    bytes pending_chan_id = 1;

    /*
    An optional base PSBT the new channel output will be added to. If this is
    non-empty, it must be a binary serialized PSBT.
    */
    bytes base_psbt = 2;

    /*
    If a channel should be part of a batch (multiple channel openings in one
    transaction), it can be dangerous if the whole batch transaction is
    published too early before all channel opening negotiations are completed.
    This flag prevents this particular channel from broadcasting the transaction
    after the negotiation with the remote peer. In a batch of channel openings
    this flag should be set to true for every channel but the very last.
    */
    bool no_publish = 3;
}

message ChanPointShim {
    /*
    The size of the pre-crafted output to be used as the channel point for this
    channel funding.
    */
    int64 amt = 1;

    // The target channel point to refrence in created commitment transactions.
    ChannelPoint chan_point = 2;

    // Our local key to use when creating the multi-sig output.
    KeyDescriptor local_key = 3;

    // The key of the remote party to use when creating the multi-sig output.
    bytes remote_key = 4;

    /*
    If non-zero, then this will be used as the pending channel ID on the wire
    protocol to initate the funding request. This is an optional field, and
    should only be set if the responder is already expecting a specific pending
    channel ID.
    */
    bytes pending_chan_id = 5;

    /*
    This uint32 indicates if this channel is to be considered 'frozen'. A frozen
    channel does not allow a cooperative channel close by the initiator. The
    thaw_height is the height that this restriction stops applying to the
    channel. The height can be interpreted in two ways: as a relative height if
    the value is less than 500,000, or as an absolute height otherwise.
    */
    uint32 thaw_height = 6;

    /*
    Indicates that the funding output is using a MuSig2 multi-sig output.
    */
    bool musig2 = 7;
}

message ChannelPoint {
    oneof funding_txid {
        /*
        Txid of the funding transaction. When using REST, this field must be
        encoded as base64.
        */
        bytes funding_txid_bytes = 1;

        /*
        Hex-encoded string representing the byte-reversed hash of the funding
        transaction.
        */
        string funding_txid_str = 2;
    }

    // The index of the output of the funding transaction
    uint32 output_index = 3;
}

message KeyDescriptor {
    /*
    The raw bytes of the key being identified.
    */
    bytes raw_key_bytes = 1;

    /*
    The key locator that identifies which key to use for signing.
    */
    KeyLocator key_loc = 2;
}

message KeyLocator {
    // The family of key being identified.
    int32 key_family = 1;

    // The precise index of the key being identified.
    int32 key_index = 2;
}

message OutPoint {
    /*
    Raw bytes representing the transaction id.
    */
    bytes txid_bytes = 1;

    /*
    Reversed, hex-encoded string representing the transaction id.
    */
    string txid_str = 2;

    /*
    The index of the output on the transaction.
    */
    uint32 output_index = 3;
}

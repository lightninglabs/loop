{
  "swagger": "2.0",
  "info": {
    "title": "client.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "SwapClient"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/auto/suggest": {
      "get": {
        "summary": "loop: `suggestswaps`\nSuggestSwaps returns a list of recommended swaps based on the current\nstate of your node's channels and it's liquidity manager parameters.\nNote that only loop out suggestions are currently supported.\n[EXPERIMENTAL]: endpoint is subject to change.",
        "operationId": "SwapClient_SuggestSwaps",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcSuggestSwapsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/l402/tokens": {
      "get": {
        "summary": "loop: `listauth`\nGetL402Tokens returns all L402 tokens the daemon ever paid for.",
        "operationId": "SwapClient_GetL402Tokens",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcTokensResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/liquidity/params": {
      "get": {
        "summary": "loop: `getparams`\nGetLiquidityParams gets the parameters that the daemon's liquidity manager\nis currently configured with. This may be nil if nothing is configured.\n[EXPERIMENTAL]: endpoint is subject to change.",
        "operationId": "SwapClient_GetLiquidityParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcLiquidityParameters"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "SwapClient"
        ]
      },
      "post": {
        "summary": "loop: `setparams`\nSetLiquidityParams sets a new set of parameters for the daemon's liquidity\nmanager. Note that the full set of parameters must be provided, because\nthis call fully overwrites our existing parameters.\n[EXPERIMENTAL]: endpoint is subject to change.",
        "operationId": "SwapClient_SetLiquidityParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcSetLiquidityParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/looprpcSetLiquidityParamsRequest"
            }
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/in": {
      "post": {
        "summary": "loop: `in`\nLoopIn initiates a loop in swap with the given parameters. The call\nreturns after the swap has been set up with the swap server. From that\npoint onwards, progress can be tracked via the SwapStatus stream\nthat is returned from Monitor().",
        "operationId": "SwapClient_LoopIn",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcSwapResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/looprpcLoopInRequest"
            }
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/in/probe/{amt}": {
      "get": {
        "summary": "Probe asks he sever to probe the route to us to have a better upfront\nestimate about routing fees when loopin-in.",
        "operationId": "SwapClient_Probe",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcProbeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "amt",
            "description": "The amount to probe.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "last_hop",
            "description": "Optional last hop of the route to probe.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/in/quote/{amt}": {
      "get": {
        "summary": "loop: `quote`\nGetQuote returns a quote for a swap with the provided parameters.",
        "operationId": "SwapClient_GetLoopInQuote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcInQuoteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "amt",
            "description": "The amount to swap in satoshis. In the loop-in case this can either be taken\nfrom the connected lnd wallet or coin-selected from static address deposits.\nThis is controlled by the select_deposits flag. If deposit_outpoints are\nspecified, the coins are taken out of that.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "conf_target",
            "description": "The confirmation target that should be used either for the sweep of the\non-chain HTLC broadcast by the swap server in the case of a Loop Out, or for\nthe confirmation of the on-chain HTLC broadcast by the swap client in the\ncase of a Loop In.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "external_htlc",
            "description": "If external_htlc is true, we expect the htlc to be published by an external\nactor.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "swap_publication_deadline",
            "description": "The latest time (in unix seconds) we allow the server to wait before\npublishing the HTLC on chain. Setting this to a larger value will give the\nserver the opportunity to batch multiple swaps together, and wait for\nlow-fee periods before publishing the HTLC, potentially resulting in a\nlower total swap fee. This only has an effect on loop out quotes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "loop_in_last_hop",
            "description": "Optionally the client can specify the last hop pubkey when requesting a\nloop-in quote. This is useful to get better off-chain routing fee from the\nserver.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "private",
            "description": "Private indicates whether the destination node should be considered\nprivate. In which case, loop will generate hophints to assist with\nprobing and payment.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "deposit_outpoints",
            "description": "Static address deposit outpoints that will be quoted for. This option only\npertains to loop in swaps. If the amt field is set as well the respective\npartial amount will be swapped. Cannot be used in conjunction with\nauto_select_deposits.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "asset_info.asset_id",
            "description": "The asset id to use to pay for the swap invoice. If set an\nasset client is needed to set to be able to pay the invoice.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "asset_info.asset_edge_node",
            "description": "The node identity public key of the peer to ask for a quote for sending out\nthe assets and converting them to satoshis. This must be specified if\nan asset id is set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "asset_info.max_limit_multiplier",
            "description": "An optional maximum multiplier for the rfq rate. If not set, the default\nwill be 1.1. This means if we request a loop out quote for 1 BTC, the off\nchain cost will be at most 1.1 BTC.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "asset_info.expiry",
            "description": "An optional expiry unix timestamp for when the rfq quote should expire.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "auto_select_deposits",
            "description": "In the legacy loop-in case this field must be set to false.\nIf set to true, the swap amount will be automatically selected from the\nstatic address deposits. If set to true, deposit_outpoints must be empty.\nThis option only pertains to loop in swaps.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "fast",
            "description": "If set to true the server will immediately publish the swap in exchange for\na higher fee. This can be useful if the client expects change from a swap.\nNote that this feature is only available for static address loop in swaps.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/in/terms": {
      "get": {
        "summary": "loop: `terms`\nGetTerms returns the terms that the server enforces for swaps.",
        "operationId": "SwapClient_GetLoopInTerms",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcInTermsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/info": {
      "get": {
        "summary": "loop: `getinfo`\nGetInfo gets basic information about the loop daemon.",
        "operationId": "SwapClient_GetInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcGetInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/out": {
      "post": {
        "summary": "loop: `out`\nLoopOut initiates an loop out swap with the given parameters. The call\nreturns after the swap has been set up with the swap server. From that\npoint onwards, progress can be tracked via the SwapStatus stream that is\nreturned from Monitor().",
        "operationId": "SwapClient_LoopOut",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcSwapResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/looprpcLoopOutRequest"
            }
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/out/quote/{amt}": {
      "get": {
        "summary": "loop: `quote`\nLoopOutQuote returns a quote for a loop out swap with the provided\nparameters.",
        "operationId": "SwapClient_LoopOutQuote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcOutQuoteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "amt",
            "description": "The amount to swap in satoshis. In the loop-in case this can either be taken\nfrom the connected lnd wallet or coin-selected from static address deposits.\nThis is controlled by the select_deposits flag. If deposit_outpoints are\nspecified, the coins are taken out of that.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "conf_target",
            "description": "The confirmation target that should be used either for the sweep of the\non-chain HTLC broadcast by the swap server in the case of a Loop Out, or for\nthe confirmation of the on-chain HTLC broadcast by the swap client in the\ncase of a Loop In.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "external_htlc",
            "description": "If external_htlc is true, we expect the htlc to be published by an external\nactor.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "swap_publication_deadline",
            "description": "The latest time (in unix seconds) we allow the server to wait before\npublishing the HTLC on chain. Setting this to a larger value will give the\nserver the opportunity to batch multiple swaps together, and wait for\nlow-fee periods before publishing the HTLC, potentially resulting in a\nlower total swap fee. This only has an effect on loop out quotes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "loop_in_last_hop",
            "description": "Optionally the client can specify the last hop pubkey when requesting a\nloop-in quote. This is useful to get better off-chain routing fee from the\nserver.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "private",
            "description": "Private indicates whether the destination node should be considered\nprivate. In which case, loop will generate hophints to assist with\nprobing and payment.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "deposit_outpoints",
            "description": "Static address deposit outpoints that will be quoted for. This option only\npertains to loop in swaps. If the amt field is set as well the respective\npartial amount will be swapped. Cannot be used in conjunction with\nauto_select_deposits.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "asset_info.asset_id",
            "description": "The asset id to use to pay for the swap invoice. If set an\nasset client is needed to set to be able to pay the invoice.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "asset_info.asset_edge_node",
            "description": "The node identity public key of the peer to ask for a quote for sending out\nthe assets and converting them to satoshis. This must be specified if\nan asset id is set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "asset_info.max_limit_multiplier",
            "description": "An optional maximum multiplier for the rfq rate. If not set, the default\nwill be 1.1. This means if we request a loop out quote for 1 BTC, the off\nchain cost will be at most 1.1 BTC.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "asset_info.expiry",
            "description": "An optional expiry unix timestamp for when the rfq quote should expire.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "auto_select_deposits",
            "description": "In the legacy loop-in case this field must be set to false.\nIf set to true, the swap amount will be automatically selected from the\nstatic address deposits. If set to true, deposit_outpoints must be empty.\nThis option only pertains to loop in swaps.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "fast",
            "description": "If set to true the server will immediately publish the swap in exchange for\na higher fee. This can be useful if the client expects change from a swap.\nNote that this feature is only available for static address loop in swaps.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/out/terms": {
      "get": {
        "summary": "loop: `terms`\nLoopOutTerms returns the terms that the server enforces for a loop out swap.",
        "operationId": "SwapClient_LoopOutTerms",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcOutTermsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/swap/{id}": {
      "get": {
        "summary": "loop: `swapinfo`\nSwapInfo returns all known details about a single swap.",
        "operationId": "SwapClient_SwapInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcSwapStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "The swap identifier which currently is the hash that locks the HTLCs. When\nusing REST, this field must be encoded as URL safe base64.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/loop/swaps": {
      "get": {
        "summary": "loop: `listswaps`\nListSwaps returns a list of all currently known swaps and their current\nstatus.",
        "operationId": "SwapClient_ListSwaps",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcListSwapsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "list_swap_filter.swap_type",
            "description": "The type of the swap.\n\n - ANY: ANY indicates that no filter is applied.\n - LOOP_OUT: LOOP_OUT indicates an loop out swap (off-chain to on-chain).\n - LOOP_IN: LOOP_IN indicates a loop in swap (on-chain to off-chain).",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "ANY",
              "LOOP_OUT",
              "LOOP_IN"
            ],
            "default": "ANY"
          },
          {
            "name": "list_swap_filter.pending_only",
            "description": "If set, only pending swaps are returned.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "list_swap_filter.outgoing_chan_set",
            "description": "If specified on creation, the outgoing channel set of the swap.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "list_swap_filter.label",
            "description": "Label of swap to filter for.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "list_swap_filter.loop_in_last_hop",
            "description": "If specified on creation, the last hop of the swap.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "list_swap_filter.asset_swap_only",
            "description": "If specified, only returns asset swaps.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "list_swap_filter.start_timestamp_ns",
            "description": "If specified, returns swaps initiated after this Unix (ns) timestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "max_swaps",
            "description": "Set a maximum number of swaps to return in the response.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "SwapClient"
        ]
      }
    },
    "/v1/lsat/tokens": {
      "get": {
        "summary": "loop: `listauth`\nGetL402Tokens returns all L402 tokens the daemon ever paid for.",
        "operationId": "SwapClient_GetL402Tokens2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/looprpcTokensResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "SwapClient"
        ]
      }
    }
  },
  "definitions": {
    "ListSwapsFilterSwapTypeFilter": {
      "type": "string",
      "enum": [
        "ANY",
        "LOOP_OUT",
        "LOOP_IN"
      ],
      "default": "ANY",
      "description": " - ANY: ANY indicates that no filter is applied.\n - LOOP_OUT: LOOP_OUT indicates an loop out swap (off-chain to on-chain).\n - LOOP_IN: LOOP_IN indicates a loop in swap (on-chain to off-chain)."
    },
    "looprpcAbandonSwapResponse": {
      "type": "object"
    },
    "looprpcAddressType": {
      "type": "string",
      "enum": [
        "ADDRESS_TYPE_UNKNOWN",
        "TAPROOT_PUBKEY"
      ],
      "default": "ADDRESS_TYPE_UNKNOWN",
      "description": "- `unknown`: Unknown address type\n- `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 1)",
      "title": "`AddressType` has to be one of:"
    },
    "looprpcAssetLoopOutInfo": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "The asset id that was used to pay for the swap invoice."
        },
        "asset_name": {
          "type": "string",
          "description": "The human readable name of the asset."
        },
        "asset_cost_offchain": {
          "type": "string",
          "format": "uint64",
          "description": "The total asset offchain cost of the swap."
        }
      }
    },
    "looprpcAssetLoopOutRequest": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset id to use to pay for the swap invoice. If set an\nasset client is needed to set to be able to pay the invoice."
        },
        "asset_edge_node": {
          "type": "string",
          "format": "byte",
          "description": "The node identity public key of the peer to ask for a quote for sending out\nthe assets and converting them to satoshis. This must be specified if\nan asset id is set."
        },
        "max_limit_multiplier": {
          "type": "number",
          "format": "double",
          "description": "An optional maximum multiplier for the rfq rate. If not set, the default\nwill be 1.1. This means if we request a loop out quote for 1 BTC, the off\nchain cost will be at most 1.1 BTC."
        },
        "expiry": {
          "type": "string",
          "format": "int64",
          "description": "An optional expiry unix timestamp for when the rfq quote should expire."
        }
      }
    },
    "looprpcAssetRfqInfo": {
      "type": "object",
      "properties": {
        "prepay_rfq_id": {
          "type": "string",
          "format": "byte",
          "description": "The Prepay RFQ ID to use to pay for the prepay invoice."
        },
        "max_prepay_asset_amt": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum asset amt we'll pay for the prepay payment. This includes the\nmax limit multiplier that was set in the request."
        },
        "prepay_asset_rate": {
          "$ref": "#/definitions/looprpcFixedPoint",
          "description": "The asset to BTC conversion rate for the prepay invoice."
        },
        "swap_rfq_id": {
          "type": "string",
          "format": "byte",
          "description": "The Swap RFQ ID to use to pay for the swap invoice."
        },
        "max_swap_asset_amt": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum asset amt we'll pay for the swap payment. This includes the\nmax limit multiplier that was set in the request."
        },
        "swap_asset_rate": {
          "$ref": "#/definitions/looprpcFixedPoint",
          "description": "The asset to BTC conversion rate for the swap invoice."
        },
        "asset_name": {
          "type": "string",
          "description": "The name of the asset to swap."
        }
      }
    },
    "looprpcAutoReason": {
      "type": "string",
      "enum": [
        "AUTO_REASON_UNKNOWN",
        "AUTO_REASON_BUDGET_NOT_STARTED",
        "AUTO_REASON_SWEEP_FEES",
        "AUTO_REASON_BUDGET_ELAPSED",
        "AUTO_REASON_IN_FLIGHT",
        "AUTO_REASON_SWAP_FEE",
        "AUTO_REASON_MINER_FEE",
        "AUTO_REASON_PREPAY",
        "AUTO_REASON_FAILURE_BACKOFF",
        "AUTO_REASON_LOOP_OUT",
        "AUTO_REASON_LOOP_IN",
        "AUTO_REASON_LIQUIDITY_OK",
        "AUTO_REASON_BUDGET_INSUFFICIENT",
        "AUTO_REASON_FEE_INSUFFICIENT"
      ],
      "default": "AUTO_REASON_UNKNOWN",
      "description": " - AUTO_REASON_BUDGET_NOT_STARTED: Budget not started indicates that we do not recommend any swaps because\nthe start time for our budget has not arrived yet.\n - AUTO_REASON_SWEEP_FEES: Sweep fees indicates that the estimated fees to sweep swaps are too high\nright now.\n - AUTO_REASON_BUDGET_ELAPSED: Budget elapsed indicates that the autoloop budget for the period has been\nelapsed.\n - AUTO_REASON_IN_FLIGHT: In flight indicates that the limit on in-flight automatically dispatched\nswaps has already been reached.\n - AUTO_REASON_SWAP_FEE: Swap fee indicates that the server fee for a specific swap is too high.\n - AUTO_REASON_MINER_FEE: Miner fee indicates that the miner fee for a specific swap is to high.\n - AUTO_REASON_PREPAY: Prepay indicates that the prepay fee for a specific swap is too high.\n - AUTO_REASON_FAILURE_BACKOFF: Failure backoff indicates that a swap has recently failed for this target,\nand the backoff period has not yet passed.\n - AUTO_REASON_LOOP_OUT: Loop out indicates that a loop out swap is currently utilizing the channel,\nso it is not eligible.\n - AUTO_REASON_LOOP_IN: Loop In indicates that a loop in swap is currently in flight for the peer,\nso it is not eligible.\n - AUTO_REASON_LIQUIDITY_OK: Liquidity ok indicates that a target meets the liquidity balance expressed\nin its rule, so no swap is needed.\n - AUTO_REASON_BUDGET_INSUFFICIENT: Budget insufficient indicates that we cannot perform a swap because we do\nnot have enough pending budget available. This differs from budget elapsed,\nbecause we still have some budget available, but we have allocated it to\nother swaps.\n - AUTO_REASON_FEE_INSUFFICIENT: Fee insufficient indicates that the fee estimate for a swap is higher than\nthe portion of total swap amount that we allow fees to consume."
    },
    "looprpcChanPointShim": {
      "type": "object",
      "properties": {
        "amt": {
          "type": "string",
          "format": "int64",
          "description": "The size of the pre-crafted output to be used as the channel point for this\nchannel funding."
        },
        "chan_point": {
          "$ref": "#/definitions/looprpcChannelPoint",
          "description": "The target channel point to refrence in created commitment transactions."
        },
        "local_key": {
          "$ref": "#/definitions/looprpcKeyDescriptor",
          "description": "Our local key to use when creating the multi-sig output."
        },
        "remote_key": {
          "type": "string",
          "format": "byte",
          "description": "The key of the remote party to use when creating the multi-sig output."
        },
        "pending_chan_id": {
          "type": "string",
          "format": "byte",
          "description": "If non-zero, then this will be used as the pending channel ID on the wire\nprotocol to initate the funding request. This is an optional field, and\nshould only be set if the responder is already expecting a specific pending\nchannel ID."
        },
        "thaw_height": {
          "type": "integer",
          "format": "int64",
          "description": "This uint32 indicates if this channel is to be considered 'frozen'. A frozen\nchannel does not allow a cooperative channel close by the initiator. The\nthaw_height is the height that this restriction stops applying to the\nchannel. The height can be interpreted in two ways: as a relative height if\nthe value is less than 500,000, or as an absolute height otherwise."
        },
        "musig2": {
          "type": "boolean",
          "description": "Indicates that the funding output is using a MuSig2 multi-sig output."
        }
      }
    },
    "looprpcChannelPoint": {
      "type": "object",
      "properties": {
        "funding_txid_bytes": {
          "type": "string",
          "format": "byte",
          "description": "Txid of the funding transaction. When using REST, this field must be\nencoded as base64."
        },
        "funding_txid_str": {
          "type": "string",
          "description": "Hex-encoded string representing the byte-reversed hash of the funding\ntransaction."
        },
        "output_index": {
          "type": "integer",
          "format": "int64",
          "title": "The index of the output of the funding transaction"
        }
      }
    },
    "looprpcClientReservation": {
      "type": "object",
      "properties": {
        "reservation_id": {
          "type": "string",
          "format": "byte",
          "description": "The reservation id that identifies this reservation."
        },
        "state": {
          "type": "string",
          "description": "The state the reservation is in."
        },
        "amount": {
          "type": "string",
          "format": "uint64",
          "description": "The amount that the reservation is for."
        },
        "tx_id": {
          "type": "string",
          "description": "The transaction id of the reservation."
        },
        "vout": {
          "type": "integer",
          "format": "int64",
          "description": "The vout of the reservation."
        },
        "expiry": {
          "type": "integer",
          "format": "int64",
          "description": "The expiry of the reservation."
        }
      }
    },
    "looprpcCommitmentType": {
      "type": "string",
      "enum": [
        "UNKNOWN_COMMITMENT_TYPE",
        "STATIC_REMOTE_KEY",
        "ANCHORS",
        "SIMPLE_TAPROOT"
      ],
      "default": "UNKNOWN_COMMITMENT_TYPE",
      "description": " - UNKNOWN_COMMITMENT_TYPE: Returned when the commitment type isn't known or unavailable.\n - STATIC_REMOTE_KEY: A channel that uses the modern commitment format where the key in the\noutput of the remote party does not change each state. This makes back\nup and recovery easier as when the channel is closed, the funds go\ndirectly to that key.\n - ANCHORS: A channel that uses a commitment format that has anchor outputs on the\ncommitments, allowing fee bumping after a force close transaction has\nbeen broadcast.\n - SIMPLE_TAPROOT: A channel that uses musig2 for the funding output, and the new tapscript\nfeatures where relevant."
    },
    "looprpcDeposit": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "byte",
          "description": "The identifier of the deposit."
        },
        "state": {
          "$ref": "#/definitions/looprpcDepositState",
          "description": "The state of the deposit."
        },
        "outpoint": {
          "type": "string",
          "description": "The outpoint of the deposit in format txid:index."
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "The value of the deposit in satoshis."
        },
        "confirmation_height": {
          "type": "string",
          "format": "int64",
          "description": "The block height at which the deposit was confirmed."
        },
        "blocks_until_expiry": {
          "type": "string",
          "format": "int64",
          "description": "The number of blocks that are left until the deposit cannot be used for a\nloop-in swap anymore."
        },
        "swap_hash": {
          "type": "string",
          "format": "byte",
          "description": "The swap hash of the swap that this deposit is part of. This field is only\nset if the deposit is part of a loop-in swap."
        }
      }
    },
    "looprpcDepositState": {
      "type": "string",
      "enum": [
        "UNKNOWN_STATE",
        "DEPOSITED",
        "WITHDRAWING",
        "WITHDRAWN",
        "LOOPING_IN",
        "LOOPED_IN",
        "SWEEP_HTLC_TIMEOUT",
        "HTLC_TIMEOUT_SWEPT",
        "PUBLISH_EXPIRED",
        "WAIT_FOR_EXPIRY_SWEEP",
        "EXPIRED",
        "OPENING_CHANNEL",
        "CHANNEL_PUBLISHED"
      ],
      "default": "UNKNOWN_STATE",
      "description": " - UNKNOWN_STATE: UNKNOWN_STATE is the default state of a deposit.\n - DEPOSITED: DEPOSITED indicates that the deposit has been sufficiently confirmed on\nchain.\n - WITHDRAWING: WITHDRAWING indicates that the deposit is currently being withdrawn. It\nflips to WITHDRAWN once the withdrawal transaction has been sufficiently\nconfirmed.\n - WITHDRAWN: WITHDRAWN indicates that the deposit has been withdrawn.\n - LOOPING_IN: LOOPING_IN indicates that the deposit is currently being used in a static\naddress loop-in swap.\n - LOOPED_IN: LOOPED_IN indicates that the deposit was used in a static address loop-in\nswap.\n - SWEEP_HTLC_TIMEOUT: SWEEP_HTLC_TIMEOUT indicates that the deposit is part of an active loop-in\nof which the respective htlc was published by the server and the timeout\npath has opened up for the client to sweep.\n - HTLC_TIMEOUT_SWEPT: HTLC_TIMEOUT_SWEPT indicates that the timeout path of the htlc has been\nswept by the client.\n - PUBLISH_EXPIRED: PUBLISH_EXPIRED indicates that the deposit has expired and the sweep\ntransaction has been published.\n - WAIT_FOR_EXPIRY_SWEEP: WAIT_FOR_EXPIRY_SWEEP indicates that the deposit has expired and the sweep\ntransaction has not yet been sufficiently confirmed.\n - EXPIRED: EXPIRED indicates that the deposit has expired and the sweep transaction\nhas been sufficiently confirmed.\n - OPENING_CHANNEL: OPENING_CHANNEL indicates that the channel open in which the deposit was\nused is in progress.\n - CHANNEL_PUBLISHED: CHANNEL_PUBLISHED indicates that the channel open was finalized and\npublished and that it should be managed from lnd from now on."
    },
    "looprpcDisqualified": {
      "type": "object",
      "properties": {
        "channel_id": {
          "type": "string",
          "format": "uint64",
          "description": "The short channel ID of the channel that was excluded from our suggestions."
        },
        "pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The public key of the peer that was excluded from our suggestions."
        },
        "reason": {
          "$ref": "#/definitions/looprpcAutoReason",
          "description": "The reason that we excluded the channel from the our suggestions."
        }
      }
    },
    "looprpcEasyAssetAutoloopParams": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Set to true to enable easy autoloop for this asset. If set the client will\nautomatically dispatch swaps in order to meet the configured local balance\ntarget size. Currently only loop out is supported, meaning that easy\nautoloop can only reduce the funds that are held as balance in channels."
        },
        "local_target_asset_amt": {
          "type": "string",
          "format": "uint64",
          "description": "The local balance target size, expressed in the asset's base units. This is\nused by easy autoloop to determine how much liquidity should be maintained\nin channels."
        }
      }
    },
    "looprpcFailureReason": {
      "type": "string",
      "enum": [
        "FAILURE_REASON_NONE",
        "FAILURE_REASON_OFFCHAIN",
        "FAILURE_REASON_TIMEOUT",
        "FAILURE_REASON_SWEEP_TIMEOUT",
        "FAILURE_REASON_INSUFFICIENT_VALUE",
        "FAILURE_REASON_TEMPORARY",
        "FAILURE_REASON_INCORRECT_AMOUNT",
        "FAILURE_REASON_ABANDONED",
        "FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE",
        "FAILURE_REASON_INCORRECT_HTLC_AMT_SWEPT"
      ],
      "default": "FAILURE_REASON_NONE",
      "description": " - FAILURE_REASON_NONE: FAILURE_REASON_NONE is set when the swap did not fail, it is either in\nprogress or succeeded.\n - FAILURE_REASON_OFFCHAIN: FAILURE_REASON_OFFCHAIN indicates that a loop out failed because it wasn't\npossible to find a route for one or both off chain payments that met the fee\nand timelock limits required.\n - FAILURE_REASON_TIMEOUT: FAILURE_REASON_TIMEOUT indicates that the swap failed because on chain htlc\ndid not confirm before its expiry, or it confirmed too late for us to reveal\nour preimage and claim.\n - FAILURE_REASON_SWEEP_TIMEOUT: FAILURE_REASON_SWEEP_TIMEOUT indicates that a loop out permanently failed\nbecause the on chain htlc wasn't swept before the server revoked the\nhtlc.\n - FAILURE_REASON_INSUFFICIENT_VALUE: FAILURE_REASON_INSUFFICIENT_VALUE indicates that a loop out has failed\nbecause the on chain htlc had a lower value than requested.\n - FAILURE_REASON_TEMPORARY: FAILURE_REASON_TEMPORARY indicates that a swap cannot continue due to an\ninternal error. Manual intervention such as a restart is required.\n - FAILURE_REASON_INCORRECT_AMOUNT: FAILURE_REASON_INCORRECT_AMOUNT indicates that a loop in permanently failed\nbecause the amount extended by an external loop in htlc is insufficient.\n - FAILURE_REASON_ABANDONED: FAILURE_REASON_ABANDONED indicates that a swap permanently failed because\nthe client manually abandoned the swap.\n - FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE: FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE indicates that a swap\nwasn't published due to insufficient confirmed balance.\n - FAILURE_REASON_INCORRECT_HTLC_AMT_SWEPT: FAILURE_REASON_INCORRECT_HTLC_AMT_SWEPT indicates that a swap\nwasn't published due to insufficient confirmed balance."
    },
    "looprpcFetchL402TokenResponse": {
      "type": "object"
    },
    "looprpcFixedPoint": {
      "type": "object",
      "properties": {
        "coefficient": {
          "type": "string",
          "description": "The coefficient is the fractional value scaled-up as an integer. This\ninteger is represented as a string as it may be too large to fit in a\nuint64."
        },
        "scale": {
          "type": "integer",
          "format": "int64",
          "description": "The scale is the component that determines how many decimal places\nthe coefficient should be divided by to obtain the fractional value."
        }
      },
      "description": "FixedPoint is a scaled integer representation of a fractional number.\n\nThis type consists of two integer fields: a coefficient and a scale.\nUsing this format enables precise and consistent representation of fractional\nnumbers while avoiding floating-point data types, which are prone to\nprecision errors.\n\nThe relationship between the fractional representation and its fixed-point\nrepresentation is expressed as:\n```\nV = F_c / (10^F_s)\n```\nwhere:\n\n* `V` is the fractional value.\n\n* `F_c` is the coefficient component of the fixed-point representation. It is\n   the scaled-up fractional value represented as an integer.\n\n* `F_s` is the scale component. It is an integer specifying how\n  many decimal places `F_c` should be divided by to obtain the fractional\n  representation."
    },
    "looprpcFundingShim": {
      "type": "object",
      "properties": {
        "chan_point_shim": {
          "$ref": "#/definitions/looprpcChanPointShim",
          "description": "A channel shim where the channel point was fully constructed outside\nof lnd's wallet and the transaction might already be published."
        },
        "psbt_shim": {
          "$ref": "#/definitions/looprpcPsbtShim",
          "description": "A channel shim that uses a PSBT to fund and sign the channel funding\ntransaction."
        }
      }
    },
    "looprpcGetInfoResponse": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "The current daemon version."
        },
        "network": {
          "type": "string",
          "description": "The network the daemon is running on."
        },
        "rpc_listen": {
          "type": "string",
          "description": "Host and port of the loopd grpc server."
        },
        "rest_listen": {
          "type": "string",
          "description": "Host and port of the loopd rest server."
        },
        "macaroon_path": {
          "type": "string",
          "description": "Loop's macaroon path that clients use to talk to the daemon."
        },
        "tls_cert_path": {
          "type": "string",
          "title": "Loop's tls cert path"
        },
        "loop_out_stats": {
          "$ref": "#/definitions/looprpcLoopStats",
          "description": "Statistics about loop outs."
        },
        "loop_in_stats": {
          "$ref": "#/definitions/looprpcLoopStats",
          "description": "Statistics about loop ins."
        },
        "commit_hash": {
          "type": "string",
          "description": "The Git commit hash the Loop binary build was based on. If the build had\nuncommited changes, this field will contain the most recent commit hash,\nsuffixed by \"-dirty\"."
        }
      }
    },
    "looprpcHopHint": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string",
          "description": "The public key of the node at the start of the channel."
        },
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique identifier of the channel."
        },
        "fee_base_msat": {
          "type": "integer",
          "format": "int64",
          "description": "The base fee of the channel denominated in millisatoshis."
        },
        "fee_proportional_millionths": {
          "type": "integer",
          "format": "int64",
          "description": "The fee rate of the channel for sending one satoshi across it denominated in\nmillionths of a satoshi."
        },
        "cltv_expiry_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The time-lock delta of the channel."
        }
      }
    },
    "looprpcInQuoteResponse": {
      "type": "object",
      "properties": {
        "swap_fee_sat": {
          "type": "string",
          "format": "int64",
          "description": "The fee that the swap server is charging for the swap."
        },
        "htlc_publish_fee_sat": {
          "type": "string",
          "format": "int64",
          "description": "An estimate of the on-chain fee that needs to be paid to publish the HTLC\nIf a miner fee of 0 is returned, it means the external_htlc flag was set for\na loop in and the fee estimation was skipped. If a miner fee of -1 is\nreturned, it means lnd's wallet tried to estimate the fee but was unable to\ncreate a sample estimation transaction because not enough funds are\navailable. An information message should be shown to the user in this case."
        },
        "cltv_delta": {
          "type": "integer",
          "format": "int32",
          "title": "On-chain cltv expiry delta"
        },
        "conf_target": {
          "type": "integer",
          "format": "int32",
          "description": "The confirmation target to be used to publish the on-chain HTLC."
        },
        "quoted_amt": {
          "type": "string",
          "format": "int64",
          "description": "If the quote request was for a static address loop in and only contained\ndeposit outpoints the quote response will return the total amount of the\nselected deposits."
        }
      }
    },
    "looprpcInTermsResponse": {
      "type": "object",
      "properties": {
        "min_swap_amount": {
          "type": "string",
          "format": "int64",
          "title": "Minimum swap amount (sat)"
        },
        "max_swap_amount": {
          "type": "string",
          "format": "int64",
          "title": "Maximum swap amount (sat)"
        }
      }
    },
    "looprpcInstantOut": {
      "type": "object",
      "properties": {
        "swap_hash": {
          "type": "string",
          "format": "byte",
          "description": "The swap hash that identifies this swap."
        },
        "state": {
          "type": "string",
          "description": "The state the swap is in."
        },
        "amount": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of the swap."
        },
        "reservation_ids": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "The used reservations for the swap."
        },
        "sweep_tx_id": {
          "type": "string",
          "description": "The sweep transaction id of the swap."
        }
      }
    },
    "looprpcInstantOutQuoteResponse": {
      "type": "object",
      "properties": {
        "service_fee_sat": {
          "type": "string",
          "format": "int64",
          "description": "The fee that the swap service is charging for the swap."
        },
        "sweep_fee_sat": {
          "type": "string",
          "format": "int64",
          "description": "The estimated on-chain fee that needs to be paid to publish the Sweepless\nSweep."
        }
      }
    },
    "looprpcInstantOutResponse": {
      "type": "object",
      "properties": {
        "instant_out_hash": {
          "type": "string",
          "format": "byte",
          "description": "The hash of the swap preimage."
        },
        "sweep_tx_id": {
          "type": "string",
          "description": "The transaction id of the sweep transaction."
        },
        "state": {
          "type": "string",
          "description": "The state of the swap."
        }
      }
    },
    "looprpcKeyDescriptor": {
      "type": "object",
      "properties": {
        "raw_key_bytes": {
          "type": "string",
          "format": "byte",
          "description": "The raw bytes of the key being identified."
        },
        "key_loc": {
          "$ref": "#/definitions/looprpcKeyLocator",
          "description": "The key locator that identifies which key to use for signing."
        }
      }
    },
    "looprpcKeyLocator": {
      "type": "object",
      "properties": {
        "key_family": {
          "type": "integer",
          "format": "int32",
          "description": "The family of key being identified."
        },
        "key_index": {
          "type": "integer",
          "format": "int32",
          "description": "The precise index of the key being identified."
        }
      }
    },
    "looprpcL402Token": {
      "type": "object",
      "properties": {
        "base_macaroon": {
          "type": "string",
          "format": "byte",
          "description": "The base macaroon that was baked by the auth server."
        },
        "payment_hash": {
          "type": "string",
          "format": "byte",
          "description": "The payment hash of the payment that was paid to obtain the token."
        },
        "payment_preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage of the payment hash, knowledge of this is proof that the\npayment has been paid. If the preimage is set to all zeros, this means the\npayment is still pending and the token is not yet fully valid."
        },
        "amount_paid_msat": {
          "type": "string",
          "format": "int64",
          "description": "The amount of millisatoshis that was paid to get the token."
        },
        "routing_fee_paid_msat": {
          "type": "string",
          "format": "int64",
          "description": "The amount of millisatoshis paid in routing fee to pay for the token."
        },
        "time_created": {
          "type": "string",
          "format": "int64",
          "description": "The creation time of the token as UNIX timestamp in seconds."
        },
        "expired": {
          "type": "boolean",
          "description": "Indicates whether the token is expired or still valid."
        },
        "storage_name": {
          "type": "string",
          "description": "Identifying attribute of this token in the store. Currently represents the\nfile name of the token where it's stored on the file system."
        },
        "id": {
          "type": "string",
          "description": "The l402 ID of the token."
        }
      }
    },
    "looprpcLiquidityParameters": {
      "type": "object",
      "properties": {
        "rules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcLiquidityRule"
          },
          "description": "A set of liquidity rules that describe the desired liquidity balance."
        },
        "fee_ppm": {
          "type": "string",
          "format": "uint64",
          "description": "The parts per million of swap amount that is allowed to be allocated to swap\nfees. This value is applied across swap categories and may not be set in\nconjunction with sweep fee rate, swap fee ppm, routing fee ppm, prepay\nrouting, max prepay and max miner fee."
        },
        "sweep_fee_rate_sat_per_vbyte": {
          "type": "string",
          "format": "uint64",
          "description": "The limit we place on our estimated sweep cost for a swap in sat/vByte. If\nthe estimated fee for our sweep transaction within the specified\nconfirmation target is above this value, we will not suggest any swaps."
        },
        "max_swap_fee_ppm": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum fee paid to the server for facilitating the swap, expressed\nas parts per million of the swap volume."
        },
        "max_routing_fee_ppm": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum fee paid to route the swap invoice off chain, expressed as\nparts per million of the volume being routed."
        },
        "max_prepay_routing_fee_ppm": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum fee paid to route the prepay invoice off chain, expressed as\nparts per million of the volume being routed."
        },
        "max_prepay_sat": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum no-show penalty in satoshis paid for a swap."
        },
        "max_miner_fee_sat": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum miner fee we will pay to sweep the swap on chain. Note that we\nwill not suggest a swap if the estimate is above the sweep limit set by\nthese parameters, and we use the current fee estimate to sweep on chain so\nthis value is only a cap placed on the amount we spend on fees in the case\nwhere the swap needs to be claimed on chain, but fees have suddenly spiked."
        },
        "sweep_conf_target": {
          "type": "integer",
          "format": "int32",
          "description": "The number of blocks from the on-chain HTLC's confirmation height that it\nshould be swept within."
        },
        "failure_backoff_sec": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of time we require pass since a channel was part of a failed\nswap due to off chain payment failure until it will be considered for swap\nsuggestions again, expressed in seconds."
        },
        "autoloop": {
          "type": "boolean",
          "description": "Set to true to enable automatic dispatch of swaps. All swaps will be limited\nto the fee categories set by these parameters, and total expenditure will\nbe limited to the autoloop budget."
        },
        "autoloop_budget_sat": {
          "type": "string",
          "format": "uint64",
          "description": "The total budget for automatically dispatched swaps since the budget start\ntime, expressed in satoshis."
        },
        "autoloop_budget_start_sec": {
          "type": "string",
          "format": "uint64",
          "description": "Deprecated, use autoloop_budget_refresh_period_sec. The start time for\nautoloop budget, expressed as a unix timestamp in seconds. If this value is\n0, the budget will be applied for all automatically dispatched swaps. Swaps\nthat were completed before this date will not be included in budget\ncalculations."
        },
        "auto_max_in_flight": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum number of automatically dispatched swaps that we allow to be in\nflight at any point in time."
        },
        "min_swap_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The minimum amount, expressed in satoshis, that the autoloop client will\ndispatch a swap for. This value is subject to the server-side limits\nspecified by the LoopOutTerms endpoint."
        },
        "max_swap_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum amount, expressed in satoshis, that the autoloop client will\ndispatch a swap for. This value is subject to the server-side limits\nspecified by the LoopOutTerms endpoint."
        },
        "htlc_conf_target": {
          "type": "integer",
          "format": "int32",
          "description": "The confirmation target for loop in on-chain htlcs."
        },
        "autoloop_dest_address": {
          "type": "string",
          "description": "The destination address to use for autoloop loop outs. Set to \"default\" in\norder to revert to default behavior."
        },
        "autoloop_budget_refresh_period_sec": {
          "type": "string",
          "format": "uint64",
          "description": "The period over which the autoloop budget is refreshed, expressed in\nseconds."
        },
        "autoloop_budget_last_refresh": {
          "type": "string",
          "format": "uint64",
          "description": "The time at which the autoloop budget was last refreshed, expressed as a\nUNIX timestamp in seconds."
        },
        "easy_autoloop": {
          "type": "boolean",
          "description": "Set to true to enable easy autoloop. If set, all channel/peer rules will be\noverridden and the client will automatically dispatch swaps in order to meet\nthe configured local balance target size. Currently only loop out is\nsupported, meaning that easy autoloop can only reduce the funds that are\nheld as balance in channels."
        },
        "easy_autoloop_local_target_sat": {
          "type": "string",
          "format": "uint64",
          "description": "The local balance target size, expressed in satoshis. This is used by easy\nautoloop to determine how much liquidity should be maintained in channels."
        },
        "account": {
          "type": "string",
          "description": "An alternative destination address source for the swap. This field\nrepresents the name of the account in the backing lnd instance.\nRefer to lnd's wallet import functions for reference."
        },
        "account_addr_type": {
          "$ref": "#/definitions/looprpcAddressType",
          "description": "The address type of the account specified in the account field."
        },
        "easy_asset_params": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/looprpcEasyAssetAutoloopParams"
          },
          "description": "A map of asset parameters to use for swaps. The key is the asset id and the\nvalue is the parameters to use for swaps in that asset."
        },
        "fast_swap_publication": {
          "type": "boolean",
          "description": "Set to true to enable fast swap publication. If set, the server will\npublish the HTLC immediately after receiving the swap request. This\nsetting has direct implications on the swap fees, as fast swaps may\nnot be able to be batched with other swaps."
        }
      }
    },
    "looprpcLiquidityRule": {
      "type": "object",
      "properties": {
        "channel_id": {
          "type": "string",
          "format": "uint64",
          "description": "The short channel ID of the channel that this rule should be applied to.\nThis field may not be set when the pubkey field is set."
        },
        "swap_type": {
          "$ref": "#/definitions/looprpcSwapType",
          "description": "The type of swap that will be dispatched for this rule."
        },
        "pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The public key of the peer that this rule should be applied to. This field\nmay not be set when the channel id field is set."
        },
        "type": {
          "$ref": "#/definitions/looprpcLiquidityRuleType",
          "description": "Type indicates the type of rule that this message rule represents. Setting\nthis value will determine which fields are used in the message. The comments\non each field in this message will be prefixed with the LiquidityRuleType\nthey belong to."
        },
        "incoming_threshold": {
          "type": "integer",
          "format": "int64",
          "description": "THRESHOLD: The percentage of total capacity that incoming capacity should\nnot drop beneath."
        },
        "outgoing_threshold": {
          "type": "integer",
          "format": "int64",
          "description": "THRESHOLD: The percentage of total capacity that outgoing capacity should\nnot drop beneath."
        }
      }
    },
    "looprpcLiquidityRuleType": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "THRESHOLD"
      ],
      "default": "UNKNOWN"
    },
    "looprpcListInstantOutsResponse": {
      "type": "object",
      "properties": {
        "swaps": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcInstantOut"
          },
          "description": "The list of all currently known instant out swaps and their status."
        }
      }
    },
    "looprpcListReservationsResponse": {
      "type": "object",
      "properties": {
        "reservations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcClientReservation"
          },
          "description": "The list of all currently known reservations and their status."
        }
      }
    },
    "looprpcListStaticAddressDepositsResponse": {
      "type": "object",
      "properties": {
        "filtered_deposits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcDeposit"
          },
          "description": "A list of all deposits that match the filtered state."
        }
      }
    },
    "looprpcListStaticAddressSwapsResponse": {
      "type": "object",
      "properties": {
        "swaps": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcStaticAddressLoopInSwap"
          },
          "description": "A list of all swaps known static address loop-in swaps."
        }
      }
    },
    "looprpcListStaticAddressWithdrawalResponse": {
      "type": "object",
      "properties": {
        "withdrawals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcStaticAddressWithdrawal"
          },
          "description": "A list of all static address withdrawals."
        }
      }
    },
    "looprpcListSwapsFilter": {
      "type": "object",
      "properties": {
        "swap_type": {
          "$ref": "#/definitions/ListSwapsFilterSwapTypeFilter",
          "description": "The type of the swap."
        },
        "pending_only": {
          "type": "boolean",
          "description": "If set, only pending swaps are returned."
        },
        "outgoing_chan_set": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "description": "If specified on creation, the outgoing channel set of the swap."
        },
        "label": {
          "type": "string",
          "description": "Label of swap to filter for."
        },
        "loop_in_last_hop": {
          "type": "string",
          "format": "byte",
          "description": "If specified on creation, the last hop of the swap."
        },
        "asset_swap_only": {
          "type": "boolean",
          "description": "If specified, only returns asset swaps."
        },
        "start_timestamp_ns": {
          "type": "string",
          "format": "int64",
          "description": "If specified, returns swaps initiated after this Unix (ns) timestamp."
        }
      }
    },
    "looprpcListSwapsResponse": {
      "type": "object",
      "properties": {
        "swaps": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcSwapStatus"
          },
          "description": "The list of all currently known swaps and their status."
        },
        "next_start_time": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp to use for paging start_timestamp_ns."
        }
      }
    },
    "looprpcListUnspentDepositsResponse": {
      "type": "object",
      "properties": {
        "utxos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcUtxo"
          },
          "description": "A list of utxos behind the static address."
        }
      }
    },
    "looprpcLoopInRequest": {
      "type": "object",
      "properties": {
        "amt": {
          "type": "string",
          "format": "int64",
          "description": "Requested swap amount in sat. This does not include the swap and miner\nfee."
        },
        "max_swap_fee": {
          "type": "string",
          "format": "int64",
          "description": "Maximum we are willing to pay the server for the swap. This value is not\ndisclosed in the swap initiation call, but if the server asks for a\nhigher fee, we abort the swap. Typically this value is taken from the\nresponse of the GetQuote call."
        },
        "max_miner_fee": {
          "type": "string",
          "format": "int64",
          "description": "Maximum in on-chain fees that we are willing to spend. If we want to\npublish the on-chain htlc and the fee estimate turns out higher than this\nvalue, we cancel the swap.\n\nmax_miner_fee is typically taken from the response of the GetQuote call."
        },
        "last_hop": {
          "type": "string",
          "format": "byte",
          "description": "The last hop to use for the loop in swap. If empty, the last hop is selected\nbased on the lowest routing fee for the swap payment from the server."
        },
        "external_htlc": {
          "type": "boolean",
          "description": "If external_htlc is true, we expect the htlc to be published by an external\nactor."
        },
        "htlc_conf_target": {
          "type": "integer",
          "format": "int32",
          "description": "The number of blocks that the on chain htlc should confirm within."
        },
        "label": {
          "type": "string",
          "description": "An optional label for this swap. This field is limited to 500 characters\nand may not be one of the reserved values in loop/labels Reserved list."
        },
        "initiator": {
          "type": "string",
          "description": "An optional identification string that will be appended to the user agent\nstring sent to the server to give information about the usage of loop. This\ninitiator part is meant for user interfaces to add their name to give the\nfull picture of the binary used (loopd, LiT) and the method used for\ntriggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI)."
        },
        "route_hints": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcRouteHint"
          },
          "description": "Optional route hints to reach the destination through private channels."
        },
        "private": {
          "type": "boolean",
          "description": "Private indicates whether the destination node should be considered\nprivate. In which case, loop will generate hophints to assist with\nprobing and payment."
        }
      }
    },
    "looprpcLoopOutRequest": {
      "type": "object",
      "properties": {
        "amt": {
          "type": "string",
          "format": "int64",
          "description": "Requested swap amount in sat. This does not include the swap and miner fee."
        },
        "dest": {
          "type": "string",
          "description": "Base58 encoded destination address for the swap."
        },
        "max_swap_routing_fee": {
          "type": "string",
          "format": "int64",
          "description": "Maximum off-chain fee in sat that may be paid for swap payment to the\nserver. This limit is applied during path finding. Typically this value is\ntaken from the response of the GetQuote call."
        },
        "max_prepay_routing_fee": {
          "type": "string",
          "format": "int64",
          "description": "Maximum off-chain fee in sat that may be paid for the prepay to the server.\nThis limit is applied during path finding. Typically this value is taken\nfrom the response of the GetQuote call."
        },
        "max_swap_fee": {
          "type": "string",
          "format": "int64",
          "description": "Maximum we are willing to pay the server for the swap. This value is not\ndisclosed in the swap initiation call, but if the server asks for a\nhigher fee, we abort the swap. Typically this value is taken from the\nresponse of the GetQuote call. It includes the prepay amount."
        },
        "max_prepay_amt": {
          "type": "string",
          "format": "int64",
          "description": "Maximum amount of the swap fee that may be charged as a prepayment."
        },
        "max_miner_fee": {
          "type": "string",
          "format": "int64",
          "description": "Maximum in on-chain fees that we are willing to spend. If we want to\nsweep the on-chain htlc and the fee estimate turns out higher than this\nvalue, we cancel the swap. If the fee estimate is lower, we publish the\nsweep tx.\n\nIf the sweep tx is not confirmed, we are forced to ratchet up fees until it\nis swept. Possibly even exceeding max_miner_fee if we get close to the htlc\ntimeout. Because the initial publication revealed the preimage, we have no\nother choice. The server may already have pulled the off-chain htlc. Only\nwhen the fee becomes higher than the swap amount, we can only wait for fees\nto come down and hope - if we are past the timeout - that the server is not\npublishing the revocation.\n\nmax_miner_fee is typically taken from the response of the GetQuote call."
        },
        "loop_out_channel": {
          "type": "string",
          "format": "uint64",
          "description": "Deprecated, use outgoing_chan_set. The channel to loop out, the channel\nto loop out is selected based on the lowest routing fee for the swap\npayment to the server."
        },
        "outgoing_chan_set": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "description": "A restriction on the channel set that may be used to loop out. The actual\nchannel(s) that will be used are selected based on the lowest routing fee\nfor the swap payment to the server."
        },
        "sweep_conf_target": {
          "type": "integer",
          "format": "int32",
          "description": "The number of blocks from the on-chain HTLC's confirmation height that it\nshould be swept within."
        },
        "htlc_confirmations": {
          "type": "integer",
          "format": "int32",
          "description": "The number of confirmations that we require for the on chain htlc that will\nbe published by the server before we reveal the preimage."
        },
        "swap_publication_deadline": {
          "type": "string",
          "format": "uint64",
          "description": "The latest time (in unix seconds) we allow the server to wait before\npublishing the HTLC on chain. Setting this to a larger value will give the\nserver the opportunity to batch multiple swaps together, and wait for\nlow-fee periods before publishing the HTLC, potentially resulting in a\nlower total swap fee."
        },
        "label": {
          "type": "string",
          "description": "An optional label for this swap. This field is limited to 500 characters\nand may not start with the prefix [reserved], which is used to tag labels\nproduced by the daemon."
        },
        "initiator": {
          "type": "string",
          "description": "An optional identification string that will be appended to the user agent\nstring sent to the server to give information about the usage of loop. This\ninitiator part is meant for user interfaces to add their name to give the\nfull picture of the binary used (loopd, LiT) and the method used for\ntriggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI)."
        },
        "account": {
          "type": "string",
          "description": "An alternative destination address source for the swap. This field\nrepresents the name of the account in the backing lnd instance.\nRefer to lnd's wallet import functions for reference."
        },
        "account_addr_type": {
          "$ref": "#/definitions/looprpcAddressType",
          "description": "The address type of the account specified in the account field."
        },
        "is_external_addr": {
          "type": "boolean",
          "description": "A flag indicating whether the defined destination address does not belong to\nthe wallet. This is used to flag whether this loop out swap could have its\nassociated sweep batched."
        },
        "reservation_ids": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "The reservations to use for the swap. If this field is set, loop will try\nto use the instant out flow using the given reservations. If the\nreservations are not sufficient, the swap will fail. The swap amount must\nbe equal to the sum of the amounts of the reservations."
        },
        "payment_timeout": {
          "type": "integer",
          "format": "int64",
          "description": "The timeout in seconds to use for off-chain payments. Note that the swap\npayment is attempted multiple times where each attempt will set this value\nas the timeout for the payment."
        },
        "asset_info": {
          "$ref": "#/definitions/looprpcAssetLoopOutRequest",
          "description": "The optional asset information to use for the swap. If set, the swap will\nbe paid in the specified asset using the provided edge node. An Asset client\nmust be connected to the loop client to use this feature."
        },
        "asset_rfq_info": {
          "$ref": "#/definitions/looprpcAssetRfqInfo",
          "description": "The optional RFQ information to use for the swap. If set, the swap will\nuse the provided RFQs to pay for the swap invoice."
        }
      }
    },
    "looprpcLoopStats": {
      "type": "object",
      "properties": {
        "pending_count": {
          "type": "string",
          "format": "uint64",
          "description": "Number of currently pending swaps."
        },
        "success_count": {
          "type": "string",
          "format": "uint64",
          "description": "Number of succeeded swaps."
        },
        "fail_count": {
          "type": "string",
          "format": "uint64",
          "description": "Number failed swaps."
        },
        "sum_pending_amt": {
          "type": "string",
          "format": "int64",
          "description": "The sum of all pending swap amounts."
        },
        "sum_succeeded_amt": {
          "type": "string",
          "format": "int64",
          "description": "The sum of all succeeded swap amounts."
        }
      }
    },
    "looprpcNewStaticAddressResponse": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "The taproot static address."
        },
        "expiry": {
          "type": "integer",
          "format": "int64",
          "description": "The CSV expiry of the static address."
        }
      }
    },
    "looprpcOutPoint": {
      "type": "object",
      "properties": {
        "txid_bytes": {
          "type": "string",
          "format": "byte",
          "description": "Raw bytes representing the transaction id."
        },
        "txid_str": {
          "type": "string",
          "description": "Reversed, hex-encoded string representing the transaction id."
        },
        "output_index": {
          "type": "integer",
          "format": "int64",
          "description": "The index of the output on the transaction."
        }
      }
    },
    "looprpcOutQuoteResponse": {
      "type": "object",
      "properties": {
        "swap_fee_sat": {
          "type": "string",
          "format": "int64",
          "description": "The fee that the swap server is charging for the swap."
        },
        "prepay_amt_sat": {
          "type": "string",
          "format": "int64",
          "description": "The part of the swap fee that is requested as a prepayment."
        },
        "htlc_sweep_fee_sat": {
          "type": "string",
          "format": "int64",
          "description": "An estimate of the on-chain fee that needs to be paid to sweep the HTLC for\na loop out."
        },
        "swap_payment_dest": {
          "type": "string",
          "format": "byte",
          "description": "The node pubkey where the swap payment needs to be paid\nto. This can be used to test connectivity before initiating the swap."
        },
        "cltv_delta": {
          "type": "integer",
          "format": "int32",
          "title": "On-chain cltv expiry delta"
        },
        "conf_target": {
          "type": "integer",
          "format": "int32",
          "description": "The confirmation target to be used for the sweep of the on-chain HTLC."
        },
        "asset_rfq_info": {
          "$ref": "#/definitions/looprpcAssetRfqInfo",
          "description": "If the request was for an asset swap, the quote will return the rfq ids\nthat will be used to pay for the swap and prepay invoices."
        }
      }
    },
    "looprpcOutTermsResponse": {
      "type": "object",
      "properties": {
        "min_swap_amount": {
          "type": "string",
          "format": "int64",
          "title": "Minimum swap amount (sat)"
        },
        "max_swap_amount": {
          "type": "string",
          "format": "int64",
          "title": "Maximum swap amount (sat)"
        },
        "min_cltv_delta": {
          "type": "integer",
          "format": "int32",
          "description": "The minimally accepted cltv delta of the on-chain htlc."
        },
        "max_cltv_delta": {
          "type": "integer",
          "format": "int32",
          "description": "The maximally accepted cltv delta of the on-chain htlc."
        }
      }
    },
    "looprpcProbeResponse": {
      "type": "object"
    },
    "looprpcPsbtShim": {
      "type": "object",
      "properties": {
        "pending_chan_id": {
          "type": "string",
          "format": "byte",
          "description": "A unique identifier of 32 random bytes that will be used as the pending\nchannel ID to identify the PSBT state machine when interacting with it and\non the wire protocol to initiate the funding request."
        },
        "base_psbt": {
          "type": "string",
          "format": "byte",
          "description": "An optional base PSBT the new channel output will be added to. If this is\nnon-empty, it must be a binary serialized PSBT."
        },
        "no_publish": {
          "type": "boolean",
          "description": "If a channel should be part of a batch (multiple channel openings in one\ntransaction), it can be dangerous if the whole batch transaction is\npublished too early before all channel opening negotiations are completed.\nThis flag prevents this particular channel from broadcasting the transaction\nafter the negotiation with the remote peer. In a batch of channel openings\nthis flag should be set to true for every channel but the very last."
        }
      }
    },
    "looprpcRouteHint": {
      "type": "object",
      "properties": {
        "hop_hints": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcHopHint"
          },
          "description": "A list of hop hints that when chained together can assist in reaching a\nspecific destination."
        }
      }
    },
    "looprpcSetLiquidityParamsRequest": {
      "type": "object",
      "properties": {
        "parameters": {
          "$ref": "#/definitions/looprpcLiquidityParameters",
          "description": "Parameters is the desired new set of parameters for the liquidity management\nsubsystem. Note that the current set of parameters will be completely\noverwritten by the parameters provided (if they are valid), so the full set\nof parameters should be provided for each call."
        }
      }
    },
    "looprpcSetLiquidityParamsResponse": {
      "type": "object"
    },
    "looprpcStaticAddressLoopInResponse": {
      "type": "object",
      "properties": {
        "swap_hash": {
          "type": "string",
          "format": "byte",
          "description": "The swap hash that identifies this swap."
        },
        "state": {
          "type": "string",
          "description": "The state the swap is in."
        },
        "amount": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of the swap."
        },
        "htlc_cltv": {
          "type": "integer",
          "format": "int32",
          "description": "The htlc cltv expiry height of the swap."
        },
        "quoted_swap_fee_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The quoted swap fee in satoshis."
        },
        "max_swap_fee_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The maximum total swap fee the client is willing to pay for the swap."
        },
        "initiation_height": {
          "type": "integer",
          "format": "int64",
          "description": "The block height at which the swap was initiated."
        },
        "protocol_version": {
          "type": "string",
          "description": "The static address protocol version."
        },
        "label": {
          "type": "string",
          "description": "An optional label for this swap."
        },
        "initiator": {
          "type": "string",
          "description": "An optional identification string that will be appended to the user agent\nstring sent to the server to give information about the usage of loop. This\ninitiator part is meant for user interfaces to add their name to give the\nfull picture of the binary used (loopd, LiT) and the method used for\ntriggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI)."
        },
        "payment_timeout_seconds": {
          "type": "integer",
          "format": "int64",
          "description": "The swap payment timeout allows the user to specify an upper limit for the\namount of time the server is allowed to take to fulfill the off-chain swap\npayment. If the timeout is reached the swap will be aborted on the server\nside and the client can retry the swap with different parameters."
        },
        "used_deposits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcDeposit"
          },
          "description": "The deposits that are used for this swap."
        },
        "swap_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The amount that is being swapped (may be less than total deposit value if\nchange is returned)."
        },
        "change": {
          "type": "string",
          "format": "int64",
          "description": "The change amount that will be returned to the static address."
        },
        "fast": {
          "type": "boolean",
          "description": "If set, indicates that the server was requested to use fast publication\nbehavior."
        }
      }
    },
    "looprpcStaticAddressLoopInSwap": {
      "type": "object",
      "properties": {
        "swap_hash": {
          "type": "string",
          "format": "byte",
          "description": "The swap hash of the swap. It represents the unique identifier of the swap."
        },
        "deposit_outpoints": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "state": {
          "$ref": "#/definitions/looprpcStaticAddressLoopInSwapState"
        },
        "swap_amount_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The swap amount of the swap. It is the sum of the values of the deposit\noutpoints that were used for this swap."
        },
        "payment_request_amount_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The invoiced swap amount. It is the swap amount minus the quoted server\nfees."
        },
        "deposits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcDeposit"
          },
          "description": "The deposits that were used for this swap."
        }
      }
    },
    "looprpcStaticAddressLoopInSwapState": {
      "type": "string",
      "enum": [
        "UNKNOWN_STATIC_ADDRESS_SWAP_STATE",
        "INIT_HTLC",
        "SIGN_HTLC_TX",
        "MONITOR_INVOICE_HTLC_TX",
        "PAYMENT_RECEIVED",
        "SWEEP_STATIC_ADDRESS_HTLC_TIMEOUT",
        "MONITOR_HTLC_TIMEOUT_SWEEP",
        "HTLC_STATIC_ADDRESS_TIMEOUT_SWEPT",
        "SUCCEEDED",
        "SUCCEEDED_TRANSITIONING_FAILED",
        "UNLOCK_DEPOSITS",
        "FAILED_STATIC_ADDRESS_SWAP"
      ],
      "default": "UNKNOWN_STATIC_ADDRESS_SWAP_STATE"
    },
    "looprpcStaticAddressSummaryResponse": {
      "type": "object",
      "properties": {
        "static_address": {
          "type": "string",
          "description": "The static address of the client."
        },
        "relative_expiry_blocks": {
          "type": "string",
          "format": "uint64",
          "description": "The CSV expiry of the static address."
        },
        "total_num_deposits": {
          "type": "integer",
          "format": "int64",
          "description": "The total number of deposits."
        },
        "value_unconfirmed_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The total value of unconfirmed deposits."
        },
        "value_deposited_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The total value of confirmed deposits."
        },
        "value_expired_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The total value of all expired deposits."
        },
        "value_withdrawn_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The total value of all deposits that have been withdrawn."
        },
        "value_looped_in_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The total value of all loop-ins that have been finalized."
        },
        "value_htlc_timeout_sweeps_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The total value of all htlc timeout sweeps that the client swept."
        },
        "value_channels_opened": {
          "type": "string",
          "format": "int64",
          "description": "The total value of all deposits that have been used for channel openings."
        }
      }
    },
    "looprpcStaticAddressWithdrawal": {
      "type": "object",
      "properties": {
        "tx_id": {
          "type": "string",
          "description": "The transaction id of the withdrawal transaction."
        },
        "deposits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcDeposit"
          },
          "description": "The selected deposits that is withdrawn from."
        },
        "total_deposit_amount_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The sum of the deposit values that was selected for withdrawal."
        },
        "withdrawn_amount_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "The actual amount that was withdrawn from the selected deposits. This value\nrepresents the sum of selected deposit values minus tx fees minus optional\nchange output."
        },
        "change_amount_satoshis": {
          "type": "string",
          "format": "int64",
          "description": "An optional change."
        },
        "confirmation_height": {
          "type": "integer",
          "format": "int64",
          "description": "The confirmation block height of the withdrawal transaction."
        }
      }
    },
    "looprpcStaticOpenChannelResponse": {
      "type": "object",
      "properties": {
        "channel_open_tx_hash": {
          "type": "string",
          "description": "The transaction hash of the channel opening transaction."
        },
        "error": {
          "type": "string",
          "description": "An optional error string."
        }
      }
    },
    "looprpcSuggestSwapsResponse": {
      "type": "object",
      "properties": {
        "loop_out": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcLoopOutRequest"
          },
          "description": "The set of recommended loop outs."
        },
        "loop_in": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcLoopInRequest"
          },
          "title": "The set of recommended loop in swaps"
        },
        "disqualified": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcDisqualified"
          },
          "description": "Disqualified contains the set of channels that swaps are not recommended\nfor."
        }
      }
    },
    "looprpcSwapResponse": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Swap identifier to track status in the update stream that is returned from\nthe Start() call. Currently this is the hash that locks the htlcs.\nDEPRECATED: To make the API more consistent, this field is deprecated in\nfavor of id_bytes and will be removed in a future release."
        },
        "id_bytes": {
          "type": "string",
          "format": "byte",
          "description": "Swap identifier to track status in the update stream that is returned from\nthe Start() call. Currently this is the hash that locks the htlcs."
        },
        "htlc_address": {
          "type": "string",
          "description": "DEPRECATED. This field stores the address of the onchain htlc, but\ndepending on the request, the semantics are different.\n- For internal loop-in htlc_address contains the address of the\nnative segwit (P2WSH) htlc.\n/    - For loop-out htlc_address always contains the native segwit (P2WSH)\nhtlc address."
        },
        "htlc_address_p2wsh": {
          "type": "string",
          "description": "The native segwit address of the on-chain htlc.\nUsed for both loop-in and loop-out."
        },
        "htlc_address_p2tr": {
          "type": "string",
          "description": "The address of the v3 (taproot) htlc. Used for both loop-in and loop-out."
        },
        "server_message": {
          "type": "string",
          "description": "A human-readable message received from the loop server."
        }
      }
    },
    "looprpcSwapState": {
      "type": "string",
      "enum": [
        "INITIATED",
        "PREIMAGE_REVEALED",
        "HTLC_PUBLISHED",
        "SUCCESS",
        "FAILED",
        "INVOICE_SETTLED"
      ],
      "default": "INITIATED",
      "description": " - INITIATED: INITIATED is the initial state of a swap. At that point, the initiation\ncall to the server has been made and the payment process has been started\nfor the swap and prepayment invoices.\n - PREIMAGE_REVEALED: PREIMAGE_REVEALED is reached when the sweep tx publication is first\nattempted. From that point on, we should consider the preimage to no\nlonger be secret and we need to do all we can to get the sweep confirmed.\nThis state will mostly coalesce with StateHtlcConfirmed, except in the\ncase where we wait for fees to come down before we sweep.\n - HTLC_PUBLISHED: HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in\nswap.\n - SUCCESS: SUCCESS is the final swap state that is reached when the sweep tx has\nthe required confirmation depth.\n - FAILED: FAILED is the final swap state for a failed swap with or without loss of\nthe swap amount.\n - INVOICE_SETTLED: INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been\npaid, but we are still waiting for the htlc spend to confirm."
    },
    "looprpcSwapStatus": {
      "type": "object",
      "properties": {
        "amt": {
          "type": "string",
          "format": "int64",
          "description": "Requested swap amount in sat. This does not include the swap and miner\nfee."
        },
        "id": {
          "type": "string",
          "description": "Swap identifier to track status in the update stream that is returned from\nthe Start() call. Currently this is the hash that locks the htlcs.\nDEPRECATED: To make the API more consistent, this field is deprecated in\nfavor of id_bytes and will be removed in a future release."
        },
        "id_bytes": {
          "type": "string",
          "format": "byte",
          "description": "Swap identifier to track status in the update stream that is returned from\nthe Start() call. Currently this is the hash that locks the htlcs."
        },
        "type": {
          "$ref": "#/definitions/looprpcSwapType",
          "description": "The type of the swap."
        },
        "state": {
          "$ref": "#/definitions/looprpcSwapState",
          "description": "State the swap is currently in, see State enum."
        },
        "failure_reason": {
          "$ref": "#/definitions/looprpcFailureReason",
          "description": "A failure reason for the swap, only set if the swap has failed."
        },
        "initiation_time": {
          "type": "string",
          "format": "int64",
          "description": "Initiation time of the swap."
        },
        "last_update_time": {
          "type": "string",
          "format": "int64",
          "description": "Initiation time of the swap."
        },
        "htlc_address": {
          "type": "string",
          "description": "DEPRECATED:  This field stores the address of the onchain htlc.\n- For internal loop-in htlc_address contains the address of the\nnative segwit (P2WSH) htlc.\n- For loop-out htlc_address always contains the native segwit (P2WSH)\nhtlc address."
        },
        "htlc_address_p2wsh": {
          "type": "string",
          "description": "HTLC address (native segwit), used in loop-in and loop-out swaps."
        },
        "htlc_address_p2tr": {
          "type": "string",
          "description": "The address of the v3 (taproot) htlc. Used for both loop-in and loop-out."
        },
        "cost_server": {
          "type": "string",
          "format": "int64",
          "title": "Swap server cost"
        },
        "cost_onchain": {
          "type": "string",
          "format": "int64",
          "title": "On-chain transaction cost"
        },
        "cost_offchain": {
          "type": "string",
          "format": "int64",
          "title": "Off-chain routing fees"
        },
        "last_hop": {
          "type": "string",
          "format": "byte",
          "description": "Optional last hop if provided in the loop in request."
        },
        "outgoing_chan_set": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "description": "Optional outgoing channel set if provided in the loop out request."
        },
        "label": {
          "type": "string",
          "description": "An optional label given to the swap on creation."
        },
        "asset_info": {
          "$ref": "#/definitions/looprpcAssetLoopOutInfo",
          "description": "If the swap was an asset swap, the asset information will be returned."
        }
      }
    },
    "looprpcSwapType": {
      "type": "string",
      "enum": [
        "LOOP_OUT",
        "LOOP_IN"
      ],
      "default": "LOOP_OUT",
      "title": "- LOOP_OUT: LOOP_OUT indicates an loop out swap (off-chain to on-chain)\n - LOOP_IN: LOOP_IN indicates a loop in swap (on-chain to off-chain)"
    },
    "looprpcTokensResponse": {
      "type": "object",
      "properties": {
        "tokens": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/looprpcL402Token"
          },
          "description": "List of all tokens the daemon knows of, including old/expired tokens."
        }
      }
    },
    "looprpcUtxo": {
      "type": "object",
      "properties": {
        "static_address": {
          "type": "string",
          "description": "The static address of the utxo."
        },
        "amount_sat": {
          "type": "string",
          "format": "int64",
          "description": "The value of the unspent coin in satoshis."
        },
        "outpoint": {
          "type": "string",
          "description": "The outpoint in the form txid:index."
        },
        "confirmations": {
          "type": "string",
          "format": "int64",
          "description": "The number of confirmations for the Utxo."
        }
      }
    },
    "looprpcWithdrawDepositsResponse": {
      "type": "object",
      "properties": {
        "withdrawal_tx_hash": {
          "type": "string",
          "description": "The transaction hash of the withdrawal transaction."
        },
        "address": {
          "type": "string",
          "description": "The destination address of the withdrawal transaction."
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    }
  }
}
